export const metadata = {
  title: "API Connector Specification",
  description: "Complete specification for implementing robust, production-ready API connectors"
}

## API Connector Specification

This specification defines the requirements for implementing a robust, production‑ready API connector.
The connector must be language‑agnostic. Any illustrative snippets must be treated as pseudocode, not tied to a specific language or framework.

### Scope and Principles

- **Language‑agnostic**: The spec describes behaviors, contracts, and data shapes, not language constructs.
- **Separation of concerns**: Request execution, authentication, retries, rate limits, and pagination are composable, swappable modules.
- **Deterministic, observable, testable**: Deterministic defaults, structured logs/metrics/traces, and clear test surfaces.
- **Secure by default**: Credentials are redacted, transport is encrypted where applicable, and inputs/outputs are validated.
- **Resilient**: Backoff with jitter, circuit breaking, idempotency, and graceful degradation built in.
- **Extensible**: Hooks/middleware enable customization without forking core.

### Core Package Architecture

All API connectors must extend the `@connector-factory/core` package which provides standardized base classes and utilities.

#### Required Dependencies

```json
{
  "dependencies": {
    "@connector-factory/core": "workspace:*",
    "ajv": "^8.17.1",
    "ajv-formats": "^3.0.1",
    "zod": "^3.25.8"
  }
}
```

#### Base Class Extension

Every connector must extend `ApiConnectorBase` from `@connector-factory/core`:

```typescript
import { ApiConnectorBase, type RateLimitOptions } from '@connector-factory/core'

export class MyApiConnector extends ApiConnectorBase implements MyConnector {
  initialize(userConfig: ConnectorConfig) {
    super.initialize(userConfig, withDefaults, authFunction, rateLimitOptions)
  }
}
```

#### Domain-Based Architecture

- Organize code by domains rather than individual resources
- Each domain module lives under `src/domains/{resource}.ts` and uses:
  - `buildResourceDomain(send)` factory that returns a CRUD surface
  - Built on `makeCrudDomain` utility from core patterns
  - Operations: `list`, `get`, `streamAll`, `getAll`
- Models organized under `src/models/{resource}/` with:
  - `{resource}.ts` - main model definition
  - `{resource}-api-contracts.ts` - API response types
  - `index.ts` - exports

#### Domain Factory Pattern

```typescript
import { makeCrudDomain } from '../core/make-crud-domain'
import type { SendFn } from '@connector-factory/core'

export function buildContactsDomain(send: SendFn) {
  const base = makeCrudDomain<Contact, ContactsResponse, ContactResponse>('/contacts', send)
  return {
    listContacts: base.list,
    getContact: base.get,
    streamContacts: base.streamAll,
    getContacts: base.getAll
  }
}
```

### Core Modules and Methods

Every API connector must implement the following core functionality:


#### Initialization and Lifecycle

The `ApiConnectorBase` class provides these methods which your connector inherits:

- **initialize(configuration, defaults, authFunction, rateLimitOptions)**  
  Extends the base initialization with your configuration defaults, authentication strategy, and rate limiting options.

- **connect()**  
  Inherited from base class - establishes connection state.

- **disconnect()**  
  Inherited from base class - gracefully closes connection.

- **isConnected()**  
  Inherited from base class - returns connection status.

#### Domain Delegation Pattern

Connectors expose methods that delegate to domain builders:

```typescript
private get domain() {
  const sendLite: SendFn = async (args) => this.send<any>(args)
  return {
    ...buildContactsDomain((args) => sendLite({ ...args, operation: 'contacts' })),
    ...buildCompaniesDomain((args) => sendLite({ ...args, operation: 'companies' }))
  }
}

// Public methods delegate to domains
listContacts = (params?) => this.domain.listContacts(params)
getContact = (params) => this.domain.getContact(params)
```

#### Request Methods

The `ApiConnectorBase` provides the core request infrastructure:

- **send<T>(options)**  
  Protected method for making HTTP requests with full rate limiting, retry logic, and hooks.  
  Automatically handles authentication, rate limiting, and response wrapping.

- **request(options)**  
  Public alias for `send()` method - inherited from base class.

#### HTTP Client Integration

The base class uses `HttpClient` from core package which provides:
- Automatic retry with exponential backoff
- Rate limiting with `TokenBucketLimiter`
- Hook system for middleware
- Response envelope wrapping
- Error handling and classification

#### Advanced Operations

- **batch(requests)**  
  Executes multiple requests in a single operation where supported by the API. Should handle partial failures gracefully.

- **paginate(options)**  
  Returns an iterator that automatically handles pagination, fetching subsequent pages as needed. Should support different pagination strategies. Resource modules should consume this via the shared lib.

#### Optional Operations (if applicable)

- **stream(options)**  
  Reads streaming responses (e.g., chunked, SSE) with backpressure and cancellation.

### Configuration Structure

The connector configuration should support the following settings:

#### Base Configuration

- **baseUrl** - The base URL for all API requests
- **timeout** - Request timeout in milliseconds (default: 30000)
- **userAgent** - Identifier for outbound requests (include app version/commit when available)
- **proxy** - Optional proxy configuration (host, port, protocol, credentials)
- **tls** - TLS options (verify, min version, CA bundle, mTLS certificates) where applicable
- **pooling** - Connection pooling/keep‑alive settings

#### Authentication Configuration

Support for multiple authentication types:

- **type** - One of: api_key, bearer, basic, oauth2, or custom
- **credentials** - Authentication credentials specific to the chosen type

#### Retry Configuration

- **maxAttempts** - Maximum number of retry attempts (default: 3)
- **initialDelay** - Initial retry delay in milliseconds (default: 1000)
- **maxDelay** - Maximum retry delay in milliseconds (default: 30000)
- **backoffMultiplier** - Multiplier for exponential backoff (default: 2)
- **retryableStatusCodes** - HTTP status codes that trigger retries (default: [429, 500, 502, 503, 504])
- **retryableErrors** - Error types/codes that should trigger retries
- **retryBudgetMs** - Hard cap on total time spent retrying a single logical operation
- **respectRetryAfter** - Whether to honor server Retry‑After hints (default: true)
- **idempotency** - Enable idempotency key strategy for unsafe methods (default: enabled)

#### Rate Limiting Configuration

- **requestsPerSecond** - Maximum requests per second
- **requestsPerMinute** - Maximum requests per minute
- **requestsPerHour** - Maximum requests per hour
- **concurrentRequests** - Maximum concurrent requests (default: 10)
- **burstCapacity** - Allowed burst above steady rate (token bucket)
- **adaptiveFromHeaders** - Update limits from response headers when available (default: true)

#### Default Settings

- **defaultHeaders** - Headers to include with every request
- **defaultQueryParams** - Query parameters to include with every request

#### Hooks Configuration

Arrays of hooks to execute at different stages:

- **beforeRequest** - Executed before sending a request
- **afterResponse** - Executed after receiving a response
- **onError** - Executed when an error occurs
- **onRetry** - Executed before retrying a request

### Retry Mechanism

The connector must implement a robust retry strategy with the following requirements:

#### Retry Strategy Methods

- **shouldRetry(error, attemptNumber)**  
  Determines whether a request should be retried based on the error and current attempt count.

- **calculateDelay(attemptNumber)**  
  Calculates the delay before the next retry attempt.

- **onRetry(error, attemptNumber)**  
  Hook called before each retry attempt for logging or state updates.

#### Implementation Requirements

1. **Exponential Backoff**  
   Calculate delay as: minimum(initialDelay × (backoffMultiplier ^ attemptNumber), maxDelay)

2. **Jitter**  
   Add randomization to prevent thundering herd: actualDelay = delay × (0.5 + random(0 to 0.5))

3. **Respect Server Hints**  
   Honor "Retry-After" headers when present

4. **Circuit Breaker**  
   Implement circuit breaker pattern to prevent cascading failures

5. **Retry Budget**  
   Abort retries once the per‑operation retry budget is exhausted, even if `maxAttempts` not reached.

### Hook System

Hooks provide extension points for customizing connector behavior without modifying core logic:

#### Hook Structure

Hooks follow a standardized interface:

```typescript
interface Hook {
  name: string
  priority?: number
  execute: (ctx: HookContext) => Promise<void> | void
}
```

- **name** - Unique identifier for the hook
- **priority** - Execution order (lower numbers execute first)  
- **execute(context)** - The hook's main function with full context access

#### Hook Context

Each hook receives a context object containing:

- **type** - The hook type: beforeRequest, afterResponse, onError, or onRetry
- **request** - The request options (when applicable)
- **response** - The response object (when applicable)
- **error** - The error object (when applicable)
- **metadata** - Additional context data

#### Enhanced Hook Context

```typescript
interface HookContext {
  type: HookType
  operation?: string
  request?: Record<string, unknown>
  response?: HttpResponseEnvelope<unknown>
  error?: unknown
  metadata?: Record<string, unknown>
  modifyRequest?: (updates: Record<string, unknown>) => void
  modifyResponse?: (updates: Partial<HttpResponseEnvelope<unknown>>) => void
  abort?: (reason?: string) => void
}
```

- **modifyRequest(updates)** - Modify the outgoing request
- **modifyResponse(updates)** - Modify the incoming response  
- **abort(reason)** - Cancel the request with a reason
- **operation** - Track which domain operation is executing

#### Middleware Pipeline (conceptual)

Hooks/middleware execute in a well‑defined order around the core request execution:

```text
PSEUDOCODE pipeline:
1. Build request (defaults → per‑call options → auth → user hooks)
2. Rate limiter: waitForSlot()
3. beforeRequest hooks (ordered by priority)
4. Execute (with timeout + cancellation token)
5. afterResponse hooks (transform/validate)
6. onError hooks (map/enrich), possibly shouldRetry → backoff
7. Metrics/logging at each stage
```

#### Common Hook Use Cases

- Adding authentication headers
- Request/response logging
- Metrics collection
- Request signing
- Response transformation
- Error enrichment

### Type and Data Model Management

#### Response Structure

All responses should be wrapped in a consistent structure containing:

- **data** - The actual response payload
- **status** - HTTP status code
- **headers** - Response headers as key-value pairs
- **meta** - Optional metadata including:
  - **timestamp** - When the response was received
  - **duration** - Request duration in milliseconds
  - **retryCount** - Number of retry attempts made
  - **rateLimit** - Current rate limit status
  - **requestId** - Correlation identifier echoed by server or generated by client

#### Data Transformation

The connector should provide methods for data transformation:

- **deserialize(data, schema)**  
  Transform API response data into internal application models

- **serialize(data, schema)**  
  Transform internal models into API-compatible format

- **validate(data, schema)**  
  Validate data against a schema definition

#### Schema Definition

Schemas should support:

- **type** - Data type: object, array, string, number, or boolean
- **properties** - For objects, defines nested properties
- **items** - For arrays, defines the schema of array elements
- **required** - List of required property names
- **format** - Specific format constraints (e.g., date-time, email, uri)
- **transform** - Custom transformation function

### Error Handling

#### Error Structure

All connector errors should include:

- **message** - Human-readable error description
- **code** - Machine-readable error code
- **statusCode** - HTTP status code (if applicable)
- **details** - Additional error context or data
- **retryable** - Boolean indicating if the request can be retried
- **requestId** - Correlation identifier if available
- **source** - Subsystem where the error occurred (transport, auth, rateLimit, deserialize, userHook, unknown)

#### Standard Error Codes

Connectors should use these standardized error codes:

- **NETWORK_ERROR** - Network connectivity issues
- **TIMEOUT** - Request exceeded timeout limit
- **AUTH_FAILED** - Authentication or authorization failure
- **RATE_LIMIT** - Rate limit exceeded
- **INVALID_REQUEST** - Malformed or invalid request
- **SERVER_ERROR** - Server-side error (5xx status codes)
- **PARSING_ERROR** - Failed to parse response
- **VALIDATION_ERROR** - Data validation failed
- **CANCELLED** - Request was cancelled by caller
- **UNSUPPORTED** - Operation not supported by target API

#### Error Handling Best Practices

- Preserve original error information for debugging
- Provide actionable error messages
- Include request context in error details
- Differentiate between retryable and non-retryable errors
- Log errors with appropriate severity levels

```text
PSEUDOCODE error enrichment:
IF transport error THEN code = NETWORK_ERROR, retryable = true
ELSE IF status in [408, 425, 429, 5xx] THEN retryable = true
ELSE retryable = false
Attach requestId, endpoint, method, attemptNumber, duration
```

### Pagination Support

#### Pagination Configuration

The paginate method should accept options including:

- **pageSize** - Number of items per page
- **startCursor** - Initial cursor for cursor-based pagination
- **startPage** - Initial page number for page-based pagination
- **strategy** - Pagination type: cursor, offset, page, or link-header
- **params** - Strategy‑specific parameter names (e.g., pageParam, perPageParam, cursorParam, offsetParam, limitParam)

#### Custom Extraction Functions

Allow customization of pagination logic through:

- **extractNextCursor(response)** - Extract the next page cursor from response
- **extractItems(response)** - Extract items array from response
- **hasNextPage(response)** - Determine if more pages exist

#### Pagination Implementation

The paginate method should:

1. Return an iterator for memory-efficient processing
2. Automatically fetch subsequent pages as needed
3. Handle different pagination strategies transparently
4. Yield arrays of items for each page
5. Stop when no more pages are available

```text
PSEUDOCODE for paginate method:
1. Initialize cursor/page from options
2. Set hasMore = true
3. WHILE hasMore:
   a. Make request with current cursor/page
   b. Extract items from response
   c. Yield items to caller
   d. Extract next cursor/page
   e. Check if more pages exist
   f. Update hasMore flag
4. End iteration when no more pages
```

### Concurrency, Cancellation, and Timeouts

- **Cancellation token**: All operations accept a caller‑provided token to cancel in‑flight work.
- **Per‑call timeout**: Enforced at the transport layer; must trigger cancellation and error with `TIMEOUT`.
- **Global shutdown**: The connector supports graceful shutdown, draining in‑flight requests.
- **Max concurrency**: Enforced independent of rate limits; bounded work queue to avoid unbounded memory growth.

```text
PSEUDOCODE request with cancellation and timeout:
1. IF !canProceed() THEN waitForSlot()
2. START timer(timeout)
3. TRY execute
4. IF cancelled OR timer expired → abort transport → raise TIMEOUT/CANCELLED
5. ALWAYS release slot
```

### Streaming and Large Payloads

- Support reading streaming responses (SSE/chunked) with backpressure.
- Support large uploads/downloads with chunking, multi‑part, or resumable mechanisms when available.
- Apply checksum/ETag validation when provided by the server.
- Surface progress events via hooks or callbacks where relevant.

```text
PSEUDOCODE streaming read:
open stream
FOR EACH chunk IN stream:
  emit chunk to caller
ON error → map to NETWORK_ERROR (retryable if partial/transient)
```

### Rate Limiting

#### Rate Limiter Methods

The rate limiter should implement:

- **canProceed()**  
  Returns true if a request can be made immediately without exceeding rate limits

- **waitForSlot()**  
  Blocks/waits until a request slot becomes available

- **updateFromResponse(headers)**  
  Updates rate limit state based on response headers (e.g., X-RateLimit-Remaining)

- **getStatus()**  
  Returns current rate limit status information

#### Rate Limit Status

Status information should include:

- **limit** - Maximum requests allowed in the window
- **remaining** - Requests remaining in current window
- **reset** - Timestamp when the limit resets
- **retryAfter** - Seconds to wait before retrying (if provided)

#### Implementation Strategies

- **Token Bucket** - Smooth rate limiting with burst capacity
- **Sliding Window** - Precise rate limiting over time windows
- **Fixed Window** - Simple reset at specific intervals
- **Adaptive** - Adjust based on server feedback

```text
PSEUDOCODE adaptive update:
IF headers contain rate-limit info THEN update limiter state
IF Retry-After present THEN sleep per hint
```

### Authentication Strategies

#### Authentication Methods

Each authentication strategy should implement:

- **authenticate(request)**  
  Apply authentication credentials to the outgoing request

- **refresh()**  
  Refresh expired credentials (optional, for token-based auth)

- **isValid()**  
  Check if current authentication credentials are still valid

#### Required Authentication Types

- **API Key**  
  Support for API keys in headers, query parameters, or custom locations

- **Bearer Token**  
  JWT or opaque tokens with optional refresh mechanism

- **Basic Authentication**  
  Username and password encoded in Authorization header

- **OAuth 2.0**  
  Full OAuth flow with token refresh support

- **Custom Authentication**  
  Signature-based auth, HMAC, or other custom schemes

#### Authentication Best Practices

- Store credentials securely (never in plain text)
- Implement automatic token refresh before expiration
- Handle authentication failures gracefully
- Support multiple authentication methods per connector
- Allow authentication method switching at runtime

```text
PSEUDOCODE auth application:
credentials = load from secure store
IF credentials expiring → refresh()
add auth to request (header/query/signature)
```

### Idempotency

- For unsafe methods (e.g., POST), support idempotency keys when the API allows, to safely retry.
- Generate a stable key per logical operation; store it in a header or agreed field.
- Avoid silent replays when idempotency is not supported (surface clear warnings).

```text
PSEUDOCODE idempotency key:
key = hash(operationName + stableInputs)
set header "Idempotency-Key" = key
```

### Webhooks and Async Jobs (if applicable)

- Verify webhook signatures and timestamps; reject stale or invalid deliveries.
- Support async job polling patterns (create → poll status → fetch result), with backoff.
- De‑duplicate webhook events using delivery IDs or replay IDs.

```text
PSEUDOCODE async job:
jobId = POST /jobs
REPEAT until done:
  status = GET /jobs/{jobId}
  IF status == done → break
  sleep(backoff)
result = GET /jobs/{jobId}/result
```

### Best Practices

- **Connection Pooling:** Reuse connections when possible
- **Request Deduplication:** Prevent duplicate requests for the same resource
- **Caching:** Implement cache headers respect (ETag, Last-Modified)
- **Compression:** Support gzip/deflate compression
- **Logging:** Structured logging with request IDs for tracing
- **Metrics:** Track request count, latency, error rates
- **Graceful Shutdown:** Complete in-flight requests before disconnecting
- **Resource Cleanup:** Properly clean up timers, connections, and listeners

### Observability

The core package provides built-in observability hooks that connectors should export:

```typescript
// Export observability hooks for external use
export { createLoggingHooks, createMetricsHooks, InMemoryMetricsSink, createInMemoryMetricsSink } from './observability'
```

#### Built-in Observability Features

- **Logging Hooks**: Structured logs with correlation `requestId`, operation tracking, and secret redaction
- **Metrics Hooks**: Counters (requests, errors, retries), histograms (latency), gauges (in‑flight requests)
- **Request Correlation**: Every request gets a correlation ID for distributed tracing
- **Rate Limit Tracking**: Real-time rate limit status in response metadata

#### Observability Integration

```typescript
const connector = createMyConnector()
const loggingHooks = createLoggingHooks()
const metricsHooks = createMetricsHooks(metricsSink)

connector.initialize({
  auth: { /* auth config */ },
  hooks: {
    beforeRequest: [...loggingHooks.beforeRequest, ...metricsHooks.beforeRequest],
    afterResponse: [...loggingHooks.afterResponse, ...metricsHooks.afterResponse]
  }
})
```

### Security and Compliance

- Redact secrets in logs, metrics, and errors.
- Validate inputs and outputs; reject malformed data early.
- Use TLS by default; support custom CA bundles and optional mTLS where required.
- Clock‑skew aware signature validation when needed.
- Respect data residency and minimization; avoid storing payloads unless explicitly enabled.

### Versioning and Compatibility

- Use the upstream/source version identifiers for organizing connector variants (e.g., v4, dates, API versions). SemVer is not required for registry entries.
- Backward‑compatible changes preferable; document breaking changes clearly.
- Feature flags or capability negotiation for optional features (e.g., streaming, webhooks).

### Testing Requirements

Connectors must include:

- Unit tests for all public methods
- Integration tests with mock servers
- Retry logic testing with various failure scenarios
- Rate limit testing
- Authentication flow testing
- Error handling and recovery testing
- Performance benchmarks

### Conformance Checklist

#### Core Package Integration
- ✅ Extends `ApiConnectorBase` from `@connector-factory/core`
- ✅ Uses domain factory pattern with `buildResourceDomain(send)` functions
- ✅ Implements proper initialization with defaults, auth, and rate limiting
- ✅ Exports observability hooks (`createLoggingHooks`, `createMetricsHooks`)
- ✅ Uses `makeCrudDomain` for consistent CRUD operations

#### Architecture Compliance
- ✅ Domain organization under `src/domains/{resource}.ts`
- ✅ Model organization under `src/models/{resource}/`
- ✅ Type exports for external usage (`export type *`)
- ✅ Configuration with proper TypeScript types
- ✅ Hook system with named hooks and priority

#### Base Functionality (Inherited)
- ✅ Lifecycle: initialize, connect, disconnect, isConnected
- ✅ Request infrastructure with retry, rate limiting, hooks
- ✅ Response wrapper with data/status/headers/meta including requestId and rateLimit
- ✅ Structured errors with code/status/retryable/details and correlation
- ✅ Pagination with cursor support via `paginateCursor`
- ✅ Concurrency limits, cancellation, graceful shutdown
- ✅ Security controls for credentials, TLS, validation, and redaction

#### Testing Requirements
- ✅ Unit tests using Jest framework
- ✅ Integration tests with real API (gated)
- ✅ Separate test configurations for unit vs integration
- ✅ Hook testing and domain testing
