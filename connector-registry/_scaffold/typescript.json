{
  "$schema": "https://schemas.connector-factory.dev/scaffold.schema.json",
  "scaffold": "typescript",
  "version": "0.6.0",
  "description": "TypeScript implementation scaffold with _meta folder at implementation level.",
  "variables": {
    "connector": {
      "description": "Connector name (kebab-case).",
      "example": "stripe",
      "pattern": "^[a-z0-9][a-z0-9-]*$"
    },
    "version": {
      "description": "Source version identifier (not necessarily semver). Examples: v4, ga4, 2020-08-27, api-2020.08.27",
      "example": "v4",
      "pattern": "^[A-Za-z0-9][A-Za-z0-9._-]*$"
    },
    "author": {
      "description": "GitHub organization or user handle (kebab-case). Used for linking and avatars.",
      "example": "514-labs",
      "pattern": "^[a-z0-9](?:[a-z0-9-]{0,37}[a-z0-9])?$"
    },
    "implementation": {
      "description": "Implementation name nested under the language folder (kebab-case). Defaults to 'default'.",
      "example": "default",
      "pattern": "^[a-z0-9][a-z0-9-]*$",
      "default": "default"
    },
    "packageName": {
      "description": "npm package name for the connector (use @workspace/ prefix if publishing in this monorepo).",
      "example": "@workspace/connector-stripe",
      "pattern": "^(@[a-z0-9-~][a-z0-9-._~]*)?/[a-z0-9-~][a-z0-9-._~]*$|^[a-z0-9-~][a-z0-9-._~]*$"
    },
    "resource": {
      "description": "Default REST resource path segment (kebab-case).",
      "example": "contacts",
      "pattern": "^[a-z0-9][a-z0-9-]*$",
      "default": "resource"
    }
  },
  "structure": [
    {
      "type": "dir",
      "name": "{connector}",
      "children": [
        {
          "type": "dir",
          "name": "{version}",
          "children": [
            {
              "type": "dir",
              "name": "{author}",
              "children": [
                {
                  "type": "dir",
                  "name": "typescript",
                  "children": [
                    {
                      "type": "dir",
                      "name": "{implementation}",
                      "children": [
                        {
                          "type": "dir",
                          "name": "_meta",
                          "children": [
                            {
                              "type": "file",
                              "name": "connector.json",
                              "template": "{\n  \"$schema\": \"https://schemas.connector-factory.dev/connector.schema.json\",\n  \"identifier\": \"{connector}\",\n  \"name\": \"{connector}\",\n  \"author\": \"{author}\",\n  \"authorType\": \"organization\",\n  \"avatarUrlOverride\": \"\",\n  \"version\": \"{version}\",\n  \"language\": \"typescript\",\n  \"implementation\": \"{implementation}\",\n  \"tags\": [],\n  \"category\": \"api\",\n  \"description\": \"\",\n  \"homepage\": \"\",\n  \"license\": \"MIT\",\n  \"source\": {\"type\":\"api\",\"spec\":\"\"},\n  \"capabilities\": {\"extract\": true, \"transform\": true, \"load\": true},\n  \"maintainers\": [],\n  \"issues\": \"\",\n  \"registryUrl\": \"https://github.com/514-labs/registry/tree/main/connector-registry/{connector}/{version}/{author}/typescript/{implementation}\"\n}\n"
                            },
                            {
                              "type": "file",
                              "name": "README.md",
                              "template": "# {connector}\n\n> Maintained by {author}\n\nConnector metadata and assets for the TypeScript {implementation} implementation.\n"
                            },
                            {
                              "type": "file",
                              "name": "CHANGELOG.md",
                              "template": "# Changelog\n\nAll notable changes to `{connector}` TypeScript {implementation} implementation by `{author}`.\n\n## [0.1.0] - Initial Release\n\n- Initial connector implementation\n"
                            },
                            { "type": "file", "name": "LICENSE", "template": "MIT\n" },
                            { "type": "dir", "name": "assets" }
                          ]
                        },
                        {
                          "type": "file",
                          "name": ".gitignore",
                          "template": "node_modules/\ndist/\n.env\n"
                        },
                        {
                          "type": "file",
                          "name": ".env.example",
                          "template": "API_KEY=\n"
                        },
                        {
                          "type": "file",
                          "name": "README.md",
                          "template": "# {connector} (TypeScript)\n\nTypeScript implementation for `{connector}` by `{author}`.\n\nSchemas: see `schemas/index.json` for machine-readable definitions and accompanying Markdown docs.\n"
                        },
                        {
                          "type": "file",
                          "name": "package.json",
                          "template": "{\n  \"name\": \"{packageName}\",\n  \"version\": \"0.0.0\",\n  \"private\": true,\n  \"description\": \"TypeScript {connector} connector\",\n  \"license\": \"MIT\",\n  \"main\": \"dist/src/index.js\",\n  \"types\": \"dist/src/index.d.ts\",\n  \"exports\": {\n    \".\": {\n      \"types\": \"./dist/src/index.d.ts\",\n      \"default\": \"./dist/src/index.js\"\n    }\n  },\n  \"files\": [\"dist\", \"README.md\"],\n  \"scripts\": {\n    \"build\": \"tsc -p tsconfig.json\",\n    \"test\": \"jest --passWithNoTests\",\n    \"test:watch\": \"jest --watch\",\n    \"test:integration\": \"jest --config jest.integration.cjs\"\n  },\n  \"dependencies\": {\n    \"@connector-factory/core\": \"workspace:*\",\n    \"ajv\": \"^8.17.1\",\n    \"ajv-formats\": \"^3.0.1\",\n    \"zod\": \"^3.25.8\"\n  },\n  \"devDependencies\": {\n    \"@types/jest\": \"^29.5.14\",\n    \"@types/node\": \"^20.14.12\",\n    \"jest\": \"^29.7.0\",\n    \"nock\": \"^13.5.4\",\n    \"ts-jest\": \"29.1.2\",\n    \"tsx\": \"^4.19.2\",\n    \"typescript\": \"^5.6.3\"\n  },\n  \"engines\": {\"node\": \">=20\"}\n}\n"
                        },
                        {
                          "type": "file",
                          "name": "tsconfig.json",
                          "template": "{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"CommonJS\",\n    \"moduleResolution\": \"Node\",\n    \"outDir\": \"dist\",\n    \"declaration\": true,\n    \"declarationMap\": true,\n    \"strict\": true,\n    \"skipLibCheck\": true,\n    \"esModuleInterop\": true,\n    \"allowSyntheticDefaultImports\": true,\n    \"forceConsistentCasingInFileNames\": true\n  },\n  \"include\": [\"src\", \"tests\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n"
                        },
                        {
                          "type": "file",
                          "name": "jest.config.cjs",
                          "template": "module.exports = {\n  preset: 'ts-jest',\n  testEnvironment: 'node',\n  roots: ['<rootDir>/src', '<rootDir>/tests'],\n  testMatch: ['**/__tests__/**/*.ts', '**/?(*.)+(spec|test).ts'],\n  collectCoverageFrom: ['src/**/*.ts', '!src/**/*.d.ts'],\n  setupFilesAfterEnv: [],\n  moduleNameMapping: {},\n  testTimeout: 30000\n};\n"
                        },
                        {
                          "type": "file",
                          "name": "jest.integration.cjs",
                          "template": "module.exports = {\n  ...require('./jest.config.cjs'),\n  testMatch: ['**/tests/integration/**/*.test.ts'],\n  testTimeout: 60000\n};\n"
                        },
                        {
                          "type": "dir",
                          "name": "docs",
                          "children": [
                            {
                              "type": "file",
                              "name": "getting-started.md",
                              "template": "# Getting started\n\nThis is a placeholder. Document how to configure and run the connector in TypeScript.\n"
                            },
                            {
                              "type": "file",
                              "name": "configuration.md",
                              "template": "# Configuration\n\nDocument configuration options (auth, scopes, IDs).\n"
                            },
                            {
                              "type": "file",
                              "name": "schema.md",
                              "template": "# Schema\n\nRefer to `schemas/index.json` and related files.\n\n## Organization\n\nSchemas support nested folder structures for better organization:\n\n- **raw/** - Raw API schemas\n  - `endpoints/` - API endpoint request/response schemas\n  - `types/` - Shared type definitions for endpoints (not shown as Files)\n  - `events/` - Event payloads\n- **extracted/** - Normalized schemas\n  - `entities/` - Business entities\n  - `metrics/` - Aggregated data\n- **files/** - File-based schemas (CSV/JSON/Parquet/Avro/NDJSON). Only items under `schemas/files` appear in the Files tab.\n\n## Adding Schemas\n\n1. Create schema files in appropriate nested folders\n2. Update `schemas/index.json` with correct paths for endpoints and tables\n3. Place file schemas under `schemas/files` (no index entries needed)\n"
                            },
                            {
                              "type": "file",
                              "name": "limits.md",
                              "template": "# Limits\n\nDescribe API limits, quotas, and rate limiting behavior.\n"
                            }
                          ]
                        },
                        {
                          "type": "dir",
                          "name": "schemas",
                          "children": [
                            {
                              "type": "file",
                              "name": "index.json",
                              "template": "{\n  \"$schema\": \"https://schemas.connector-factory.dev/schema-index.schema.json\",\n  \"version\": \"0.1.0\",\n  \"datasets\": [\n    {\n      \"name\": \"events\",\n      \"stage\": \"raw\",\n      \"kind\": \"endpoints\",\n      \"path\": \"raw/endpoints/events.schema.json\",\n      \"doc\": \"raw/endpoints/events.md\"\n    },\n    {\n      \"name\": \"events\",\n      \"stage\": \"extracted\",\n      \"kind\": \"endpoints\",\n      \"path\": \"extracted/endpoints/events.schema.json\",\n      \"doc\": \"extracted/endpoints/events.md\"\n    }\n  ],\n  \"_examples\": {\n    \"_comment\": \"Below are examples of how to use nested folders. Copy and modify these patterns:\",\n    \"endpoint_example\": {\n      \"name\": \"users.create\",\n      \"stage\": \"raw\",\n      \"kind\": \"endpoints\",\n      \"path\": \"raw/endpoints/endpoints/users/create.schema.json\",\n      \"doc\": \"raw/endpoints/endpoints/users/create.md\",\n      \"metadata\": {\n        \"category\": \"endpoint\",\n        \"apiMethod\": \"POST\"\n      }\n    },\n    \"nested_organization_example\": {\n      \"name\": \"reports.analytics\",\n      \"stage\": \"raw\",\n      \"kind\": \"endpoints\",\n      \"path\": \"raw/endpoints/endpoints/reports/analytics.schema.json\",\n      \"doc\": \"raw/endpoints/endpoints/reports/analytics.md\"\n    }\n  }\n}\n"
                            },
                            {
                              "type": "dir",
                              "name": "raw",
                              "children": [
                                {
                                  "type": "dir",
                                  "name": "json",
                                  "children": [
                                    {
                                      "type": "file",
                                      "name": "README.md",
                                      "template": "# Raw JSON Schemas\n\nThis directory contains raw JSON schemas from the source API.\n\n## Organization\n\nSchemas can be organized in nested folders for better structure:\n- `endpoints/` - API endpoint request/response schemas\n- `types/` - Shared type definitions\n- `events/` - Event or webhook payloads\n- Or any logical grouping that makes sense for your connector\n\n## Example Structure\n\n```\njson/\n├── endpoints/\n│   ├── users.schema.json\n│   └── users.md\n├── types/\n│   ├── User.schema.json\n│   └── User.md\n└── events.schema.json\n```\n"
                                    },
                                    {
                                      "type": "file",
                                      "name": "events.schema.json",
                                      "template": "{\\n  \\\"$schema\\\": \\\"http://json-schema.org/draft-07/schema#\\\",\\n  \\\"title\\\": \\\"Raw Event\\\",\\n  \\\"type\\\": \\\"object\\\",\\n  \\\"additionalProperties\\\": true\\n}\\n"
                                    },
                                    {
                                      "type": "file",
                                      "name": "events.md",
                                      "template": "# Raw events (JSON)\n\nDescribe the upstream event payload.\n"
                                    }
                                  ]
                                },
                                {
                                  "type": "dir",
                                  "name": "files",
                                  "children": [
                                    {
                                      "type": "file",
                                      "name": "README.md",
                                      "template": "# File schemas\n\nPlace file-based schemas here (CSV/JSON/Parquet/Avro/NDJSON). Files in this folder are shown in the Files tab.\n\nExamples:\n- `events.csv`\n- `events.schema.json` (with title/description)\n"
                                    }
                                  ]
                                },
                                {
                                  "type": "dir",
                                  "name": "relational",
                                  "children": [
                                    {
                                      "type": "file",
                                      "name": "tables.json",
                                      "template": "{\\n  \\\"tables\\\": []\\n}\\n"
                                    },
                                    {
                                      "type": "file",
                                      "name": "tables.sql",
                                      "template": "-- DDL placeholders for raw tables\n"
                                    },
                                    {
                                      "type": "file",
                                      "name": "README.md",
                                      "template": "# Raw relational schema\n\nDescribe tables and relationships.\n"
                                    }
                                  ]
                                }
                              ]
                            },
                            {
                              "type": "dir",
                              "name": "extracted",
                              "children": [
                                {
                                  "type": "dir",
                                  "name": "json",
                                  "children": [
                                    {
                                      "type": "file",
                                      "name": "README.md",
                                      "template": "# Extracted JSON Schemas\n\nThis directory contains normalized/transformed JSON schemas.\n\n## Organization\n\nLike raw schemas, extracted schemas can be organized in nested folders:\n- `entities/` - Normalized business entities\n- `metrics/` - Calculated metrics or aggregations\n- `reports/` - Structured report schemas\n- Or any logical grouping for your transformed data\n\n## Naming Convention\n\nUse the same folder structure as in `raw/endpoints/` when there's a 1:1 mapping, or create new logical groupings for transformed data.\n"
                                    },
                                    {
                                      "type": "file",
                                      "name": "events.schema.json",
                                      "template": "{\\n  \\\"$schema\\\": \\\"http://json-schema.org/draft-07/schema#\\\",\\n  \\\"title\\\": \\\"Extracted Event\\\",\\n  \\\"type\\\": \\\"object\\\",\\n  \\\"additionalProperties\\\": false,\\n  \\\"properties\\\": {}\\n}\\n"
                                    },
                                    {
                                      "type": "file",
                                      "name": "events.md",
                                      "template": "# Extracted events (JSON)\n\nDescribe the normalized event shape.\n"
                                    }
                                  ]
                                },
                                {
                                  "type": "dir",
                                  "name": "relational",
                                  "children": [
                                    {
                                      "type": "file",
                                      "name": "tables.json",
                                      "template": "{\\n  \\\"tables\\\": []\\n}\\n"
                                    },
                                    {
                                      "type": "file",
                                      "name": "tables.sql",
                                      "template": "-- DDL placeholders for extracted tables\n"
                                    },
                                    {
                                      "type": "file",
                                      "name": "README.md",
                                      "template": "# Extracted relational schema\n\nDescribe normalized tables and relationships.\n"
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        },
                        {
                          "type": "dir",
                          "name": "src",
                          "children": [
                            {
                              "type": "file",
                              "name": "index.ts",
                              "template": "export { create{connector|title}Connector } from './connector'\nexport type { {connector|title}Connector } from './types/connector'\nexport type { ConnectorConfig } from './types/config'\nexport type { HttpResponseEnvelope } from './types/envelopes'\n// Export all model types for external use\nexport type * from './models'\n// Observability exports\nexport { createLoggingHooks, createMetricsHooks, InMemoryMetricsSink, createInMemoryMetricsSink } from './observability'\n"
                            },
                            {
                              "type": "file",
                              "name": "connector.ts",
                              "template": "import { ApiConnectorBase, type RateLimitOptions } from '@connector-factory/core'\nimport type { {connector|title}Connector } from './types/connector'\nimport type { ConnectorConfig } from './types/config'\nimport { withDerivedDefaults } from './config/defaults'\nimport { ConnectorError } from './types/errors'\nimport { build{resource|title}Domain } from './domains/{resource}'\nimport type { SendFn } from '@connector-factory/core'\n\nexport class {connector|title}ApiConnector extends ApiConnectorBase implements {connector|title}Connector {\n  initialize(userConfig: ConnectorConfig) {\n    const rateLimitOptions: RateLimitOptions = {\n      onRateLimitSignal: (info) => {\n        // Adaptive rate limiting based on server feedback\n        if (this.config?.rateLimit?.adaptiveFromHeaders && this.limiter) {\n          (this.limiter as any).updateFromResponse(info)\n        }\n      }\n    }\n\n    super.initialize(\n      userConfig,\n      withDerivedDefaults,\n      ({ headers }: { headers: Record<string, string> }) => {\n        // Apply authentication\n        if (this.config?.auth.type === 'bearer') {\n          const token = this.config?.auth.bearer?.token\n          if (!token) throw new ConnectorError({ message: 'Authentication failed – missing bearer token', code: 'AUTH_FAILED', source: 'auth', retryable: false })\n          headers['Authorization'] = `Bearer ${token}`\n        }\n      },\n      rateLimitOptions\n    )\n  }\n\n  // Build domain delegates\n  private get domain() {\n    const sendLite: SendFn = async (args) => this.send<any>(args)\n    return {\n      ...build{resource|title}Domain((args) => sendLite({ ...args, operation: args.operation ?? '{resource}' }))\n    }\n  }\n\n  // {resource|title} methods\n  list{resource|title} = (params?: { properties?: string[]; limit?: number; after?: string }) => this.domain.list{resource|title}(params)\n  get{resource|title} = (params: { id: string; properties?: string[] }) => this.domain.get{resource|title}(params)\n  stream{resource|title} = (params?: { properties?: string[]; pageSize?: number }) => this.domain.stream{resource|title}(params)\n  get{resource|title}s = (params?: { properties?: string[]; pageSize?: number; maxItems?: number }) => this.domain.get{resource|title}s(params)\n}\n\nexport function create{connector|title}Connector(): {connector|title}Connector {\n  return new {connector|title}ApiConnector()\n}\n"
                            },
                            {
                              "type": "file",
                              "name": "config.ts",
                              "template": "export type ConnectorConfig = {\n  // Base configuration\n  baseUrl?: string\n  timeoutMs?: number\n  userAgent?: string\n  defaultHeaders?: Record<string, string>\n  defaultQueryParams?: Record<string, string>\n\n  // Authentication\n  auth: {\n    type: 'bearer' | 'apiKey' | 'basic'\n    bearer?: { token: string }\n    apiKey?: { key: string; header?: string }\n    basic?: { username: string; password: string }\n  }\n\n  // Rate limiting\n  rateLimit?: {\n    requestsPerSecond?: number\n    burstCapacity?: number\n    concurrentRequests?: number\n    adaptiveFromHeaders?: boolean\n  }\n\n  // Retry configuration\n  retry?: {\n    maxAttempts?: number\n    initialDelayMs?: number\n    maxDelayMs?: number\n    backoffMultiplier?: number\n    retryableStatusCodes?: number[]\n    respectRetryAfter?: boolean\n  }\n\n  // Hooks\n  hooks?: {\n    beforeRequest?: Array<{ name: string; priority?: number; execute: (ctx: any) => Promise<void> | void }>\n    afterResponse?: Array<{ name: string; priority?: number; execute: (ctx: any) => Promise<void> | void }>\n    onError?: Array<{ name: string; priority?: number; execute: (ctx: any) => Promise<void> | void }>\n    onRetry?: Array<{ name: string; priority?: number; execute: (ctx: any) => Promise<void> | void }>\n  }\n}\n"
                            },
                            {
                              "type": "dir",
                              "name": "domains",
                              "children": [
                                {
                                  "type": "file",
                                  "name": "{resource}.ts",
                                  "template": "import type { SendFn } from '@connector-factory/core'\nimport { makeCrudDomain } from '../core/make-crud-domain'\nimport type { {resource|title}, {resource|title}sResponse, {resource|title}Response } from '../models/{resource}'\n\nexport function build{resource|title}Domain(send: SendFn) {\n  const base = makeCrudDomain<{resource|title}, {resource|title}sResponse, {resource|title}Response>('/{resource}', send)\n  return {\n    list{resource|title}: base.list,\n    get{resource|title}: base.get,\n    stream{resource|title}: base.streamAll,\n    get{resource|title}s: base.getAll\n  }\n}\n"
                                }
                              ]
                            },
                            {
                              "type": "dir",
                              "name": "core",
                              "children": [
                                {
                                  "type": "file",
                                  "name": "make-crud-domain.ts",
                                  "template": "import { paginateCursor, type SendFn } from '@connector-factory/core'\n\nexport function makeCrudDomain<TObject, TListResponse, TSingleResponse>(objectPath: string, send: SendFn) {\n  const api = {\n    list: (params?: { properties?: string[]; limit?: number; after?: string }) => {\n      const query: Record<string, any> = {}\n      if (params?.properties?.length) query.properties = params.properties.join(',')\n      if (params?.limit) query.limit = params.limit\n      if (params?.after) query.after = params.after\n      return send<TListResponse>({ method: 'GET', path: objectPath, query })\n    },\n    get: (params: { id: string; properties?: string[] }) => {\n      const query: Record<string, any> = {}\n      if (params?.properties?.length) query.properties = params.properties.join(',')\n      return send<TSingleResponse>({ method: 'GET', path: `${objectPath}/${params.id}` as const, query })\n    },\n    streamAll: async function* (params?: { properties?: string[]; pageSize?: number }) {\n      const query: Record<string, any> = {}\n      if (params?.properties?.length) query.properties = params.properties.join(',')\n      for await (const items of paginateCursor<TObject>({ send, path: objectPath, query, pageSize: params?.pageSize })) {\n        for (const item of items) yield item\n      }\n    },\n    getAll: async (params?: { properties?: string[]; pageSize?: number; maxItems?: number }) => {\n      const results: TObject[] = []\n      for await (const item of api.streamAll({ properties: params?.properties, pageSize: params?.pageSize })) {\n        results.push(item)\n        if (params?.maxItems && results.length >= params.maxItems) break\n      }\n      return results\n    }\n  }\n  return api\n}\n"
                                }
                              ]
                            },
                            {
                              "type": "dir",
                              "name": "types",
                              "children": [
                                {
                                  "type": "file",
                                  "name": "connector.ts",
                                  "template": "import type { ConnectorConfig } from './config'\nimport type { {resource|title} } from '../models/{resource}'\n\nexport interface {connector|title}Connector {\n  initialize(config: ConnectorConfig): void\n  connect(): Promise<void>\n  disconnect(): Promise<void>\n  isConnected(): boolean\n\n  // {resource|title} operations\n  list{resource|title}(params?: { properties?: string[]; limit?: number; after?: string }): Promise<any>\n  get{resource|title}(params: { id: string; properties?: string[] }): Promise<any>\n  stream{resource|title}(params?: { properties?: string[]; pageSize?: number }): AsyncGenerator<{resource|title}, void, unknown>\n  get{resource|title}s(params?: { properties?: string[]; pageSize?: number; maxItems?: number }): Promise<{resource|title}[]>\n}\n"
                                },
                                {
                                  "type": "file",
                                  "name": "envelopes.ts",
                                  "template": "export type HttpResponseEnvelope<T = unknown> = {\n  data: T\n  status?: number\n  headers?: Record<string, string>\n  meta?: {\n    timestamp: number\n    durationMs: number\n    retryCount: number\n    requestId?: string\n    rateLimit?: {\n      limit: number\n      remaining: number\n      reset: number\n      resetDate?: string\n    }\n  }\n}\n"
                                },
                                {
                                  "type": "file",
                                  "name": "errors.ts",
                                  "template": "export type ErrorCode = 'NETWORK_ERROR' | 'TIMEOUT' | 'AUTH_FAILED' | 'RATE_LIMITED' | 'INVALID_REQUEST' | 'SERVER_ERROR' | 'PARSING_ERROR' | 'VALIDATION_ERROR' | 'CANCELLED' | 'UNSUPPORTED' | 'NOT_INITIALIZED'\n\nexport type ErrorSource = 'transport' | 'auth' | 'rateLimit' | 'deserialize' | 'userHook' | 'application' | 'unknown'\n\nexport interface ConnectorErrorOptions {\n  message: string\n  code: ErrorCode\n  statusCode?: number\n  details?: any\n  retryable: boolean\n  requestId?: string\n  source: ErrorSource\n}\n\nexport class ConnectorError extends Error {\n  code: ErrorCode\n  statusCode?: number\n  retryable: boolean\n  requestId?: string\n  source: ErrorSource\n  details?: any\n\n  constructor(options: ConnectorErrorOptions) {\n    super(options.message)\n    this.name = 'ConnectorError'\n    this.code = options.code\n    this.statusCode = options.statusCode\n    this.retryable = options.retryable\n    this.requestId = options.requestId\n    this.source = options.source\n    this.details = options.details\n  }\n}\n"
                                }
                              ]
                            },
                            {
                              "type": "dir",
                              "name": "models",
                              "children": [
                                {
                                  "type": "file",
                                  "name": "index.ts",
                                  "template": "export * from './{resource}'\n"
                                },
                                {
                                  "type": "dir",
                                  "name": "{resource}",
                                  "children": [
                                    {
                                      "type": "file",
                                      "name": "index.ts",
                                      "template": "export * from './{resource}'\nexport * from './{resource}-api-contracts'\n"
                                    },
                                    {
                                      "type": "file",
                                      "name": "{resource}.ts",
                                      "template": "export interface {resource|title} {\n  id: string\n  // Add your resource-specific properties here\n  [key: string]: unknown\n}\n"
                                    },
                                    {
                                      "type": "file",
                                      "name": "{resource}-api-contracts.ts",
                                      "template": "import type { {resource|title} } from './{resource}'\n\nexport interface {resource|title}sResponse {\n  results: {resource|title}[]\n  paging?: {\n    next?: {\n      after?: string\n    }\n  }\n}\n\nexport interface {resource|title}Response {\n  data: {resource|title}\n}\n"
                                    }
                                  ]
                                }
                              ]
                            },
                            {
                              "type": "dir",
                              "name": "config",
                              "children": [
                                {
                                  "type": "file",
                                  "name": "defaults.ts",
                                  "template": "import type { ConnectorConfig } from '../types/config'\n\nexport function withDerivedDefaults(userConfig: ConnectorConfig): ConnectorConfig {\n  return {\n    ...userConfig,\n    baseUrl: userConfig.baseUrl ?? 'https://api.example.com',\n    timeoutMs: userConfig.timeoutMs ?? 30000,\n    userAgent: userConfig.userAgent ?? '{connector} Connector v1.0.0',\n    rateLimit: {\n      requestsPerSecond: 10,\n      burstCapacity: 20,\n      concurrentRequests: 5,\n      adaptiveFromHeaders: true,\n      ...userConfig.rateLimit\n    },\n    retry: {\n      maxAttempts: 3,\n      initialDelayMs: 1000,\n      maxDelayMs: 30000,\n      backoffMultiplier: 2,\n      retryableStatusCodes: [408, 425, 429, 500, 502, 503, 504],\n      respectRetryAfter: true,\n      ...userConfig.retry\n    }\n  }\n}\n"
                                }
                              ]
                            },
                            {
                              "type": "dir",
                              "name": "observability",
                              "children": [
                                {
                                  "type": "file",
                                  "name": "index.ts",
                                  "template": "export { createLoggingHooks } from './logging-hooks'\nexport { createMetricsHooks, InMemoryMetricsSink, createInMemoryMetricsSink } from './metrics-hooks'\n"
                                },
                                {
                                  "type": "file",
                                  "name": "logging-hooks.ts",
                                  "template": "export function createLoggingHooks() {\n  return {\n    beforeRequest: [{\n      name: 'request-logger',\n      priority: 100,\n      execute: (ctx: any) => {\n        console.log(`[${ctx.type}] Making request to ${ctx.request?.path}`)\n      }\n    }],\n    afterResponse: [{\n      name: 'response-logger',\n      priority: 100,\n      execute: (ctx: any) => {\n        console.log(`[${ctx.type}] Response received with status ${ctx.response?.status}`)\n      }\n    }]\n  }\n}\n"
                                },
                                {
                                  "type": "file",
                                  "name": "metrics-hooks.ts",
                                  "template": "export interface MetricsSink {\n  increment(name: string, tags?: Record<string, string>): void\n  gauge(name: string, value: number, tags?: Record<string, string>): void\n  histogram(name: string, value: number, tags?: Record<string, string>): void\n}\n\nexport class InMemoryMetricsSink implements MetricsSink {\n  private metrics = new Map<string, any>()\n\n  increment(name: string, tags?: Record<string, string>): void {\n    // Implementation for increment\n  }\n\n  gauge(name: string, value: number, tags?: Record<string, string>): void {\n    // Implementation for gauge\n  }\n\n  histogram(name: string, value: number, tags?: Record<string, string>): void {\n    // Implementation for histogram\n  }\n\n  getMetrics() {\n    return this.metrics\n  }\n}\n\nexport function createInMemoryMetricsSink(): InMemoryMetricsSink {\n  return new InMemoryMetricsSink()\n}\n\nexport function createMetricsHooks(sink: MetricsSink) {\n  return {\n    beforeRequest: [{\n      name: 'metrics-collector',\n      priority: 100,\n      execute: (ctx: any) => {\n        sink.increment('requests.total', { operation: ctx.operation })\n      }\n    }]\n  }\n}\n"
                                }
                              ]
                            }
                          ]
                        },
                        {
                          "type": "dir",
                          "name": "tests",
                          "children": [
                            {
                              "type": "dir",
                              "name": "unit",
                              "children": [
                                {
                                  "type": "file",
                                  "name": "connector.test.ts",
                                  "template": "import { create{connector|title}Connector } from '../src/connector'\nimport type { ConnectorConfig } from '../src/types/config'\n\ndescribe('{connector|title}Connector', () => {\n  let connector: ReturnType<typeof create{connector|title}Connector>\n  let config: ConnectorConfig\n\n  beforeEach(() => {\n    connector = create{connector|title}Connector()\n    config = {\n      auth: {\n        type: 'bearer',\n        bearer: { token: 'test-token' }\n      }\n    }\n  })\n\n  it('should initialize successfully', () => {\n    expect(() => connector.initialize(config)).not.toThrow()\n  })\n\n  it('should handle connection lifecycle', async () => {\n    connector.initialize(config)\n    expect(connector.isConnected()).toBe(false)\n    await connector.connect()\n    expect(connector.isConnected()).toBe(true)\n    await connector.disconnect()\n    expect(connector.isConnected()).toBe(false)\n  })\n})\n"
                                },
                                {
                                  "type": "file",
                                  "name": "{resource}.test.ts",
                                  "template": "import { create{connector|title}Connector } from '../src/connector'\nimport type { ConnectorConfig } from '../src/types/config'\n\ndescribe('{resource|title} operations', () => {\n  let connector: ReturnType<typeof create{connector|title}Connector>\n  let config: ConnectorConfig\n\n  beforeEach(() => {\n    connector = create{connector|title}Connector()\n    config = {\n      auth: {\n        type: 'bearer',\n        bearer: { token: 'test-token' }\n      }\n    }\n    connector.initialize(config)\n  })\n\n  it('should list {resource}', async () => {\n    // Mock test - implement actual testing logic\n    expect(connector.list{resource|title}).toBeDefined()\n  })\n\n  it('should get single {resource}', async () => {\n    // Mock test - implement actual testing logic\n    expect(connector.get{resource|title}).toBeDefined()\n  })\n})\n"
                                }
                              ]
                            },
                            {
                              "type": "dir",
                              "name": "integration",
                              "children": [
                                {
                                  "type": "file",
                                  "name": "{resource}.integration.test.ts",
                                  "template": "import { create{connector|title}Connector } from '../src/connector'\nimport type { ConnectorConfig } from '../src/types/config'\n\n// Integration tests - require real API credentials\ndescribe.skip('{resource|title} integration tests', () => {\n  let connector: ReturnType<typeof create{connector|title}Connector>\n  let config: ConnectorConfig\n\n  beforeAll(() => {\n    if (!process.env.API_TOKEN) {\n      throw new Error('API_TOKEN environment variable required for integration tests')\n    }\n\n    connector = create{connector|title}Connector()\n    config = {\n      auth: {\n        type: 'bearer',\n        bearer: { token: process.env.API_TOKEN }\n      }\n    }\n    connector.initialize(config)\n  })\n\n  it('should connect to real API', async () => {\n    await connector.connect()\n    expect(connector.isConnected()).toBe(true)\n  })\n\n  it('should list {resource} from real API', async () => {\n    await connector.connect()\n    const result = await connector.list{resource|title}({ limit: 1 })\n    expect(result).toBeDefined()\n  })\n})\n"
                                }
                              ]
                            }
                          ]
                        },
                        {
                          "type": "dir",
                          "name": "examples",
                          "children": [
                            {
                              "type": "file",
                              "name": "basic-usage.ts",
                              "template": "import { Client } from './src/client'\nconsole.log(new Client({}).ping())\n"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    }
  ]
}