{
  "$schema": "https://schemas.connector-factory.dev/scaffold.schema.json",
  "scaffold": "typescript",
  "version": "0.6.0",
  "description": "TypeScript implementation scaffold with _meta folder at implementation level.",
  "variables": {
    "connector": {
      "description": "Connector name (kebab-case).",
      "example": "stripe",
      "pattern": "^[a-z0-9][a-z0-9-]*$"
    },
    "version": {
      "description": "Source version identifier (not necessarily semver). Examples: v4, ga4, 2020-08-27, api-2020.08.27",
      "example": "v4",
      "pattern": "^[A-Za-z0-9][A-Za-z0-9._-]*$"
    },
    "author": {
      "description": "GitHub organization or user handle (kebab-case). Used for linking and avatars.",
      "example": "514-labs",
      "pattern": "^[a-z0-9](?:[a-z0-9-]{0,37}[a-z0-9])?$"
    },
    "implementation": {
      "description": "Implementation name nested under the language folder (kebab-case). Defaults to 'default'.",
      "example": "default",
      "pattern": "^[a-z0-9][a-z0-9-]*$",
      "default": "default"
    },
    "packageName": {
      "description": "npm package name for the connector (use @workspace/ prefix if publishing in this monorepo).",
      "example": "@workspace/connector-stripe",
      "pattern": "^(@[a-z0-9-~][a-z0-9-._~]*)?/[a-z0-9-~][a-z0-9-._~]*$|^[a-z0-9-~][a-z0-9-._~]*$"
    },
    "resource": {
      "description": "Default REST resource path segment (kebab-case).",
      "example": "contacts",
      "pattern": "^[a-z0-9][a-z0-9-]*$",
      "default": "resource"
    }
  },
  "structure": [
    {
      "type": "dir",
      "name": "{connector}",
      "children": [
            {
              "type": "dir",
              "name": "_meta",
              "children": [
                {
                  "type": "file",
                  "name": "connector.json",
                  "template": "{\n  \"$schema\": \"https://schemas.connector-factory.dev/connector-root.schema.json\",\n  \"identifier\": \"{connector}\",\n  \"name\": \"{connector}\",\n  \"category\": \"api\",\n  \"tags\": [],\n  \"description\": \"\",\n  \"homepage\": \"\"\n}"
                },
            {
              "type": "file",
              "name": "README.md",
              "template": "# {connector} (Registry)\n\nThis is the top-level registry entry for `{connector}`.\n\n- Versions live under `{connector}/{version}`\n- See author implementations under `{connector}/{version}/{author}`\n"
            },
            { "type": "dir", "name": "assets" }
          ]
        },
        {
          "type": "dir",
          "name": "{version}",
          "children": [
            {
              "type": "dir",
              "name": "_meta",
              "children": [
                {
                  "type": "file",
                  "name": "version.json",
                  "template": "{\n  \"name\": \"{connector}\",\n  \"version\": \"{version}\",\n  \"status\": \"beta\",\n  \"releasedAt\": \"\",\n  \"notes\": \"{connector} {version} version\"\n}"
                }
              ]
            },
            {
              "type": "dir",
              "name": "{author}",
              "children": [
                {
                  "type": "dir",
                  "name": "_meta",
                  "children": [
                    {
                      "type": "file",
                      "name": "connector.json",
                  "template": "{\n  \"name\": \"{connector}\",\n  \"author\": \"{author}\",\n  \"version\": \"{version}\",\n  \"languages\": [\n    \"typescript\"\n  ],\n  \"category\": \"api\",\n  \"capabilities\": {\n    \"extract\": true,\n    \"transform\": false,\n    \"load\": false\n  },\n  \"source\": {\n    \"type\": \"api\",\n    \"spec\": \"\",\n    \"homepage\": \"\"\n  },\n  \"tags\": [],\n  \"maintainers\": [],\n  \"issues\": { \"typescript\": { \"default\": \"\" } }\n}"
                    },
                    {
                      "type": "file",
                      "name": "README.md",
                      "template": "# {connector} Connector (by {author})\n\nThis directory contains language-agnostic metadata and documentation for the `{connector}` connector.\n\n- Name: `{connector}`\n- Author: `{author}`\n- Category: `api`\n- Languages: `typescript`\n\nSee `_meta/connector.json` for connector metadata and implementation folders for language-specific code.\n"
                    },
                    { "type": "file", "name": "CHANGELOG.md", "template": "# Changelog\n\nAll notable changes to this connector will be documented in this file.\n\n## 0.1.0 - Scaffold created\n\n- Initial scaffold for `{connector}` (TypeScript) added.\n" },
                    { "type": "file", "name": "LICENSE", "template": "MIT License\n\nCopyright (c) {author}\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n" },
                    { "type": "dir", "name": "assets" }
                  ]
                },
                {
                  "type": "dir",
                  "name": "typescript",
                  "children": [
                    {
                      "type": "dir",
                      "name": "_meta",
                      "children": [
                        {
                          "type": "file",
                          "name": "connector.json",
                          "template": "{\n  \"identifier\": \"{connector}\",\n  \"name\": \"{connector}\",\n  \"author\": \"{author}\",\n  \"version\": \"{version}\",\n  \"language\": \"typescript\",\n  \"implementations\": [\"{implementation}\"]\n}\n"
                        }
                      ]
                    },
                    {
                      "type": "dir",
                      "name": "{implementation}",
                      "children": [
                        {
                          "type": "file",
                          "name": ".gitignore",
                          "template": "node_modules/\ndist/\n.env\n"
                        },
                        {
                          "type": "file",
                          "name": ".env.example",
                          "template": "API_KEY=\n"
                        },
                        {
                          "type": "file",
                          "name": "README.md",
                          "template": "# {connector} (TypeScript)\n\nTypeScript implementation for `{connector}` by `{author}`.\n\nSchemas: see `schemas/index.json` for machine-readable definitions and accompanying Markdown docs.\n"
                        },
                        {
                          "type": "file",
                          "name": "install.config.toml",
                          "template": "language = \"typescript\"\ndescription = \"TypeScript connector for {connector}\"\npost_install_print = \"\"\"\nðŸš€ Next steps to get your {connector} connector running:\n\nðŸ“‚ Go to your connector directory:\n    $ cd {destination_dir}\n\nðŸ“¦ Install dependencies:\n    $ npm install\n\nðŸ”§ Build the connector:\n    $ npm run build\n\nðŸ§ª Run tests:\n    $ npm test\n\nðŸ“– Next, check out the documentation:\n    â€¢ Review docs/getting-started.md for configuration details\n    â€¢ See examples/ for usage examples\n    â€¢ Update src/connector.ts with your API implementation\n\nðŸ”— Integration options:\n    â€¢ Add to your project: import { createConnector } from '{packageName}'\n    â€¢ Use with pipelines: Configure as a source in your pipeline setup\n    â€¢ Standalone usage: Check examples/basic-usage.ts\n\"\"\"\n"
                        },
                        {
                          "type": "dir",
                          "name": "scripts",
                          "children": [
                            {
                              "type": "file",
                              "name": "postinstall.sh",
                              "template": "#!/usr/bin/env bash\nset -euo pipefail\n\n# This script runs after your package is installed (pnpm/npm postinstall lifecycle).\n# It is intentionally minimal and documented so you can customize it for your distribution needs.\n#\n# Common use cases:\n#  - Copy shared core sources into this package for single-file distribution\n#  - Prune dev-only files from the published artifact\n#  - Flatten directories for easier consumption\n#\n# By default, this script does nothing. Uncomment and adapt as needed.\n\nmain() {\n  echo \"postinstall: no-op (customize scripts/postinstall.sh as needed)\"\n\n  # Example: flatten src into the package root\n  # if [ -d src ]; then\n  #   shopt -s dotglob\n  #   mv src/* . || true\n  #   shopt -u dotglob\n  #   rm -rf src\n  # fi\n\n  # Example: remove dev-only files\n  # rm -f package-lock.json || true\n  # rm -rf tests || true\n}\n\nmain \"$@\"\n"
                            }
                          ]
                        },
                        {
                          "type": "file",
                          "name": "package.json",
                          "template": "{\n  \"name\": \"{packageName}\",\n  \"version\": \"0.1.0\",\n  \"private\": true,\n  \"type\": \"module\",\n  \"main\": \"dist/index.js\",\n  \"types\": \"dist/index.d.ts\",\n  \"scripts\": {\n    \"build\": \"tsc -p tsconfig.json\",\n    \"test\": \"jest --runInBand\",\n    \"test:build\": \"rm -rf .temp-test && tsc -p tsconfig.test.json\"\n  },\n  \"engines\": {\"node\": \">=20\"},\n  \"dependencies\": {\n    \"@connector-factory/core\": \"^0.0.0\"\n  },\n  \"devDependencies\": {\n    \"typescript\": \"^5.4.0\",\n    \"jest\": \"^29.7.0\",\n    \"ts-jest\": \"^29.1.2\",\n    \"nock\": \"^13.5.0\"\n  }\n}\n"
                        },
                        {
                          "type": "file",
                          "name": "tsconfig.json",
                          "template": "{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"CommonJS\",\n    \"moduleResolution\": \"Node\",\n    \"declaration\": true,\n    \"outDir\": \"dist\",\n    \"rootDir\": \".\",\n    \"strict\": true,\n    \"skipLibCheck\": true,\n    \"types\": [\"node\", \"jest\"],\n    \"resolveJsonModule\": true,\n    \"esModuleInterop\": true,\n    \"allowSyntheticDefaultImports\": true\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"dist\", \"node_modules\", \"examples\", \"tests\"]\n}\n"
                        },
                        {
                          "type": "file",
                          "name": "jest.config.cjs",
                          "template": "module.exports = {\n  testEnvironment: 'node',\n  transform: { '^.+\\.tsx?$': ['ts-jest', { tsconfig: 'tsconfig.test.json' }] },\n};\n"
                        },
                        {
                          "type": "file",
                          "name": "tsconfig.test.json",
                          "template": "{\n  \"extends\": \"./tsconfig.json\",\n  \"compilerOptions\": {\n    \"outDir\": \".temp-test\",\n    \"types\": [\n      \"jest\",\n      \"node\"\n    ]\n  },\n  \"include\": [\n    \"src\",\n    \"tests\"\n  ]\n}\n"
                        },
                        {
                          "type": "dir",
                          "name": "docs",
                          "children": [
                            {
                              "type": "file",
                              "name": "getting-started.md",
                              "template": "# Getting started\n\n```ts\nimport { createConnector } from './src'\n\nconst conn = createConnector()\nconn.initialize({\n  baseUrl: 'https://api.example.com',\n  auth: { type: 'bearer', bearer: { token: process.env.API_TOKEN! } },\n  logging: { enabled: true, level: 'info' },\n})\n\nfor await (const page of conn.myResource.getAll({ pageSize: 100, maxItems: 500 })) {\n  console.log(page.length)\n}\n```\n"
                            },
                            {
                              "type": "file",
                              "name": "configuration.md",
                              "template": "# Configuration\n\n- baseUrl, timeoutMs, userAgent\n- auth: api key, basic, bearer, oauth2 (per core)\n- retry: maxAttempts, initialDelayMs, maxDelayMs, backoffMultiplier, respectRetryAfter\n- rateLimit: requestsPerSecond, burstCapacity, adaptiveFromHeaders\n- hooks: arrays for beforeRequest/afterResponse/onError/onRetry\n"
                            },
                            {
                              "type": "file",
                              "name": "schema.md",
                              "template": "# Schema\n\nRefer to `schemas/index.json` and related files.\n\n## Organization\n\nSchemas support nested folder structures for better organization:\n\n- **raw/** - Raw API schemas\n  - `endpoints/` - API endpoint request/response schemas\n  - `types/` - Shared type definitions for endpoints (not shown as Files)\n  - `events/` - Event payloads\n- **extracted/** - Normalized schemas\n  - `entities/` - Business entities\n  - `metrics/` - Aggregated data\n- **files/** - File-based schemas (CSV/JSON/Parquet/Avro/NDJSON). Only items under `schemas/files` appear in the Files tab.\n\n## Adding Schemas\n\n1. Create schema files in appropriate nested folders\n2. Update `schemas/index.json` with correct paths for endpoints and tables\n3. Place file schemas under `schemas/files` (no index entries needed)\n"
                            },
                            {
                              "type": "file",
                              "name": "limits.md",
                              "template": "# Limits\n\nDescribe API limits, quotas, and rate limiting behavior.\n"
                            },
                            {
                              "type": "file",
                              "name": "observability.md",
                              "template": "# Observability\n\n## Logging\n```ts\nconn.initialize({\n  logging: { enabled: true, level: 'info', includeQueryParams: true, includeHeaders: true, includeBody: false }\n})\n```\nEmits http_request and http_response with optional fields.\n\n## Metrics\n```ts\nimport { createMetricsHooks, InMemoryMetricsSink } from '../src/observability/metrics-hooks'\nconst sink = new InMemoryMetricsSink()\nconn.initialize({ hooks: createMetricsHooks(sink) })\n```\nInspect sink.events for telemetry.\n"
                            }
                          ]
                        },
                        {
                          "type": "dir",
                          "name": "schemas",
                          "children": [
                            {
                              "type": "file",
                              "name": "index.json",
                              "template": "{\n  \"$schema\": \"https://schemas.connector-factory.dev/schema-index.schema.json\",\n  \"version\": \"0.1.0\",\n  \"datasets\": [\n    {\n      \"name\": \"events\",\n      \"stage\": \"raw\",\n      \"kind\": \"endpoints\",\n      \"path\": \"raw/endpoints/events.schema.json\",\n      \"doc\": \"raw/endpoints/events.md\"\n    },\n    {\n      \"name\": \"events\",\n      \"stage\": \"extracted\",\n      \"kind\": \"endpoints\",\n      \"path\": \"extracted/endpoints/events.schema.json\",\n      \"doc\": \"extracted/endpoints/events.md\"\n    }\n  ],\n  \"_examples\": {\n    \"_comment\": \"Below are examples of how to use nested folders. Copy and modify these patterns:\",\n    \"endpoint_example\": {\n      \"name\": \"users.create\",\n      \"stage\": \"raw\",\n      \"kind\": \"endpoints\",\n      \"path\": \"raw/endpoints/endpoints/users/create.schema.json\",\n      \"doc\": \"raw/endpoints/endpoints/users/create.md\",\n      \"metadata\": {\n        \"category\": \"endpoint\",\n        \"apiMethod\": \"POST\"\n      }\n    },\n    \"nested_organization_example\": {\n      \"name\": \"reports.analytics\",\n      \"stage\": \"raw\",\n      \"kind\": \"endpoints\",\n      \"path\": \"raw/endpoints/endpoints/reports/analytics.schema.json\",\n      \"doc\": \"raw/endpoints/endpoints/reports/analytics.md\"\n    }\n  }\n}\n"
                            },
                            {
                              "type": "dir",
                              "name": "raw",
                              "children": [
                                {
                                  "type": "dir",
                                  "name": "json",
                                  "children": [
                                    {
                                      "type": "file",
                                      "name": "README.md",
                                      "template": "# Raw JSON Schemas\n\nThis directory contains raw JSON schemas from the source API.\n\n## Organization\n\nSchemas can be organized in nested folders for better structure:\n- `endpoints/` - API endpoint request/response schemas\n- `types/` - Shared type definitions\n- `events/` - Event or webhook payloads\n- Or any logical grouping that makes sense for your connector\n\n## Example Structure\n\n```\njson/\nâ”œâ”€â”€ endpoints/\nâ”‚   â”œâ”€â”€ users.schema.json\nâ”‚   â””â”€â”€ users.md\nâ”œâ”€â”€ types/\nâ”‚   â”œâ”€â”€ User.schema.json\nâ”‚   â””â”€â”€ User.md\nâ””â”€â”€ events.schema.json\n```\n"
                                    },
                                    {
                                      "type": "file",
                                      "name": "events.schema.json",
                                      "template": "{\\n  \\\"$schema\\\": \\\"http://json-schema.org/draft-07/schema#\\\",\\n  \\\"title\\\": \\\"Raw Event\\\",\\n  \\\"type\\\": \\\"object\\\",\\n  \\\"additionalProperties\\\": true\\n}\\n"
                                    },
                                    {
                                      "type": "file",
                                      "name": "events.md",
                                      "template": "# Raw events (JSON)\n\nDescribe the upstream event payload.\n"
                                    }
                                  ]
                                },
                                {
                                  "type": "dir",
                                  "name": "files",
                                  "children": [
                                    {
                                      "type": "file",
                                      "name": "README.md",
                                      "template": "# File schemas\n\nPlace file-based schemas here (CSV/JSON/Parquet/Avro/NDJSON). Files in this folder are shown in the Files tab.\n\nExamples:\n- `events.csv`\n- `events.schema.json` (with title/description)\n\n## OpenAPI type generation\n\nIf you have an OpenAPI spec, you can generate TypeScript types and then re-export them from your resource model.\n\n### Recommended: hey-api\n```bash\npnpm dlx @hey-api/openapi-ts -i schemas/raw/files/openapi.json -o src/generated\n```\n\nAfter generation, edit `src/{resource}/model.ts` to re-export the generated type.\n"
                                    }
                                  ]
                                },
                                {
                                  "type": "dir",
                                  "name": "relational",
                                  "children": [
                                    {
                                      "type": "file",
                                      "name": "tables.json",
                                      "template": "{\\n  \\\"tables\\\": []\\n}\\n"
                                    },
                                    {
                                      "type": "file",
                                      "name": "tables.sql",
                                      "template": "-- DDL placeholders for raw tables\n"
                                    },
                                    {
                                      "type": "file",
                                      "name": "README.md",
                                      "template": "# Raw relational schema\n\nDescribe tables and relationships.\n"
                                    }
                                  ]
                                }
                              ]
                            },
                            {
                              "type": "dir",
                              "name": "extracted",
                              "children": [
                                {
                                  "type": "dir",
                                  "name": "json",
                                  "children": [
                                    {
                                      "type": "file",
                                      "name": "README.md",
                                      "template": "# Extracted JSON Schemas\n\nThis directory contains normalized/transformed JSON schemas.\n\n## Organization\n\nLike raw schemas, extracted schemas can be organized in nested folders:\n- `entities/` - Normalized business entities\n- `metrics/` - Calculated metrics or aggregations\n- `reports/` - Structured report schemas\n- Or any logical grouping for your transformed data\n\n## Naming Convention\n\nUse the same folder structure as in `raw/endpoints/` when there's a 1:1 mapping, or create new logical groupings for transformed data.\n"
                                    },
                                    {
                                      "type": "file",
                                      "name": "events.schema.json",
                                      "template": "{\\n  \\\"$schema\\\": \\\"http://json-schema.org/draft-07/schema#\\\",\\n  \\\"title\\\": \\\"Extracted Event\\\",\\n  \\\"type\\\": \\\"object\\\",\\n  \\\"additionalProperties\\\": false,\\n  \\\"properties\\\": {}\\n}\\n"
                                    },
                                    {
                                      "type": "file",
                                      "name": "events.md",
                                      "template": "# Extracted events (JSON)\n\nDescribe the normalized event shape.\n"
                                    }
                                  ]
                                },
                                {
                                  "type": "dir",
                                  "name": "relational",
                                  "children": [
                                    {
                                      "type": "file",
                                      "name": "tables.json",
                                      "template": "{\\n  \\\"tables\\\": []\\n}\\n"
                                    },
                                    {
                                      "type": "file",
                                      "name": "tables.sql",
                                      "template": "-- DDL placeholders for extracted tables\n"
                                    },
                                    {
                                      "type": "file",
                                      "name": "README.md",
                                      "template": "# Extracted relational schema\n\nDescribe normalized tables and relationships.\n"
                                    }
                                  ]
                                }
                              ]
                            }
                          ]
                        },
                        {
                          "type": "dir",
                          "name": "src",
                          "children": [
                            {
                              "type": "dir",
                              "name": "generated",
                              "children": [
                                { "type": "file", "name": ".gitkeep", "template": "" }
                              ]
                            },
                            {
                              "type": "dir",
                              "name": "observability",
                              "children": [
                                {
                                  "type": "file",
                                  "name": "logging-hooks.ts",
                                  "template": "import type { Hook, HookContext } from '@connector-factory/core'\n\nexport type LogLevel = 'debug' | 'info' | 'warn' | 'error'\nexport type LoggingOptions = { level?: LogLevel; logger?: (level: LogLevel, event: Record<string, unknown>) => void; includeQueryParams?: boolean; includeHeaders?: boolean; includeBody?: boolean }\n\nconst levelOrder: Record<LogLevel, number> = { debug: 10, info: 20, warn: 30, error: 40 }\nconst shouldLog = (cfg: LoggingOptions, level: LogLevel) => (levelOrder[level] >= levelOrder[cfg.level ?? 'info'])\n\nfunction safeUrl(raw?: string, includeQuery = false): { url?: string; query?: Record<string, unknown> } {\n  if (!raw) return {}\n  try {\n    const isPathOnly = raw.startsWith('/')\n    const u = new URL(isPathOnly ? `https://dummy${raw}` : raw)\n    if (!includeQuery) return { url: isPathOnly ? u.pathname : u.toString() }\n    const query: Record<string, unknown> = {}\n    u.searchParams.forEach((v, k) => { query[k] = v })\n    return { url: isPathOnly ? `${u.pathname}${u.search}` : u.toString(), query }\n  } catch {\n    return { url: raw }\n  }\n}\n\nexport function createLoggingHooks(opts: LoggingOptions = {}): Partial<{ beforeRequest: Hook[]; afterResponse: Hook[]; onError: Hook[]; onRetry: Hook[] }> {\n  const logger = opts.logger ?? ((level: LogLevel, event: Record<string, unknown>) => { console.log(level, event) })\n  const beforeRequest: Hook = { name: 'logging:beforeRequest', execute: (ctx: HookContext) => { if (ctx.type !== 'beforeRequest' || !shouldLog(opts, 'info')) return; const rawUrl = ctx.request.url || ctx.request.path; const { url, query } = safeUrl(rawUrl, !!opts.includeQueryParams); const evt: Record<string, unknown> = { event: 'http_request', operation: ctx.operation ?? ctx.request.operation, method: ctx.request.method, url }; if (opts.includeQueryParams && query) evt.query = query; if (opts.includeHeaders) evt.headers = ctx.request.headers; if (opts.includeBody && ctx.request.body !== undefined) evt.body = ctx.request.body; logger('info', evt) } }\n  const afterResponse: Hook = { name: 'logging:afterResponse', execute: (ctx: HookContext) => { if (ctx.type !== 'afterResponse' || !shouldLog(opts, 'info')) return; const rawUrl = ctx.request.url || ctx.request.path; const { url } = safeUrl(rawUrl, !!opts.includeQueryParams); const evt: Record<string, unknown> = { event: 'http_response', operation: ctx.operation ?? ctx.request.operation, method: ctx.request.method, url, status: ctx.response.status, durationMs: ctx.response.meta?.durationMs, retryCount: ctx.response.meta?.retryCount }; if (opts.includeHeaders) (evt as any).headers = (ctx.response as any).headers; if (opts.includeBody) (evt as any).body = ctx.response.data; logger('info', evt) } }\n  const onError: Hook = { name: 'logging:onError', execute: (ctx: HookContext) => { if (ctx.type !== 'onError' || !shouldLog(opts, 'error')) return; logger('error', { event: 'http_error', operation: ctx.operation, message: (ctx.error as any)?.message, code: (ctx.error as any)?.code, statusCode: (ctx.error as any)?.statusCode }) } }\n  const onRetry: Hook = { name: 'logging:onRetry', execute: (ctx: HookContext) => { if (ctx.type !== 'onRetry' || !shouldLog(opts, 'debug')) return; logger('debug', { event: 'http_retry', operation: ctx.metadata.operation ?? ctx.operation, attempt: ctx.metadata.attempt }) } }\n  return { beforeRequest: [beforeRequest], afterResponse: [afterResponse], onError: [onError], onRetry: [onRetry] }\n}\n"
                                },
                                {
                                  "type": "file",
                                  "name": "metrics-hooks.ts",
                                  "template": "import type { Hook, HookContext } from '@connector-factory/core'\n\nexport type MetricsEvent = { type: 'request'; operation?: string } | { type: 'response'; operation?: string; status?: number; durationMs?: number } | { type: 'error'; operation?: string; code?: string } | { type: 'retry'; operation?: string; attempt?: number }\nexport interface MetricsSink { record: (event: MetricsEvent) => void }\nexport class InMemoryMetricsSink implements MetricsSink { public events: MetricsEvent[] = []; record(e: MetricsEvent) { this.events.push(e) } }\n\nexport function createMetricsHooks(sink: MetricsSink) {\n  const beforeRequest: Hook = { name: 'metrics:beforeRequest', execute: (ctx: HookContext) => { if (ctx.type !== 'beforeRequest') return; sink.record({ type: 'request', operation: ctx.operation ?? ctx.request?.operation }) } }\n  const afterResponse: Hook = { name: 'metrics:afterResponse', execute: (ctx: HookContext) => { if (ctx.type !== 'afterResponse') return; sink.record({ type: 'response', operation: ctx.operation ?? ctx.request?.operation, status: ctx.response?.status, durationMs: ctx.response?.meta?.durationMs }) } }\n  const onError: Hook = { name: 'metrics:onError', execute: (ctx: HookContext) => { if (ctx.type !== 'onError') return; sink.record({ type: 'error', operation: ctx.operation, code: (ctx.error as any)?.code }) } }\n  const onRetry: Hook = { name: 'metrics:onRetry', execute: (ctx: HookContext) => { if (ctx.type !== 'onRetry') return; sink.record({ type: 'retry', operation: ctx.metadata?.operation ?? ctx.operation, attempt: ctx.metadata?.attempt }) } }\n  return { beforeRequest: [beforeRequest], afterResponse: [afterResponse], onError: [onError], onRetry: [onRetry] }\n}\n"
                                }
                              ]
                            },
                            {
                              "type": "file",
                              "name": "index.ts",
                              "template": "export * from './client/connector'\n"
                            },
                            {
                              "type": "dir",
                              "name": "client",
                              "children": [
                                {
                                  "type": "file",
                                  "name": "connector.ts",
                                  "template": "import { ApiConnectorBase } from '@connector-factory/core'\nimport type { ConnectorConfig as CoreConfig, Hook } from '@connector-factory/core'\nimport { createLoggingHooks } from '../observability/logging-hooks'\nimport { createMetricsHooks, InMemoryMetricsSink } from '../observability/metrics-hooks'\n\nexport type ConnectorConfig = CoreConfig & {\n  logging?: { enabled?: boolean; level?: 'debug'|'info'|'warn'|'error'; includeQueryParams?: boolean; includeHeaders?: boolean; includeBody?: boolean; logger?: (level: string, event: Record<string, unknown>) => void },\n  metrics?: { enabled?: boolean }\n}\n\nexport class Connector extends ApiConnectorBase {\n  initialize(userConfig: ConnectorConfig) {\n    const withDefaults = (u: ConnectorConfig): ConnectorConfig => ({ userAgent: u.userAgent ?? '{connector}', ...u })\n    super.initialize(withDefaults(userConfig) as any, (cfg: any) => cfg)\n\n    const cfg = (this as any).config as ConnectorConfig\n    const existing = cfg.hooks ?? {} as Partial<Record<'beforeRequest'|'afterResponse'|'onError'|'onRetry', Hook[]>>\n\n    if (userConfig.logging?.enabled) {\n      const logging = createLoggingHooks({ level: userConfig.logging.level, includeQueryParams: userConfig.logging.includeQueryParams, includeHeaders: userConfig.logging.includeHeaders, includeBody: userConfig.logging.includeBody, logger: userConfig.logging.logger as any })\n      cfg.hooks = {\n        beforeRequest: [...(existing.beforeRequest ?? []), ...(logging.beforeRequest ?? [])],\n        afterResponse: [...(existing.afterResponse ?? []), ...(logging.afterResponse ?? [])],\n        onError: [...(existing.onError ?? []), ...(logging.onError ?? [])],\n        onRetry: [...(existing.onRetry ?? []), ...(logging.onRetry ?? [])],\n      }\n    }\n\n    if (userConfig.metrics?.enabled) {\n      const sink = new InMemoryMetricsSink()\n      const metrics = createMetricsHooks(sink)\n      const curr = cfg.hooks ?? {}\n      cfg.hooks = {\n        beforeRequest: [...(curr.beforeRequest ?? []), ...(metrics.beforeRequest ?? [])],\n        afterResponse: [...(curr.afterResponse ?? []), ...(metrics.afterResponse ?? [])],\n        onError: [...(curr.onError ?? []), ...(metrics.onError ?? [])],\n        onRetry: [...(curr.onRetry ?? []), ...(metrics.onRetry ?? [])],\n      }\n      ;(this as any)._metricsSink = sink\n    }\n  }\n}\n\nexport function createConnector() { return new Connector() }\n"
                                }
                              ]
                            },
                            {
                              "type": "dir",
                              "name": "lib",
                              "children": [
                                {
                                  "type": "file",
                                  "name": "paginate.ts",
                                  "template": "export type HttpResponseEnvelope<T> = { data: T }\n\nexport type SendFn = <T = any>(args: {\n  method: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';\n  path: string;\n  query?: Record<string, any>;\n  headers?: Record<string, string>;\n  body?: unknown;\n  operation?: string;\n}) => Promise<HttpResponseEnvelope<T>>\n\n// Optional: cursor pagination helper (commented)\n// export async function* paginateCursor<T = any>(params: {\n//   send: SendFn; path: string; query?: Record<string, any>; pageSize?: number;\n//   extractItems?: (res: any) => T[]; extractNextCursor?: (res: any) => string | undefined;\n// }) { /* ... see docs for an example ... */ }\n"
                                },
                                {
                                  "type": "file",
                                  "name": "make-resource.ts",
                                  "template": "import type { SendFn } from './paginate'\n\n/**\n * Create a simple resource API at the given path.\n *\n * Exposes a single getAll async generator that fetches once and yields client-side chunks.\n * This default suits APIs that don't expose server-side pagination.\n *\n * For real pagination, add a paginate helper and layer getAll on top.\n */\nexport function makeCrudResource<\n  Item,\n  ListParams extends Record<string, any> | undefined = undefined\n>(\n  objectPath: string,\n  send: SendFn,\n  options?: {\n    buildListQuery?: (params?: ListParams) => Record<string, any>\n  }\n) {\n  return {\n    async *getAll(\n      params?: (ListParams extends undefined\n        ? { pageSize?: number; maxItems?: number }\n        : ListParams & { pageSize?: number; maxItems?: number })\n    ): AsyncGenerator<ReadonlyArray<Item>> {\n      const listQuery = options?.buildListQuery?.(params as any) ?? {}\n      const res = await send<Item[]>({ method: 'GET', path: objectPath, query: listQuery, operation: 'getAll' })\n      const data = Array.isArray(res.data) ? res.data : []\n\n      const pageSize = (params as any)?.pageSize as number | undefined\n      const maxItems = (params as any)?.maxItems as number | undefined\n\n      let start = 0\n      let remaining = typeof maxItems === 'number' ? Math.max(0, maxItems) : undefined\n\n      if (!pageSize || pageSize <= 0) {\n        yield remaining !== undefined ? data.slice(0, remaining) : data\n        return\n      }\n\n      while (start < data.length) {\n        const end = Math.min(data.length, start + pageSize)\n        let chunk = data.slice(start, end)\n        if (remaining !== undefined) {\n          if (remaining <= 0) break\n          if (chunk.length > remaining) chunk = chunk.slice(0, remaining)\n          remaining -= chunk.length\n        }\n        yield chunk\n        start = end\n      }\n    },\n  }\n}\n"
                                }
                              ]
                            },
                            {
                              "type": "dir",
                              "name": "{resource}",
                              "children": [
                                {
                                  "type": "file",
                                  "name": "index.ts",
                                      "template": "import { makeCrudResource } from '../lib/make-resource'\nimport type { SendFn } from '../lib/paginate'\nimport type { Model } from './model'\n\nexport const createResource = (send: SendFn) => makeCrudResource<Model, { /* filters */ }>('/* resource path */', send, {\n  buildListQuery: (params) => ({ /* map typed filters to query */ }),\n})\n"
                                },
                                {
                                  "type": "file",
                                  "name": "model.ts",
                                  "template": "// Model typing for this resource.\n// If you generate types from OpenAPI, you can re-export here, e.g.:\n// export type Model = components['schemas']['Widget'];\n// Otherwise, start with a minimal interface and refine as needed.\nexport interface Model {\n  id?: string | number\n}\n"
                                }
                              ]
                            }
                          ]
                        },
                        {
                          "type": "dir",
                          "name": "tests",
                          "children": [
                            {
                              "type": "file",
                              "name": "observability.test.ts",
                              "template": "/* eslint-env jest */\nimport nock from 'nock'\nimport { createConnector } from '../src'\n\nit('logging includes url, headers, body when enabled', async () => {\n  const BASE = 'https://api.example.com'\n  nock(BASE).get('/{resource}').query({ x: '1' }).reply(200, [{ id: 1 }], { 'x-test-header': 'ok' })\n  const events: Array<{ level: string; event: Record<string, unknown> }> = []\n  const conn = createConnector()\n  conn.initialize({ baseUrl: BASE, auth: { type: 'bearer', bearer: { token: 't' } }, logging: { enabled: true, level: 'info', includeQueryParams: true, includeHeaders: true, includeBody: true, logger: (level, event) => events.push({ level, event }) } })\n  await (conn as any).request({ method: 'GET', path: '/{resource}?x=1' })\n  const reqEvt = events.find(e => (e.event as any)?.event === 'http_request')?.event as any\n  const respEvt = events.find(e => (e.event as any)?.event === 'http_response')?.event as any\n  expect(String(respEvt.url)).toContain('/{resource}?x=1')\n  expect(typeof reqEvt.headers).toBe('object')\n  expect((respEvt.headers ?? {})['x-test-header']).toBe('ok')\n  expect(respEvt.body).toEqual([{ id: 1 }])\n})\n"
                            },
                                {
                                  "type": "file",
                                  "name": "resource.test.ts",
                                  "template": "/* eslint-env jest */\nimport nock from 'nock'\nimport { createConnector } from '../src'\n\nit('getAll yields chunks and respects maxItems', async () => {\n  const BASE = 'https://api.example.com'\n  const data = Array.from({ length: 5 }, (_, i) => ({ id: i + 1 }))\n  nock(BASE).get('/{resource}').reply(200, data)\n  const conn = createConnector()\n  conn.initialize({ baseUrl: BASE, auth: { type: 'bearer', bearer: { token: 't' } } })\n  const pages: Array<ReadonlyArray<unknown>> = []\n  for await (const page of (conn as any).{resource}.getAll({ pageSize: 2, maxItems: 4 })) pages.push(page)\n  expect(pages.map(p => p.length)).toEqual([2, 2])\n})\n"
                                }
                          ]
                        },
                        {
                          "type": "dir",
                          "name": "examples",
                          "children": [
                            {
                              "type": "file",
                              "name": "basic-usage.ts",
                              "template": "import { Client } from './src/client'\nconsole.log(new Client({}).ping())\n"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    }
  ]
}