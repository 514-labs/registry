// This file is auto-generated by @hey-api/openapi-ts

import type { Client, Options as Options2, TDataShape } from './client';
import { client } from './client.gen';
import type { BatchLabResultsPostData, BatchLabResultsPostErrors, BatchLabResultsPostResponses, BrandGetData, BrandGetErrors, BrandGetResponses, BrandPostData, BrandPostErrors, BrandPostResponses, CustomerByExternalIdGetData, CustomerByExternalIdGetErrors, CustomerByExternalIdGetResponses, CustomerCustomerLookupPostData, CustomerCustomerLookupPostErrors, CustomerCustomerLookupPostResponses, CustomerCustomerPostData, CustomerCustomerPostErrors, CustomerCustomerPostResponses, CustomerCustomersGetData, CustomerCustomersGetErrors, CustomerCustomersGetResponses, CustomerCustomersPaginatedGetData, CustomerCustomersPaginatedGetErrors, CustomerCustomersPaginatedGetResponses, CustomerCustomerTypesGetData, CustomerCustomerTypesGetErrors, CustomerCustomerTypesGetResponses, CustomerJournalCreatePostData, CustomerJournalCreatePostErrors, CustomerJournalCreatePostResponses, CustomerJournalGetData, CustomerJournalGetErrors, CustomerJournalGetResponses, CustomerJournalUpdatePostData, CustomerJournalUpdatePostErrors, CustomerJournalUpdatePostResponses, CustomerReferralSourcesGetData, CustomerReferralSourcesGetErrors, CustomerReferralSourcesGetResponses, CustomerSearchPostData, CustomerSearchPostErrors, CustomerSearchPostResponses, DeliveriesGetData, DeliveriesGetErrors, DeliveriesGetResponses, DeliveriesSetRouteDetailPostData, DeliveriesSetRouteDetailPostErrors, DeliveriesSetRouteDetailPostResponses, DiscountsGetData, DiscountsGetErrors, DiscountsGetResponses, DiscountsV2ListGetData, DiscountsV2ListGetErrors, DiscountsV2ListGetResponses, DriversGetData, DriversGetErrors, DriversGetResponses, DriversPostData, DriversPostErrors, DriversPostResponses, EmployeesGetData, EmployeesGetErrors, EmployeesGetResponses, GuestlistGetData, GuestlistGetErrors, GuestlistGetResponses, HarvestBulkPostData, HarvestBulkPostErrors, HarvestBulkPostResponses, HarvestGetData, HarvestGetErrors, HarvestGetResponses, HarvestPostData, HarvestPostErrors, HarvestPostResponses, IntegrationIntegrationReconGetData, IntegrationIntegrationReconGetErrors, IntegrationIntegrationReconGetResponses, InventoryGetData, InventoryGetErrors, InventoryGetResponses, InventoryInventorytransactionGetData, InventoryInventorytransactionGetErrors, InventoryInventorytransactionGetResponses, InventoryLabresultsGetData, InventoryLabresultsGetErrors, InventoryLabresultsGetResponses, InventoryReceivedinventoryGetData, InventoryReceivedinventoryGetErrors, InventoryReceivedinventoryGetResponses, InventoryReceiveinventoryPostData, InventoryReceiveinventoryPostErrors, InventoryReceiveinventoryPostResponses, InventorySnapshotGetData, InventorySnapshotGetErrors, InventorySnapshotGetResponses, LineagesGetData, LineagesGetErrors, LineagesGetResponses, OkcomputerGetData, OkcomputerGetErrors, OkcomputerGetResponses, PackageAddTagsPostData, PackageAddTagsPostErrors, PackageAddTagsPostResponses, PackageRemoveTagsPostData, PackageRemoveTagsPostErrors, PackageRemoveTagsPostResponses, PackageSetTagsPostData, PackageSetTagsPostErrors, PackageSetTagsPostResponses, PlantAssignPlantsToGroupPostData, PlantAssignPlantsToGroupPostErrors, PlantAssignPlantsToGroupPostResponses, PlantChangePhasePostData, PlantChangePhasePostErrors, PlantChangePhasePostResponses, PlantGetData, PlantGetErrors, PlantGetReasonCodesGetData, PlantGetReasonCodesGetErrors, PlantGetReasonCodesGetResponses, PlantGetResponses, PlantHarvestPostData, PlantHarvestPostErrors, PlantHarvestPostResponses, PlantMovePostData, PlantMovePostErrors, PlantMovePostResponses, PlantNonstsBatchConvertImmatureplantsPostData, PlantNonstsBatchConvertImmatureplantsPostErrors, PlantNonstsBatchConvertImmatureplantsPostResponses, PlantNonstsBatchFinishHarvestPostData, PlantNonstsBatchFinishHarvestPostErrors, PlantNonstsBatchFinishHarvestPostResponses, PlantNonstsBatchImmatureplantsPostData, PlantNonstsBatchImmatureplantsPostErrors, PlantNonstsBatchImmatureplantsPostResponses, PlantNonstsBatchMatureplantsPostData, PlantNonstsBatchMatureplantsPostErrors, PlantNonstsBatchMatureplantsPostResponses, PlantNonstsBatchPostData, PlantNonstsBatchPostErrors, PlantNonstsBatchPostResponses, PlantNonstsBatchRetirePostData, PlantNonstsBatchRetirePostErrors, PlantNonstsBatchRetirePostResponses, PlantNonstsRetagPostData, PlantNonstsRetagPostErrors, PlantNonstsRetagPostResponses, PlantNonstsSplitPostData, PlantNonstsSplitPostErrors, PlantNonstsSplitPostResponses, PlantNonstsUpdatePostData, PlantNonstsUpdatePostErrors, PlantNonstsUpdatePostResponses, PlantPostData, PlantPostErrors, PlantPostResponses, PlantRetirePostData, PlantRetirePostErrors, PlantRetirePostResponses, PreorderCancelPostData, PreorderCancelPostErrors, PreorderCancelPostResponses, PreorderPriceCartPostData, PreorderPriceCartPostErrors, PreorderPriceCartPostResponses, PreorderStatusGetData, PreorderStatusGetErrors, PreorderStatusGetResponses, PreorderSubmitPostData, PreorderSubmitPostErrors, PreorderSubmitPostResponses, PreorderUpdatePostData, PreorderUpdatePostErrors, PreorderUpdatePostResponses, PricingTiersGetData, PricingTiersGetErrors, PricingTiersGetResponses, ProducersGetData, ProducersGetErrors, ProducersGetResponses, ProductCategoryGetData, ProductCategoryGetErrors, ProductCategoryGetResponses, ProductsExternalCategoriesGetData, ProductsExternalCategoriesGetErrors, ProductsExternalCategoriesGetResponses, ProductsGetData, ProductsGetErrors, ProductsGetResponses, ProductsLocationOverridesGetData, ProductsLocationOverridesGetErrors, ProductsLocationOverridesGetResponses, ProductsLocationOverridesPostData, ProductsLocationOverridesPostErrors, ProductsLocationOverridesPostResponses, ProductsProductPostData, ProductsProductPostErrors, ProductsProductPostResponses, ProductsProductsPostData, ProductsProductsPostErrors, ProductsProductsPostResponses, ProductsRemoveImagePostData, ProductsRemoveImagePostErrors, ProductsRemoveImagePostResponses, ProductsSetImagePostData, ProductsSetImagePostErrors, ProductsSetImagePostResponses, ProductsStrainsGetData, ProductsStrainsGetErrors, ProductsStrainsGetResponses, PurchaseOrderGetData, PurchaseOrderGetErrors, PurchaseOrderGetResponses, PurchaseOrderPostData, PurchaseOrderPostErrors, PurchaseOrderPostResponses, ReferenceLabResultsNamesGetData, ReferenceLabResultsNamesGetErrors, ReferenceLabResultsNamesGetResponses, ReferenceLabResultUnitsGetData, ReferenceLabResultUnitsGetErrors, ReferenceLabResultUnitsGetResponses, ReferenceUnitsGetData, ReferenceUnitsGetErrors, ReferenceUnitsGetResponses, ReferenceUnitTypesGetData, ReferenceUnitTypesGetErrors, ReferenceUnitTypesGetResponses, RegulatoryCategoryGetData, RegulatoryCategoryGetErrors, RegulatoryCategoryGetResponses, ReportingCashSummaryGetData, ReportingCashSummaryGetErrors, ReportingCashSummaryGetResponses, ReportingClosingReportGetData, ReportingClosingReportGetErrors, ReportingClosingReportGetResponses, ReportingCustomersGetData, ReportingCustomersGetErrors, ReportingCustomersGetResponses, ReportingCustomersPaginatedGetData, ReportingCustomersPaginatedGetErrors, ReportingCustomersPaginatedGetResponses, ReportingDiscountsGetData, ReportingDiscountsGetErrors, ReportingDiscountsGetResponses, ReportingInventoryGetData, ReportingInventoryGetErrors, ReportingInventoryGetResponses, ReportingLoyaltySnapshotGetData, ReportingLoyaltySnapshotGetErrors, ReportingLoyaltySnapshotGetResponses, ReportingProductsGetData, ReportingProductsGetErrors, ReportingProductsGetResponses, ReportingRegisterAdjustmentsGetData, ReportingRegisterAdjustmentsGetErrors, ReportingRegisterAdjustmentsGetResponses, ReportingRegisterTransactionsGetData, ReportingRegisterTransactionsGetErrors, ReportingRegisterTransactionsGetResponses, ReportingTransactionsGetData, ReportingTransactionsGetErrors, ReportingTransactionsGetResponses, RoomPostData, RoomPostErrors, RoomPostResponses, RoomRoomsGetData, RoomRoomsGetErrors, RoomRoomsGetResponses, SizesGetData, SizesGetErrors, SizesGetResponses, StrainsGetData, StrainsGetErrors, StrainsGetResponses, StrainsPostData, StrainsPostErrors, StrainsPostResponses, StrainsTypesGetData, StrainsTypesGetErrors, StrainsTypesGetResponses, TablePostData, TablePostErrors, TablePostResponses, TableTablesGetData, TableTablesGetErrors, TableTablesGetResponses, TagGetData, TagGetErrors, TagGetResponses, TerminalsGetData, TerminalsGetErrors, TerminalsGetResponses, TransactionCreateAnonymousPostData, TransactionCreateAnonymousPostErrors, TransactionCreateAnonymousPostResponses, UtilAuthorizationHeaderByApiKeyGetData, UtilAuthorizationHeaderByApiKeyGetResponses, VehiclesGetData, VehiclesGetErrors, VehiclesGetResponses, VehiclesPostData, VehiclesPostErrors, VehiclesPostResponses, VendorPostData, VendorPostErrors, VendorPostResponses, VendorVendorsGetData, VendorVendorsGetErrors, VendorVendorsGetResponses, WasteGetData, WasteGetErrors, WasteGetResponses, WasteHarvestWastePostData, WasteHarvestWastePostErrors, WasteHarvestWastePostResponses, WastePlantWastePostData, WastePlantWastePostErrors, WastePlantWastePostResponses, WhoamiGetData, WhoamiGetErrors, WhoamiGetResponses } from './types.gen';

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = Options2<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

/**
 * Create or Update Batch Lab Results
 * **Purpose:** Create or update comprehensive laboratory testing results for a specific batch to ensure compliance with cannabis regulations and provide quality assurance data.
 *
 * **Request Requirements:**
 * - "PackageWrite" role authorization required for lab data operations
 * - `UpdateBatchLabResultsRequest` object in request body with lab result data
 * - Content-Type: application/json
 * - BatchName must exist and be accessible to your location
 *
 * **Response Data:**
 * - Returns success confirmation (HTTP 200) upon successful creation or update
 * - No response body content (void return)
 * - Lab results are validated and stored for compliance and quality tracking
 * - Updates are reflected immediately in batch data and inventory systems
 *
 * **Create vs Update Behavior:**
 * - **CREATE**: When no lab results exist for the batch, new lab results will be created
 * - **UPDATE**: When lab results already exist for the batch, existing results will be updated
 * - **Validation**: Lab result data must pass validation requirements for regulatory compliance
 * - **Batch Sharing**: All packages within the same batch share identical lab results
 *
 * **Request Body Fields:**
 * - BatchName: Name of the batch to update lab results for (required)
 * - SampleWeight: Weight of the sample tested (optional, defaults to -1)
 * - LabResults: Array of lab result objects with test data (required)
 *
 * **Sparse Update Behavior:**
 * - **Provided lab results**: Will overwrite existing test data with new values
 * - **Omitted lab results**: Existing test data for those analytes will be preserved
 * - **Special handling**: If multiple packages exist in the same batch, all will share the updated results
 * - **Validation**: All provided lab data must meet regulatory testing standards
 *
 * **Lab Result Data Types:**
 * - **Cannabinoid Testing**: THC, THCA, CBD, CBDA, CBN, CBG concentrations
 * - **Safety Testing**: Pesticides, heavy metals, microbials, mycotoxins results
 * - **Quality Testing**: Moisture content, foreign matter, residual solvents
 * - **Potency Testing**: Total THC/CBD calculations and verification
 * - **Terpene Testing**: Terpene profiles and concentration data
 *
 * **Common Use Cases:**
 * - Submit initial lab results from testing laboratory for compliance reporting
 * - Update lab results when retesting or additional testing is performed
 * - Correct lab result data when errors are discovered
 * - Add supplementary testing results (terpenes, additional cannabinoids)
 * - Maintain accurate Certificate of Analysis (COA) data for regulatory compliance
 *
 * **Performance & Limits:**
 * - Single batch operation for targeted lab result updates
 * - Immediate validation and compliance checking
 * - Changes propagate to all packages within the batch immediately
 * - Optimized for laboratory workflow integration
 *
 * **Related Endpoints:**
 * - `POST /package/lab-results` - Update lab results by package ID instead of batch name
 * - `GET /inventory/labresults` - Retrieve lab results for display and verification
 * - `GET /reference/lab-result-units` - Get valid units for lab result data
 * - `GET /reference/lab-results-names` - Get valid analyte names for testing
 *
 * **Important Notes:**
 * - **Batch Sharing**: All packages in the same batch will share these lab results
 * - **Compliance Critical**: Lab results are required for legal cannabis sales and regulatory reporting
 * - **Data Integrity**: Validation ensures lab results meet regulatory standards
 * - **Certificate Updates**: Changes update Certificate of Analysis (COA) documentation
 * - **Alternative Access**: Use POST /package/lab-results if you prefer to work with package IDs
 */
export const batchLabResultsPost = <ThrowOnError extends boolean = false>(options?: Options<BatchLabResultsPostData, ThrowOnError>) => {
    return (options?.client ?? client).post<BatchLabResultsPostResponses, BatchLabResultsPostErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/batch/lab-results',
        ...options,
        headers: {
            'Content-Type': 'application/json-patch+json',
            ...options?.headers
        }
    });
};

/**
 * Get All Brands
 * **Purpose:** Retrieve comprehensive list of all active product brands available for the authenticated location.
 *
 * **Request Requirements:**
 * - Any authenticated role authorization (no specific role required)
 * - No query parameters or request body needed
 *
 * **Response Data:**
 * - Returns array of brand objects: `[{ Brand }, ...]`
 * - Array typically contains 10-100 brands per location
 * - Returns empty array `[]` if no brands configured for location
 * - Brand ID, name, and optional external catalog identifiers
 * - Only active, non-deleted brands are included in results
 * - Results automatically filtered to authenticated location
 *
 * **Common Use Cases:**
 * - Populate brand dropdown lists in product creation and editing forms
 * - Show available brands for product categorization and filtering on e-commerce sites
 * - Group products by brand for inventory management and organization
 * - Generate brand-specific reports for regulatory compliance requirements
 * - Organize dispensary menus by brand for customer browsing
 * - Synchronize brand data with external POS and e-commerce systems
 *
 * **Performance & Limits:**
 * - Lightweight data that is typically small and fast to retrieve
 * - This endpoint is commonly called for form population and product management
 * - No pagination needed due to typically small brand datasets
 *
 * **Related Endpoints:**
 * - `GET /products` - Get products which include brand information in response
 * - `POST /brand` - Create or update brand information
 *
 * **Important Notes:**
 * - Despite the singular endpoint name `/brand`, this method returns multiple brands (an array)
 * - Brands are automatically scoped to the authenticated dispensary location
 * - Only active brands are returned; deleted brands are excluded
 * - Brands returned here can be used when creating or updating products
 */
export const brandGet = <ThrowOnError extends boolean = false>(options?: Options<BrandGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<BrandGetResponses, BrandGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/brand',
        ...options
    });
};

/**
 * Create or Update Brand
 * **Purpose:** Creates a new brand or updates an existing brand with the provided brand information.
 *
 * **Request Requirements:**
 * - Any authenticated role authorization (no specific role required)
 * - `BrandEditRequest` object in request body with brand details
 * - Content-Type: application/json
 *
 * **Response Data:**
 * - Returns brand object: `{ Brand }`
 * - Includes assigned or updated brand ID and all brand properties
 *
 * **Create vs Update Behavior:**
 * - **CREATE**: When `BrandId` is null or omitted, a new brand will be created
 * - **UPDATE**: When `BrandId` is provided with a valid brand ID, the existing brand will be updated
 * - **Validation**: Brand name is required for both operations and must be unique within the location
 *
 * **Sparse Update Behavior:**
 * - **Provided fields**: Will overwrite existing brand values with provided data
 * - **Omitted fields**: Will preserve existing brand values (no data loss)
 * - **Required validation**: BrandName must be provided even for updates
 *
 * **Common Use Cases:**
 * - Add new product brands to the system for product categorization
 * - Update existing brand information when details change
 * - Maintain brand consistency across products and inventory
 * - Synchronize brand data from external systems
 *
 * **Performance & Limits:**
 * - Single brand operation for targeted updates
 * - Immediate validation and response
 * - Changes are reflected immediately in brand listings
 *
 * **Related Endpoints:**
 * - `GET /brand` - Retrieve all brands to see current brand list
 * - `GET /products` - View products that use specific brands
 *
 * **Important Notes:**
 * - Brand name must be unique within the authenticated location
 * - All validation errors will be returned in a structured error response
 * - This endpoint handles a single brand per request
 * - Successful operations return the complete brand object
 */
export const brandPost = <ThrowOnError extends boolean = false>(options?: Options<BrandPostData, ThrowOnError>) => {
    return (options?.client ?? client).post<BrandPostResponses, BrandPostErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/brand',
        ...options,
        headers: {
            'Content-Type': 'application/json-patch+json',
            ...options?.headers
        }
    });
};

/**
 * Get Customers
 * **Purpose:** Retrieves a list of customers with optional filtering by modification date, customer ID, or unique ID for customer management and data synchronization.
 *
 * **Request Requirements:**
 * - "Customer" role authorization required for customer data operations
 * - Optional query parameters for filtering results
 * - No request body needed
 *
 * **Response Data:**
 * - Returns array of customer objects: `[{ Customer }, ...]`
 * - Array may contain 0 to 10,000+ customers depending on location and filtering
 * - Returns empty array `[]` if no customers match criteria (not null)
 * - Includes loyalty status and qualifying conditions when available
 * - Results automatically filtered by the authenticated user's location
 * - Customer profiles with contact information and preferences
 *
 * **Filtering Options:**
 * - No parameters: Returns all customers for the location
 * - fromLastModifiedDateUTC: Returns customers modified after this date for incremental sync
 * - toLastModifiedDateUTC: Returns customers modified before this date for date range filtering
 * - customerID: Returns a specific customer by internal ID
 * - uniqueId: Returns a specific customer by unique identifier
 * - includeAnonymous: Include/exclude anonymous customers (default: true)
 *
 * **Common Use Cases:**
 * - Call without parameters for initial sync to get all customers
 * - Use fromLastModifiedDateUTC for incremental sync to get only recent changes
 * - Use customerID or uniqueId for specific customer retrieval
 * - Sync customer data for point-of-sale systems integration
 * - Export customer data for external CRM or marketing systems
 *
 * **Performance & Limits:**
 * - Maximum date range is configurable per location (default: 90 days)
 * - Use incremental sync for large datasets to avoid timeouts
 * - Optimized for high-volume data synchronization
 * - Consider using paginated endpoint for very large customer bases
 *
 * **Related Endpoints:**
 * - `GET /customer/customers-paginated` - Paginated version for large datasets
 * - `POST /customer` - Create or update customer information
 * - `POST /customerLookup` - Find existing customers by various search criteria
 *
 * **Important Notes:**
 * - Results filtered to authenticated user's location for data security
 * - Date range limits help prevent timeouts with large customer databases
 * - Anonymous customers can be included or excluded based on business needs
 * - Loyalty status information included when available for customer insights
 */
export const customerCustomersGet = <ThrowOnError extends boolean = false>(options?: Options<CustomerCustomersGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<CustomerCustomersGetResponses, CustomerCustomersGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/customer/customers',
        ...options
    });
};

/**
 * Get Customers (Paginated)
 * **Purpose:** Retrieves customers in paginated chunks for better performance with large customer datasets and efficient memory management.
 *
 * **Request Requirements:**
 * - "Customer" role authorization required for customer data operations
 * - Optional query parameters for pagination and filtering
 * - No request body needed
 *
 * **Response Data:**
 * - Response format: `[{ Customer }, { Customer }, ...]`
 * - **No pagination metadata**: Response contains only data array without total counts or page information
 * - Array contains up to PageSize customers (default 1000, max 10000)
 * - Returns empty array `[]` if no customers found for page (not null)
 * - Includes loyalty status and qualifying conditions when available
 * - Results automatically filtered by the authenticated user's location
 *
 * **Pagination Usage:**
 * - **First Request**: Call with PageNumber=0 to get first page
 * - **Subsequent Requests**: Increment PageNumber for each additional page
 * - **End Detection**: Continue requesting pages until you receive an empty array `[]`
 * - **Page Size Control**: Use PageSize parameter to control items per page (max 10,000)
 * - **Example Flow**: Request PageNumber=0 → Process results → Increment PageNumber → Repeat until empty `[]` response
 *
 * **Pagination Detection:**
 * - **End of data detection**: Continue requesting pages until you receive an empty array `[]`
 * - **No metadata provided**: Response does not include total counts, page counts, or hasNextPage indicators
 * - **Sequential access**: Increment PageNumber from 0 until empty response indicates no more data
 *
 * **Filtering Options:**
 * - fromLastModifiedDateUTC: Returns customers modified after this date
 * - toLastModifiedDateUTC: Returns customers modified before this date
 * - includeAnonymous: Include/exclude anonymous customers (default: true)
 *
 * **Common Use Cases:**
 * - Process large customer databases efficiently for data export
 * - Batch processing customers to avoid memory issues in applications
 * - Large-scale customer data synchronization with external systems
 * - Generate customer reports without overwhelming system resources
 * - Support high-volume customer data operations with controlled memory usage
 *
 * **Performance & Limits:**
 * - Maximum 10,000 customers per page for optimal performance
 * - Use consistent page size throughout pagination sequence for efficiency
 * - Monitor response times and adjust page size for optimal performance
 * - Cache results locally to minimize API calls and improve responsiveness
 * - Recommended over non-paginated endpoint for datasets over 1000 customers
 *
 * **Related Endpoints:**
 * - `GET /customer/customers` - Non-paginated version for smaller datasets
 * - `POST /customer` - Create or update customer information
 * - `POST /customerLookup` - Find specific customers by search criteria
 *
 * **Important Notes:**
 * - Use this endpoint instead of /customers for better performance with large datasets
 * - Results filtered to authenticated user's location for data security
 * - Pagination state management required in client applications
 * - Suitable for batch processing and large-scale data operations
 */
export const customerCustomersPaginatedGet = <ThrowOnError extends boolean = false>(options?: Options<CustomerCustomersPaginatedGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<CustomerCustomersPaginatedGetResponses, CustomerCustomersPaginatedGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/customer/customers-paginated',
        ...options
    });
};

/**
 * Get Customer Types
 * **Purpose:** Retrieve the complete list of customer types available for the authenticated location, used for customer categorization and compliance.
 *
 * **Request Requirements:**
 * - Valid API key authentication required (no specific role restrictions)
 * - No query parameters or request body needed
 *
 * **Response Data:**
 * - Returns array of `CustomerType` objects with customer type information
 * - Response format: `[{ CustomerType }, ...]`
 * - Array typically contains 2-10 customer types per location
 * - Returns empty array `[]` if no customer types enabled for location (rare)
 * - Each customer type includes: Id, Name, IsRetail, IsMedical flags
 * - Display names include "Adult Use", "Medical", "Wholesale", etc.
 * - Results automatically filtered to authenticated location's enabled types
 *
 * **Customer Type Fields:**
 * - Id: Unique identifier for the customer type
 * - Name: Display name of the customer type
 * - IsRetail: Boolean indicating if this type is for retail customers
 * - IsMedical: Boolean indicating if this type is for medical patients
 *
 * **Common Use Cases:**
 * - Populate dropdown/selection lists for customer type in registration forms
 * - Ensure customers are assigned to valid, location-specific types for compliance validation
 * - Configure point-of-sale systems with available customer categories
 * - Configure online ordering systems with proper customer types for e-commerce setup
 * - Understand customer type structure for reporting classification and analytics
 * - Validate customer type IDs before creating/updating customers
 *
 * **Performance & Limits:**
 * - Lightweight reference data optimized for frequent access
 * - Customer types rarely change; safe to cache for several hours
 * - Small dataset suitable for client-side caching
 * - Location-specific results based on API key access
 *
 * **Integration Workflow:**
 * 1. Call this endpoint to get available customer types for your location
 * 2. Present options to users in registration/update forms
 * 3. Use selected Id in POST /customer requests as CustomerTypeId
 * 4. Implement validation to ensure selected type is valid for your location
 *
 * **Related Endpoints:**
 * - `POST /customer` - Create customers using these customer type IDs
 * - `GET /customer/customers` - Get customers with their assigned types
 * - `GET /customer/referral-sources` - Get referral source reference data
 *
 * **Important Notes:**
 * - Customer types are location-specific and may vary between dispensary locations
 * - Only returns customer types enabled for your specific location
 * - Results automatically filtered based on your API key's location access
 * - Use Name field for user-facing displays, Id for API calls
 * - Use IsRetail/IsMedical flags for business rule implementation and compliance logic
 */
export const customerCustomerTypesGet = <ThrowOnError extends boolean = false>(options?: Options<CustomerCustomerTypesGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<CustomerCustomerTypesGetResponses, CustomerCustomerTypesGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/customer/customer-types',
        ...options
    });
};

/**
 * Get Referral Sources
 * **Purpose:** Retrieve the complete list of referral sources available system-wide, used for tracking customer acquisition and marketing campaign effectiveness.
 *
 * **Request Requirements:**
 * - "Customer" role authorization required for customer data operations
 * - No query parameters or request body needed
 *
 * **Response Data:**
 * - Returns array of string values representing available referral source options
 * - Response format: `["string", "string", ...]`
 * - Array typically contains 10-20 predefined referral sources
 * - Returns empty array `[]` if no referral sources configured (rare)
 * - Examples include: "Google", "Facebook", "Word of Mouth", "Print Ad", "Radio", "TV", "Yelp", "Instagram"
 * - Standardized list ensures consistent marketing attribution across all locations
 * - System-wide reference data for marketing tracking
 *
 * **Common Use Cases:**
 * - Populate "How did you hear about us?" dropdown fields in customer registration
 * - Track which channels are driving customer acquisition for marketing attribution
 * - Measure effectiveness of different marketing strategies for campaign analysis
 * - Ensure valid referral source selection in customer profiles for form validation
 * - Feed data into marketing analytics and reporting systems for analytics integration
 * - Connect customer acquisition costs to specific marketing channels for ROI tracking
 *
 * **Performance & Limits:**
 * - Lightweight reference data optimized for frequent access
 * - Referral sources change infrequently; safe to cache for extended periods
 * - Small static dataset suitable for client-side caching
 * - Consistent across all organizations and locations
 *
 * **Integration Workflow:**
 * 1. Call this endpoint to get available referral source options
 * 2. Present options in customer registration or profile update forms
 * 3. Include selected value when creating/updating customers (if supported)
 * 4. Use for reporting to analyze customer acquisition patterns
 *
 * **Marketing Benefits:**
 * - Attribution tracking to understand which marketing channels are most effective
 * - Budget allocation optimization based on referral source performance
 * - Campaign ROI measurement for different marketing campaigns
 * - Customer insights to learn how customers discover your dispensary
 *
 * **Related Endpoints:**
 * - `POST /customer` - Create customers with referral source information
 * - `GET /customer/customer-types` - Get customer type reference data
 * - `GET /customer/customers` - Get customers with their referral source data
 *
 * **Important Notes:**
 * - Returns system-wide referral sources for consistent reporting across all locations
 * - Consider adding "Other" or "Prefer not to say" options in your UI implementation
 * - Use these values to populate selection lists in customer forms
 * - Validate referral source values against this list before submitting customer data
 * - Essential for marketing analytics and customer acquisition tracking
 */
export const customerReferralSourcesGet = <ThrowOnError extends boolean = false>(options?: Options<CustomerReferralSourcesGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<CustomerReferralSourcesGetResponses, CustomerReferralSourcesGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/customer/referral-sources',
        ...options
    });
};

/**
 * Create or Update Customer
 * **Purpose:** Create new customer profiles or update existing customer information for dispensary operations and e-commerce integration.
 *
 * **Request Requirements:**
 * - "Customer" role authorization required for customer data operations
 * - `EcomCustomerEdit` object in request body with customer details
 * - Content-Type: application/json
 * - Optional query parameter to bypass deduplication
 * - **Idempotency Support**: Requires `ConsumerKey` header and `IdempotencyKey` field for duplicate prevention (see [Idempotency Documentation](/pages/idempotency.html))
 *
 * **Response Data:**
 * - Returns single `Customer` object (not array) with assigned system ID
 * - Response format: `{ Customer }`
 * - Includes loyalty program enrollment and qualification status
 * - Provides both internal and external system identifiers
 * - Contains full customer profile with contact and address information
 *
 * **Create vs Update Behavior:**
 * - **CREATE**: When `CustomerId` is null, 0, or omitted, a new customer record will be created
 * - **UPDATE**: When `CustomerId` is provided with a valid customer ID, the existing customer will be updated
 * - **Validation**: FirstName, Address1, City, State, PostalCode, Status, and CustomerType are required
 * - **Deduplication**: Create operations include smart duplicate detection unless bypassed with query parameter
 *
 * **Request Body Format:**
 * - For new customers: Leave `CustomerId` null or 0 (will be auto-generated)
 * - For updates: Include the `CustomerId` in the request
 * - FirstName is required (Name will be used as FirstName if FirstName is empty)
 * - Address1, City, State, PostalCode are required for address information
 * - Status and CustomerType are required for customer classification
 *
 * **Optional Fields:**
 * - DateOfBirth (must be between 1800-01-01 and current date)
 * - LastName, MiddleName, NameSuffix, NamePrefix for name information
 * - Address2 for additional address details
 * - Phone, EmailAddress for contact information
 * - EcomUserId for external e-commerce system identifier
 * - UniqueId for external system integration
 *
 * **Sparse Update Behavior:**
 * - **Provided fields**: Will overwrite existing values with provided data
 * - **Omitted fields**: Will preserve existing values (no data loss for updates)
 * - **Special handling**: Name field will be used as FirstName if FirstName is omitted during updates
 * - **Validation**: Required fields for updates are more relaxed than for new customer creation
 *
 * **Smart Deduplication System:**
 * - Default behavior automatically searches for existing customers with matching details
 * - Helps prevent creating multiple records for the same person
 * - Use `bypassDeduplication=true` to force creation of new customer record
 *
 * **Common Use Cases:**
 * - Sync customer profiles from online ordering platforms for e-commerce integration
 * - Create new customer accounts during in-store visits and walk-in registration
 * - Update existing customer contact and address information
 * - Add customers to dispensary loyalty and rewards programs
 * - Maintain customer records for regulatory compliance requirements
 * - Synchronize customer data with external customer relationship management systems
 *
 * **Performance & Limits:**
 * - Rate limited to 1500 requests per minute (higher limit for high-volume customer operations)
 * - Single customer operation for targeted updates
 * - Immediate validation and duplicate detection
 * - Changes are reflected immediately in customer listings
 * - Smart matching algorithms optimize deduplication performance
 *
 * **Related Endpoints:**
 * - `POST /customerLookup` - Find existing customers by various search criteria
 * - `POST /search` - Search customers by name, phone, or email for quick lookup
 * - `GET /by-external-id` - Retrieve customers using external system identifiers
 * - `GET /customers` - List all customers with optional filtering
 *
 * **Important Notes:**
 * - Date of birth must be realistic (between 1800 and current date) for age verification
 * - Smart matching helps prevent multiple records for the same person
 * - Some fields may be required based on location-specific compliance regulations
 * - System validates contact information format and completeness for data quality
 */
export const customerCustomerPost = <ThrowOnError extends boolean = false>(options?: Options<CustomerCustomerPostData, ThrowOnError>) => {
    return (options?.client ?? client).post<CustomerCustomerPostResponses, CustomerCustomerPostErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/customer/customer',
        ...options,
        headers: {
            'Content-Type': 'application/json-patch+json',
            ...options?.headers
        }
    });
};

export const customerCustomerLookupPost = <ThrowOnError extends boolean = false>(options?: Options<CustomerCustomerLookupPostData, ThrowOnError>) => {
    return (options?.client ?? client).post<CustomerCustomerLookupPostResponses, CustomerCustomerLookupPostErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/customer/customerLookup',
        ...options,
        headers: {
            'Content-Type': 'application/json-patch+json',
            ...options?.headers
        }
    });
};

/**
 * Customer Search (PREVIEW)
 * **NOTE - THIS ENDPOINT IS CURRENTLY IN PREVIEW - IT MAY UNDERGO BREAKING CHANGES IN UPCOMING RELEASES**
 *
 *
 * **Purpose:** Search for customers using multiple criteria with flexible matching to support customer identification and lookup workflows.
 *
 * **Request Requirements:**
 * - "Customer" role authorization required for customer data operations
 * - `CustomerSearchRequest` object in request body with search criteria
 * - Content-Type: application/json
 * - At least one search criterion must be provided
 * - Rate limited to 360 requests per minute
 *
 * **Response Data:**
 * - Returns array of `CustomerSearchResult` objects with matching customer information
 * - Response format: `[{ CustomerSearchResult }, ...]`
 * - Array may contain 0 to 100+ customers depending on search criteria specificity
 * - Returns empty array `[]` if no customers match search criteria (not null)
 * - Same customer may appear multiple times with different match types
 * - Includes match type information to identify which criteria matched
 * - Results automatically filtered to authenticated location
 *
 * **Search Criteria (Independent Matching):**
 * - **MMJ ID**: Medical marijuana patient identification number
 * - **Drivers License ID**: State-issued driver's license number
 * - **Email Address**: Customer's email address (exact match)
 * - **Phone Number**: Customer's phone number (normalized matching)
 * - **LastName + DateOfBirth**: Combined name and birth date search (both required together)
 *
 * **Search Behavior:**
 * - **Independent Fields**: Most fields are searched independently
 * - **Combined Fields**: LastName and DateOfBirth must be used together
 * - **Multiple Matches**: Same customer may appear with different match types
 * - **Location Scoped**: Results filtered to authenticated location only
 * - **Case Sensitivity**: Email and name searches are case-insensitive
 *
 * **Common Use Cases:**
 * - Find customers during check-in process for identification verification
 * - Locate existing customer records before creating new accounts
 * - Search for customers using partial or alternative identification methods
 * - Verify customer identity using multiple data points
 * - Support customer service lookup workflows
 *
 * **Performance & Limits:**
 * - Rate limited to 360 requests per minute for system protection
 * - Optimized for common customer lookup patterns
 * - Results limited to reasonable set size for performance
 * - Indexed searches for fast response times
 *
 * **Related Endpoints:**
 * - `POST /customer/customerLookup` - Single customer lookup with hierarchy
 * - `GET /customer/customers` - List all customers with filtering
 * - `POST /customer/customer` - Create or update customer records
 *
 * **Important Notes:**
 * - **PREVIEW STATUS**: This endpoint may undergo breaking changes in future releases
 * - **Multiple Results**: Same customer can appear multiple times with different match types
 * - **Location Filtering**: Results are automatically scoped to your authenticated location
 * - **Rate Limiting**: 360 requests per minute limit applies for system stability
 * - **Validation**: At least one search criterion must be provided in the request
 */
export const customerSearchPost = <ThrowOnError extends boolean = false>(options?: Options<CustomerSearchPostData, ThrowOnError>) => {
    return (options?.client ?? client).post<CustomerSearchPostResponses, CustomerSearchPostErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/customer/search',
        ...options,
        headers: {
            'Content-Type': 'application/json-patch+json',
            ...options?.headers
        }
    });
};

export const customerByExternalIdGet = <ThrowOnError extends boolean = false>(options?: Options<CustomerByExternalIdGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<CustomerByExternalIdGetResponses, CustomerByExternalIdGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/customer/by-external-id',
        ...options
    });
};

/**
 * Get Customer Journal Entries
 * **Purpose:** Retrieves all journal entries (notes/comments) associated with a specific customer for customer service and account management.
 *
 * **Request Requirements:**
 * - "Customer" role authorization required for customer data operations
 * - Customer ID query parameter required
 * - No request body needed
 *
 * **Response Data:**
 * - Returns array of journal entry objects: `[{ JournalEntry }, ...]`
 * - Array may contain 0 to 100+ entries depending on customer interaction history
 * - Returns empty array `[]` if no journal entries exist for customer (not null)
 * - Includes entry ID, subject, body, and date
 * - Results filtered by customer accessibility to authenticated location
 *
 * **Common Use Cases:**
 * - View interaction history and notes about a customer for customer service
 * - Review previous communications and issues for account management
 * - Maintain audit trail of customer interactions for compliance
 * - Track resolution history and follow-ups for support tickets
 *
 * **Performance & Limits:**
 * - Efficient retrieval for individual customer journal histories
 * - Results scoped to specific customer and location
 * - No pagination needed for typical journal entry volumes
 *
 * **Related Endpoints:**
 * - `POST /customer-journal/create` - Create new journal entries
 * - `POST /customer-journal/update` - Update existing journal entries
 *
 * **Important Notes:**
 * - Customer ID must exist and be accessible to your location
 * - Requires customer validation before retrieving entries
 * - Entries are returned in database order (not explicitly sorted)
 */
export const customerJournalGet = <ThrowOnError extends boolean = false>(options?: Options<CustomerJournalGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<CustomerJournalGetResponses, CustomerJournalGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/customer-journal',
        ...options
    });
};

/**
 * Update Customer Journal Entry
 * **Purpose:** Updates an existing journal entry's date, subject, and/or body content for customer service record management.
 *
 * **Request Requirements:**
 * - "Customer" role authorization required for customer data operations
 * - `UpdateJournalEntryRequest` object in request body
 * - Content-Type: application/json
 * - Journal entry must exist and be accessible to your location
 *
 * **Response Data:**
 * - Returns journal entry object: `{ JournalEntry }`
 * - Includes entry ID, updated subject, body, and date
 * - Confirms successful update with complete entry details
 *
 * **Request Body Fields:**
 * - JournalEntryId: The ID of the journal entry to update (required)
 * - Subject: New title or summary for the entry (required)
 * - Body: New detailed content for the entry (required)
 * - Date: New date for the entry (required)
 *
 * **Update Behavior:**
 * - **All fields required**: JournalEntryId, Subject, Body, and Date must all be provided
 * - **Complete replacement**: All entry fields will be updated with provided values
 * - **Validation**: Entry must exist and be accessible to your location
 *
 * **Common Use Cases:**
 * - Fix typos or errors in previously created entries for correction
 * - Add more details to existing notes for additional information
 * - Update resolution status or follow-up information for status updates
 * - Modify entries to meet regulatory requirements for compliance updates
 *
 * **Performance & Limits:**
 * - Single entry update operation for targeted modifications
 * - Immediate validation and response
 * - Changes reflected immediately in journal entry lists
 *
 * **Related Endpoints:**
 * - `GET /customer-journal` - Retrieve journal entries for a customer
 * - `POST /customer-journal/create` - Create new journal entries
 *
 * **Important Notes:**
 * - Journal entry must exist and be accessible to your location
 * - Validation performed before update to ensure data integrity
 * - All request fields are required for successful update
 */
export const customerJournalUpdatePost = <ThrowOnError extends boolean = false>(options?: Options<CustomerJournalUpdatePostData, ThrowOnError>) => {
    return (options?.client ?? client).post<CustomerJournalUpdatePostResponses, CustomerJournalUpdatePostErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/customer-journal/update',
        ...options,
        headers: {
            'Content-Type': 'application/json-patch+json',
            ...options?.headers
        }
    });
};

/**
 * Create Customer Journal Entry
 * **Purpose:** Creates a new journal entry (note/comment) for a specific customer to maintain interaction records and customer service history.
 *
 * **Request Requirements:**
 * - "Customer" role authorization required for customer data operations
 * - `CreateJournalEntryRequest` object in request body
 * - Content-Type: application/json
 * - Customer must exist and be accessible to your location
 *
 * **Response Data:**
 * - Returns journal entry object: `{ JournalEntry }`
 * - Includes assigned entry ID, subject, body, and date
 * - Confirms successful creation with complete entry details
 *
 * **Request Body Fields:**
 * - CustomerId: The customer to create the journal entry for (required)
 * - Subject: Brief title or summary of the entry (required)
 * - Body: Detailed content of the journal entry (required)
 * - Date: When this entry should be dated (required)
 *
 * **Common Use Cases:**
 * - Record interaction details and resolutions for customer service notes
 * - Document changes to customer information for account updates
 * - Log problems and their resolution status for issue tracking
 * - Maintain required interaction records for compliance documentation
 * - Schedule future contact or actions for follow-up reminders
 *
 * **Performance & Limits:**
 * - Single entry creation operation for immediate record keeping
 * - Immediate validation and creation
 * - New entries appear immediately in journal entry lists
 *
 * **Related Endpoints:**
 * - `GET /customer-journal` - Retrieve journal entries for a customer
 * - `POST /customer-journal/update` - Update existing journal entries
 *
 * **Important Notes:**
 * - Customer must exist and be accessible to your location
 * - Validation performed before creation to ensure data integrity
 * - All request fields are required for successful creation
 */
export const customerJournalCreatePost = <ThrowOnError extends boolean = false>(options?: Options<CustomerJournalCreatePostData, ThrowOnError>) => {
    return (options?.client ?? client).post<CustomerJournalCreatePostResponses, CustomerJournalCreatePostErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/customer-journal/create',
        ...options,
        headers: {
            'Content-Type': 'application/json-patch+json',
            ...options?.headers
        }
    });
};

/**
 * Get Deliveries
 * **Purpose:** Retrieve delivery status information and order details for cannabis delivery operations and tracking.
 *
 * **Request Requirements:**
 * - "Deliveries" role authorization required for delivery data access
 * - Optional query parameters for filtering and data inclusion
 * - Rate limited to 100 requests per minute
 * - No request body needed
 *
 * **Response Data:**
 * - Returns array of delivery objects: `[{ DeliveryOrderStatus }, ...]`
 * - Array may contain 0 to 100+ deliveries depending on filtering criteria
 * - Returns empty array `[]` if no deliveries match criteria (not null)
 * - Delivery status, timing, and location information included
 * - Optional line item details when includeLineItems=true
 * - Results automatically filtered to authenticated location
 *
 * **Query Parameters:**
 * - PreOrderId: Get delivery status for a specific pre-order (optional)
 * - TransactionId: Get delivery status for a specific transaction (optional)
 * - transactionIds: Get delivery status for multiple transactions (optional array)
 * - deliveryStatus: Filter by delivery status (optional)
 * - includeLineItems: Include detailed line item data (default: false)
 *
 * **Parameter Rules:**
 * - **Mutually Exclusive**: Use only ONE of PreOrderId, TransactionId, transactionIds, or deliveryStatus
 * - **Default Behavior**: If no parameters provided, returns all open deliveries from last 14 days
 * - **Open Definition**: Status of 'filled' or 'received' within the last 14 days
 * - **Line Items**: Only available for packages assigned to orders, not unassigned pre-order items
 *
 * **Delivery Status Values:**
 * - **Placed**: Order has been placed but not yet processed
 * - **Filled**: Order has been fulfilled and packaged for delivery
 * - **Received**: Order has been received by delivery team
 * - **In Transit**: Order is currently being delivered
 * - **Delivered**: Order has been successfully delivered to customer
 * - **Cancelled**: Order has been cancelled
 *
 * **Common Use Cases:**
 * - Monitor delivery status for customer service and tracking
 * - Generate delivery reports for operational management
 * - Track order fulfillment and delivery performance
 * - Provide delivery updates to customers and delivery teams
 * - Integrate with third-party delivery tracking systems
 *
 * **Performance & Limits:**
 * - Rate limited to 100 requests per minute for system protection
 * - Optimized for delivery tracking and status monitoring
 * - Line item data loading is conditional for performance
 * - Results filtered to location scope for operational relevance
 *
 * **Related Endpoints:**
 * - `POST /deliveries/set-route-detail` - Update delivery route and driver information
 * - `GET /drivers` - Get available drivers for delivery assignments
 * - `GET /preorder` - Get pre-order information that may become deliveries
 *
 * **Important Notes:**
 * - **Exclusive Parameters**: Only use one filtering parameter at a time
 * - **Line Item Limitation**: Line items only shown for assigned packages, not pre-order items
 * - **Time Window**: Default query covers last 14 days of open deliveries
 * - **Rate Limiting**: 100 requests per minute limit for delivery tracking operations
 * - **Status Tracking**: Provides real-time delivery status for customer and operational visibility
 */
export const deliveriesGet = <ThrowOnError extends boolean = false>(options?: Options<DeliveriesGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<DeliveriesGetResponses, DeliveriesGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/Deliveries',
        ...options
    });
};

/**
 * Set Delivery Route Detail
 * **Purpose:** Update delivery route information including vehicle, driver assignments, route details, and delivery status for operational management.
 *
 * **Request Requirements:**
 * - "Deliveries" role authorization required for delivery operations
 * - `UpdateDeliveryRouteDetailRequest` object in request body with route details
 * - Content-Type: application/json
 * - Rate limited to 100 requests per minute
 * - Valid delivery ID must exist and be accessible to your location
 *
 * **Response Data:**
 * - Returns success confirmation (HTTP 200) upon successful update
 * - No response body content (void return)
 * - Route details are validated and stored for delivery operations
 *
 *
 * **Request Body Fields:**
 * - TransactionId: The delivery transaction to update (required)
 * - DriverId: Primary driver assignment for the delivery (optional)
 * - DriverId2: Secondary driver assignment for the delivery (optional)
 * - VehicleId: Vehicle assigned to the delivery (optional)
 * - Route: Route information or notes (optional)
 * - Status: Delivery status update (optional)
 *
 * **Route Detail Updates:**
 * - **Vehicle Assignment**: Set vehicle ID for the delivery
 * - **Driver Assignment**: Assign primary and optional secondary drivers
 * - **Route Information**: Update route notes or details
 * - **Status Updates**: Modify delivery status
 *
 * **Common Use Cases:**
 * - Assign delivery vehicles and drivers to pending orders
 * - Update delivery routes for optimal efficiency and timing
 * - Modify delivery status as orders progress through fulfillment
 * - Reassign deliveries to different drivers or vehicles
 * - Update delivery information for customer tracking and notifications
 *
 * **Performance & Limits:**
 * - Rate limited to 100 requests per minute for system protection
 * - Single delivery operation for targeted route updates
 * - Immediate validation and storage of route information
 * - Changes propagate to delivery tracking systems immediately
 *
 * **Related Endpoints:**
 * - `GET /deliveries` - Retrieve current delivery status and information
 * - `GET /drivers` - Get available drivers for delivery assignments
 * - `GET /preorder` - Access pre-order information for delivery preparation
 *
 * **Important Notes:**
 * - **Driver and Vehicle IDs**: Must reference valid drivers and vehicles in the system
 * - **Validation**: Request fields are validated before processing updates
 * - **Status Tracking**: Updates enable delivery tracking for operations
 * - **Rate Limiting**: 100 requests per minute limit for delivery management operations
 */
export const deliveriesSetRouteDetailPost = <ThrowOnError extends boolean = false>(options?: Options<DeliveriesSetRouteDetailPostData, ThrowOnError>) => {
    return (options?.client ?? client).post<DeliveriesSetRouteDetailPostResponses, DeliveriesSetRouteDetailPostErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/Deliveries/set-route-detail',
        ...options,
        headers: {
            'Content-Type': 'application/json-patch+json',
            ...options?.headers
        }
    });
};

/**
 * Get Discounts (Legacy)
 * **Purpose:** Retrieves basic discount information using the legacy data structure with limited configuration details.
 *
 * **LEGACY WARNING:** This endpoint is deprecated. Migrate to `GET /discounts/v2/list` for complete functionality.
 *
 * **Request Requirements:**
 * - "Inventory" role authorization required for discount data access
 * - Optional query parameters for filtering
 * - No request body needed
 *
 * **Response Data:**
 * - Returns array of `PublishedDiscount` objects with basic discount information
 * - Array typically contains 5-50 discounts per location depending on active promotions
 * - Returns empty array `[]` if no discounts are active or configured
 * - Validity dates are converted from Eastern Time to UTC in response
 * - Automatically excludes "Loyalty Multiplier" discount types
 * - Results are filtered by the authenticated location
 *
 * **Key Limitations vs V2:**
 * - Basic response model with limited discount information
 * - Missing detailed reward and constraint configuration
 * - Does not support advanced discount capabilities
 * - Simple inclusion/exclusion data structure only
 *
 * **Common Use Cases:**
 * - Legacy system integrations that cannot be updated immediately
 * - Basic discount display when minimal information is sufficient
 * - Temporary implementations before V2 migration
 *
 * **Performance & Limits:**
 * - Lightweight response for basic discount listing
 * - Filtered results improve response time
 * - Consider V2 endpoint for comprehensive discount data
 *
 * **Related Endpoints:**
 * - `GET /discounts/v2/list` - Recommended enhanced endpoint with complete configuration
 *
 * **Important Notes:**
 * - This endpoint is deprecated and may be removed in future versions
 * - New integrations should use the V2 endpoint
 * - Date conversion assumes Eastern Time input, converts to UTC output
 */
export const discountsGet = <ThrowOnError extends boolean = false>(options?: Options<DiscountsGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<DiscountsGetResponses, DiscountsGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/discounts',
        ...options
    });
};

/**
 * Get Discounts V2 (Recommended)
 * **Purpose:** Retrieves comprehensive discount information including detailed reward configuration, payment restrictions, and advanced bundling logic.
 *
 * **Request Requirements:**
 * - "Inventory" role authorization required for discount data access
 * - Optional query parameters for enhanced data inclusion
 * - No request body needed
 *
 * **Response Data:**
 * - Returns array of `DiscountApiResponse` objects with complete discount configuration
 * - Array typically contains 5-50 discounts per location depending on active promotions
 * - Returns empty array `[]` if no discounts are active or configured
 * - Validity dates are converted from Eastern Time to UTC in response
 * - Includes detailed reward structure and constraint details
 * - Results are filtered by the authenticated location
 *
 * **Enhanced Features vs Legacy:**
 * - Complete response model with detailed discount configuration
 * - Full discount reward structure and constraint details
 * - Payment method restrictions (credit card, cash, etc.)
 * - Advanced bundle discount logic and stacking configuration
 * - E-commerce menu display configuration and ranking
 * - Optimized data retrieval and processing
 *
 * **Common Use Cases:**
 * - New discount integrations requiring complete configuration data
 * - E-commerce systems needing full discount logic implementation
 * - Point-of-sale systems requiring comprehensive discount rules
 * - Advanced analytics and discount performance analysis
 * - Payment processing systems validating payment method restrictions
 *
 * **Performance & Limits:**
 * - Single request retrieves all discount data efficiently
 * - Optimized processing for large discount configurations
 * - Consider parameter filtering to reduce response size when needed
 *
 * **Related Endpoints:**
 * - `GET /discounts` - Legacy endpoint with basic discount information (deprecated)
 *
 * **Important Notes:**
 * - This is the recommended endpoint for all new integrations
 * - Includes latest discount capabilities and improvements
 * - Date conversion assumes Eastern Time input, converts to UTC output
 */
export const discountsV2ListGet = <ThrowOnError extends boolean = false>(options?: Options<DiscountsV2ListGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<DiscountsV2ListGetResponses, DiscountsV2ListGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/discounts/v2/list',
        ...options
    });
};

/**
 * Get Drivers
 * **Purpose:** Retrieves the complete list of drivers for the authenticated location for delivery operations and transportation management.
 *
 * **Request Requirements:**
 * - "Reporting" or "Deliveries" role authorization required for driver data access
 * - No query parameters or request body needed
 *
 * **Response Data:**
 * - Response format: `[{ DriverDetail }, { DriverDetail }, ...]`
 * - Array typically contains 2-20 drivers per location
 * - Returns empty array `[]` if no drivers configured for location
 * - Includes driver ID, name, state ID, and driver's license number
 * - Location-specific driver roster for delivery and transportation operations
 *
 * **Common Use Cases:**
 * - Populate driver dropdown lists in delivery assignment systems
 * - Support delivery operations and route management workflows
 * - Validate driver assignments in delivery and transportation systems
 * - Access basic driver information for compliance and operational purposes
 *
 * **Performance & Limits:**
 * - Location-specific driver data filtered to authenticated location
 * - No pagination needed for typical location driver counts
 * - Optimized for delivery operations and transportation management
 *
 * **Related Endpoints:**
 * - `POST /drivers` - Create or update driver information
 * - `GET /deliveries` - Get deliveries that may be assigned to these drivers
 * - Delivery and transportation endpoints that utilize driver assignments
 *
 * **Important Notes:**
 * - Drivers are scoped to location level for operational relevance
 * - Requires Reporting or Deliveries role for access to driver information
 * - Essential for delivery operations and transportation compliance
 * - Driver information includes basic licensing information
 * - Used for delivery assignment and route management
 */
export const driversGet = <ThrowOnError extends boolean = false>(options?: Options<DriversGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<DriversGetResponses, DriversGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/drivers',
        ...options
    });
};

/**
 * Create or Update Driver
 * **Purpose:** Creates a new driver or updates existing driver information for delivery operations and transportation management.
 *
 * **Request Requirements:**
 * - "Reporting" or "Deliveries" role authorization required for driver data operations
 * - `DriverDetail` object in request body with driver information
 * - Content-Type: application/json
 * - Driver data must pass validation requirements
 *
 * **Response Data:**
 * - Response format: `200 OK` (no response body)
 * - Returns success confirmation upon successful creation or update
 * - Driver information is validated and stored for operational use
 * - Updates reflected immediately in driver listings and assignments
 *
 * **Request Body Fields:**
 * - DriverId: Driver identifier for updates (0 for new drivers)
 * - Name: Driver's full name (required)
 * - StateId: State identifier for licensing (optional)
 * - DriversLicense: Driver's license number (required)
 *
 * **Create vs Update Behavior:**
 * - **CREATE**: When DriverId is 0 or omitted, creates a new driver record
 * - **UPDATE**: When DriverId is provided with valid driver ID, updates existing driver
 * - **Validation**: All provided data must pass driver validation requirements
 *
 * **Common Use Cases:**
 * - Add new drivers to the delivery team for expanding operations
 * - Update existing driver information when licenses or details change
 * - Maintain accurate driver records for compliance and operational purposes
 * - Support driver onboarding and management workflows
 *
 * **Performance & Limits:**
 * - Single driver operation for targeted updates
 * - Immediate validation and storage
 * - Changes reflected immediately in driver listings
 * - Location-scoped driver management for operational relevance
 *
 * **Related Endpoints:**
 * - `GET /drivers` - Retrieve current driver information
 * - `GET /deliveries` - Get deliveries that may be assigned to drivers
 * - Delivery management endpoints that utilize driver assignments
 *
 * **Important Notes:**
 * - Driver information must pass validation before storage
 * - Drivers are scoped to location level for operational management
 * - Essential for delivery operations and transportation compliance
 * - Basic licensing information required for compliance
 * - Changes immediately available for delivery assignment and scheduling
 */
export const driversPost = <ThrowOnError extends boolean = false>(options?: Options<DriversPostData, ThrowOnError>) => {
    return (options?.client ?? client).post<DriversPostResponses, DriversPostErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/drivers',
        ...options,
        headers: {
            'Content-Type': 'application/json-patch+json',
            ...options?.headers
        }
    });
};

/**
 * Get Employees
 * **Purpose:** Retrieves the complete list of employees for the authenticated organization for staff management and operational workflows.
 *
 * **Request Requirements:**
 * - "Employee" role authorization required for employee data access
 * - No query parameters or request body needed
 * - Rate limited to 300 requests per minute
 *
 * **Response Data:**
 * - Returns array of employee objects: `[{ Employee }, ...]`
 * - Array typically contains 5-100 employees per organization
 * - Returns empty array `[]` if no employees configured (rare)
 * - Includes employee ID, name, location assignments, and permission details
 * - Organization-level employee directory filtered to authenticated organization
 * - Staff information for operational and management purposes
 *
 * **Common Use Cases:**
 * - Populate employee dropdown lists in scheduling and assignment systems
 * - Support staff management and operational workflow assignments
 * - Generate employee directories and contact lists for internal use
 * - Validate employee assignments in transaction and operational systems
 * - Enable staff-based reporting and analytics for management
 * - Support payroll and HR integration systems
 *
 * **Performance & Limits:**
 * - Rate limited to 300 requests per minute for optimal performance
 * - Organization-level employee data filtered to authenticated organization
 * - No pagination needed for typical organization employee counts
 * - Optimized for internal operational and management use cases
 *
 * **Related Endpoints:**
 * - Transaction endpoints that may reference employee assignments
 * - Operational endpoints that utilize employee information
 * - Reporting endpoints that include employee-based analytics
 *
 * **Important Notes:**
 * - Employees are scoped to organization level (LSP) for data security
 * - Requires Employee role authorization for access to sensitive staff information
 * - Rate limiting enforced to protect employee data and system performance
 * - Essential for staff management and operational workflow support
 * - Employee information may be used for transaction tracking and audit trails
 * - Supports internal operational systems and management workflows
 */
export const employeesGet = <ThrowOnError extends boolean = false>(options?: Options<EmployeesGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<EmployeesGetResponses, EmployeesGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/employees',
        ...options
    });
};

/**
 * Guest List (Active Check-ins)
 * **Purpose:** Retrieves a real-time list of customers currently checked into the dispensary location for queue management and customer service.
 *
 * **Request Requirements:**
 * - "Customer" role authorization required for guest management functions
 * - No query parameters or request body needed
 *
 * **Response Data:**
 * - Returns array of guest objects: `[{ GuestListEntry }, ...]`
 * - Array typically contains 0-50 active guests depending on current business volume
 * - Returns empty array `[]` if no customers are currently checked in
 * - Customer details including name, customer ID, customer type, and contact information
 * - Check-in status with current status and check-in timestamp in UTC
 * - Transaction data with associated transaction ID and reference number
 * - Terminal information showing POS terminal name where check-in occurred
 * - Pre-order source indicating origin of the order (online, walk-in, etc.)
 * - Returns only guests checked into the authenticated location
 *
 * **Data Filtering:**
 * - Real-time data showing only currently active check-ins
 * - Guests who have completed their visit and checked out will not appear
 * - Automatically excludes guests in hidden rooms (administrative areas)
 * - Automatically excludes guests in on-hold rooms (temporary holding areas)
 * - Results filtered to show only the most recent check-in per customer
 *
 * **Common Use Cases:**
 * - Monitor current guest queue and wait times for queue management
 * - Display active customers for budtender assignment on staff dashboards
 * - Maintain records of dispensary occupancy for compliance tracking
 * - Identify guests and their order status for customer service
 * - Track check-in patterns and peak hours for analytics
 *
 * **Performance & Limits:**
 * - Data optimized for real-time display applications
 * - Consider implementing appropriate polling intervals for your use case
 * - Live data reflects current check-in status immediately
 * - Efficient filtering for large guest lists
 *
 * **Related Endpoints:**
 * - `POST /transaction/create-anonymous` - Create anonymous customer check-ins
 *
 * **Important Notes:**
 * - All timestamps are returned in UTC format for consistent processing across time zones
 * - Only shows currently active check-ins; completed visits are excluded
 * - Location-specific data filtered to authenticated dispensary location
 * - Requires customer role authorization for access to guest management functions
 */
export const guestlistGet = <ThrowOnError extends boolean = false>(options?: Options<GuestlistGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<GuestlistGetResponses, GuestlistGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/guestlist',
        ...options
    });
};

/**
 * Get Harvests
 * **Purpose:** Retrieve harvest records for cannabis cultivation operations including tracking, compliance, and operational management.
 *
 * **Request Requirements:**
 * - Either "Inventory" or "Cultivation" role required for harvest data access
 * - Optional query parameters for filtering and date range selection
 * - No request body needed
 *
 * **Response Data:**
 * - Returns array of `Harvest` objects with comprehensive harvest information
 * - Array may contain 0 to 1,000+ harvests depending on cultivation scale and filtering
 * - Returns empty array `[]` if no harvests match criteria (not null)
 * - Results ordered by last modified date (most recent first)
 * - Harvest details include timing, quantities, strain information, and compliance data
 * - Results automatically filtered to authenticated location
 *
 * **Filtering Options:**
 * - fromLastModifiedDateUTC: Returns harvests modified after this date for incremental sync
 * - toLastModifiedDateUTC: Returns harvests modified before this date for date range filtering
 * - activeHarvests: Filter by harvest status (true=active, false=completed, null=completed only)
 *
 * **Harvest Status Definitions:**
 * - **Active Harvests**: Currently in progress, not yet completed or processed
 * - **Completed Harvests**: Finished harvest operations, ready for processing or completed
 * - **Default Behavior**: Returns completed harvests only when activeHarvests parameter is null
 *
 * **Common Use Cases:**
 * - Monitor harvest progress and completion status for cultivation management
 * - Generate harvest reports for compliance and regulatory reporting
 * - Track harvest yields and timing for operational optimization
 * - Synchronize harvest data with cultivation management systems
 * - Support inventory management and product traceability requirements
 *
 * **Performance & Limits:**
 * - Optimized for cultivation tracking and harvest management workflows
 * - Date range filtering recommended for large cultivation operations
 * - Results sorted by modification date for chronological tracking
 * - Location-scoped results for operational relevance and security
 *
 * **Related Endpoints:**
 * - `POST /harvest` - Create or update individual harvest records
 * - `POST /harvest/bulk` - Create or update multiple harvests efficiently
 * - `GET /inventory` - View products created from harvest operations
 * - Plant and cultivation tracking endpoints for complete workflow
 *
 * **Important Notes:**
 * - **Default Filter**: Returns completed harvests only unless activeHarvests parameter is specified
 * - **Date Filtering**: Use date parameters for incremental sync and performance optimization
 * - **Compliance Tracking**: Harvest records support cannabis regulatory compliance requirements
 * - **Cultivation Integration**: Links with plant tracking and inventory management systems
 * - **Yield Tracking**: Provides harvest quantity and quality data for operational analytics
 */
export const harvestGet = <ThrowOnError extends boolean = false>(options?: Options<HarvestGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<HarvestGetResponses, HarvestGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/harvest',
        ...options
    });
};

/**
 * Create or Update Harvest
 * **Purpose:** Create a new harvest record or update an existing harvest with comprehensive cultivation data for compliance tracking and operational management.
 *
 * **Request Requirements:**
 * - "CultivationWrite" role authorization required for harvest data operations
 * - `CreateOrUpdateHarvest` object in request body with harvest details
 * - Content-Type: application/json
 * - Plant and strain information must be valid and accessible to your location
 *
 * **Response Data:**
 * - Returns single integer harvest ID (not array) for the created or updated harvest
 * - New harvests receive newly assigned harvest ID
 * - Updated harvests return the existing harvest ID
 * - ID can be used for subsequent harvest operations and tracking
 *
 * **Create vs Update Behavior:**
 * - **CREATE**: When HarvestId is null or omitted, a new harvest record will be created
 * - **UPDATE**: When HarvestId is provided with a valid harvest ID, the existing harvest will be updated
 * - **Validation**: Plant and strain data must be valid for both create and update operations
 * - **Compliance**: All harvest data must meet cannabis regulatory requirements
 *
 * **Request Body Fields:**
 * - HarvestId: ID for updates (null for new harvests)
 * - Plant identification and tracking information
 * - Harvest timing and scheduling details
 * - Yield quantities and measurement data
 * - Strain and genetic information
 * - Compliance and regulatory tracking data
 *
 * **Sparse Update Behavior:**
 * - **Provided fields**: Will overwrite existing values with provided data
 * - **Omitted fields**: Will preserve existing values (no data loss for updates)
 * - **Special handling**: Plant and strain associations require valid references
 * - **Validation**: All provided data must meet cultivation and compliance standards
 *
 * **Common Use Cases:**
 * - Record new harvest operations as plants are processed
 * - Update harvest records with final yield and quality data
 * - Maintain compliance with cannabis cultivation tracking requirements
 * - Track harvest timing and efficiency for operational optimization
 * - Link harvests to plant tracking and inventory management systems
 *
 * **Performance & Limits:**
 * - Single harvest operation for targeted tracking
 * - Immediate validation and compliance checking
 * - Changes reflected immediately in harvest listings and reporting
 * - Optimized for cultivation workflow integration
 *
 * **Related Endpoints:**
 * - `GET /harvest` - Retrieve harvest records for review and tracking
 * - `POST /harvest/bulk` - Create or update multiple harvests efficiently
 * - Plant tracking endpoints for complete cultivation workflow
 * - `GET /inventory` - View products created from harvest operations
 *
 * **Important Notes:**
 * - **Compliance Critical**: Harvest records are required for cannabis regulatory compliance
 * - **Plant Tracking**: Must link to valid plant records for traceability
 * - **Yield Accuracy**: Accurate yield data is essential for inventory and compliance
 * - **Timing Tracking**: Harvest dates and timing support compliance reporting
 * - **Bulk Alternative**: Use POST /harvest/bulk for multiple harvest operations
 */
export const harvestPost = <ThrowOnError extends boolean = false>(options?: Options<HarvestPostData, ThrowOnError>) => {
    return (options?.client ?? client).post<HarvestPostResponses, HarvestPostErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/harvest',
        ...options,
        headers: {
            'Content-Type': 'application/json-patch+json',
            ...options?.headers
        }
    });
};

/**
 * Bulk Create or Update Harvests
 * **Purpose:** Create or update multiple harvest records in a single operation for efficient cultivation data management and compliance tracking.
 *
 * **Request Requirements:**
 * - "CultivationWrite" role authorization required for harvest data operations
 * - `BulkCreateOrUpdateHarvest` object in request body with array of harvest details
 * - Content-Type: application/json
 * - All plant and strain information must be valid and accessible to your location
 * - Request validation performed before any operations are executed
 *
 * **Response Data:**
 * - Returns single `BulkCreateOrUpdateHarvestResponse` object (not array) with operation results
 * - CreatedHarvestIds: Array of newly created harvest IDs
 * - UpdatedHarvestIds: Array of updated harvest IDs
 * - Success message confirming completion of operations
 * - All operations are atomic - either all succeed or all fail
 *
 * **Create vs Update Behavior:**
 * - **CREATE**: When HarvestId is null or omitted in harvest objects, new harvest records will be created
 * - **UPDATE**: When HarvestId is provided with valid harvest IDs, existing harvests will be updated
 * - **Mixed Operations**: Single request can include both create and update operations
 * - **Validation**: All harvest data must pass validation before any operations are executed
 * - **Atomic Processing**: All operations succeed together or all operations fail together
 *
 * **Request Body Structure:**
 * - Harvests: Array of CreateOrUpdateHarvest objects
 * - Each harvest object contains the same fields as individual harvest operations
 * - Plant identification, timing, yield, strain, and compliance data for each harvest
 * - Mixed create (HarvestId=null) and update (HarvestId=provided) operations supported
 *
 * **Bulk Processing Benefits:**
 * - **Efficiency**: Process multiple harvests in single API call
 * - **Performance**: Optimized database operations for large cultivation operations
 * - **Consistency**: Atomic operations ensure data integrity
 * - **Compliance**: Batch compliance checking and validation
 * - **Convenience**: Simplifies integration for cultivation management systems
 *
 * **Common Use Cases:**
 * - Process multiple harvest operations from cultivation management systems
 * - Synchronize harvest data between external systems and LeafLogix
 * - Update multiple harvest records with final yield and quality data
 * - Import harvest data from spreadsheets or external cultivation tracking
 * - Maintain compliance with cannabis cultivation tracking requirements
 *
 * **Performance & Limits:**
 * - Optimized for bulk cultivation data processing
 * - Atomic transaction processing ensures data consistency
 * - All validation performed before any operations are executed
 * - Efficient for large-scale cultivation operations
 * - Changes reflected immediately in harvest listings and reporting
 *
 * **Related Endpoints:**
 * - `GET /harvest` - Retrieve harvest records for review and tracking
 * - `POST /harvest` - Create or update individual harvest records
 * - Plant tracking endpoints for complete cultivation workflow
 * - `GET /inventory` - View products created from harvest operations
 *
 * **Important Notes:**
 * - **Atomic Operations**: All harvests in the request succeed or fail together
 * - **Validation Required**: Complete validation performed before any processing
 * - **Compliance Critical**: All harvest records must meet cannabis regulatory requirements
 * - **Plant Tracking**: All harvests must link to valid plant records for traceability
 * - **Efficiency**: Preferred method for multiple harvest operations
 */
export const harvestBulkPost = <ThrowOnError extends boolean = false>(options?: Options<HarvestBulkPostData, ThrowOnError>) => {
    return (options?.client ?? client).post<HarvestBulkPostResponses, HarvestBulkPostErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/harvest/bulk',
        ...options,
        headers: {
            'Content-Type': 'application/json-patch+json',
            ...options?.headers
        }
    });
};

/**
 * Health Check Endpoint
 * **Purpose:** Provides a simple health check endpoint to verify the API service is running and responsive.
 *
 * **Request Requirements:**
 * - No authentication or API key required for infrastructure access
 * - AllowAnonymous endpoint for monitoring systems
 * - No query parameters or request body needed
 *
 * **Response Data:**
 * - Returns health status object: `{ SuccessResult }`
 * - HTTP 200 status when the service is healthy
 * - Lightweight JSON response for fast monitoring
 *
 * **Common Use Cases:**
 * - Load balancer health checks to route traffic only to healthy instances
 * - External monitoring services (Pingdom, DataDog) for uptime alerting
 * - Infrastructure monitoring by DevOps teams for service availability
 * - Service verification before making other API calls
 * - Automated health monitoring in deployment pipelines
 *
 * **Performance & Limits:**
 * - Designed to respond quickly with minimal system requirements
 * - No rate limiting applied to health checks
 * - Minimal dependencies to ensure reliable health indication
 * - Optimized for frequent polling by monitoring systems
 *
 * **Related Endpoints:**
 * - No related endpoints - this is a standalone health check
 *
 * **Important Notes:**
 * - This endpoint bypasses normal authentication for infrastructure access
 * - Designed for automated monitoring and load balancer health checks
 * - Simple response format optimized for parsing by monitoring tools
 * - Available on both `/health-check` and `/okcomputer` routes
 */
export const okcomputerGet = <ThrowOnError extends boolean = false>(options?: Options<OkcomputerGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<OkcomputerGetResponses, OkcomputerGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/okcomputer',
        ...options
    });
};

/**
 * Get Inventory Integration Reconciliation
 * **Purpose:** Retrieve inventory reconciliation data between LeafLogix and external state tracking systems for compliance and integration monitoring.
 *
 * **Request Requirements:**
 * - "Integrations" role authorization required for integration data access
 * - No query parameters or request body needed
 * - Integration management permissions for system reconciliation
 *
 * **Response Data:**
 * - Returns single `InventoryIntegrationReconResponse` object (not array) with reconciliation results
 * - Includes inventory discrepancies and integration status information
 * - State system synchronization details and compliance tracking data
 * - Integration health and data consistency information
 *
 * **Reconciliation Information Included:**
 * - **Inventory Discrepancies**: Items with differences between systems
 * - **Integration Status**: Current state of external system synchronization
 * - **Compliance Data**: Regulatory tracking and audit trail information
 * - **Sync Health**: Integration system connectivity and data flow status
 *
 * **Common Use Cases:**
 * - Monitor inventory synchronization between LeafLogix and state tracking systems
 * - Identify and resolve inventory discrepancies for compliance
 * - Support compliance audits and regulatory reporting requirements
 * - Troubleshoot integration issues and data synchronization problems
 * - Maintain accurate inventory records across integrated systems
 *
 * **Performance & Limits:**
 * - Real-time reconciliation data for immediate integration monitoring
 * - Comprehensive reconciliation across integrated state tracking systems
 * - Optimized for compliance monitoring and integration management workflows
 * - Results include comprehensive integration status and discrepancy details
 *
 * **Related Endpoints:**
 * - `GET /inventory` - View current inventory status for comparison
 * - `GET /plant` - Check plant inventory integration status
 * - `GET /harvest` - Monitor harvest integration synchronization
 *
 * **Important Notes:**
 * - **Compliance Critical**: Essential for regulatory compliance and audit requirements
 * - **Integration Monitoring**: Real-time visibility into external system synchronization
 * - **Complete Data Access**: Provides comprehensive reconciliation across all integrated systems
 * - **State System Integration**: Specific to external state tracking system connectivity
 * - **Audit Ready**: Data formatted for compliance reporting and audit requirements
 */
export const integrationIntegrationReconGet = <ThrowOnError extends boolean = false>(options?: Options<IntegrationIntegrationReconGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<IntegrationIntegrationReconGetResponses, IntegrationIntegrationReconGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/integration/integration-recon',
        ...options
    });
};

/**
 * Get Inventory
 * **Purpose:** Retrieve current inventory levels and product details for API-enabled products with available stock.
 *
 * **Request Requirements:**
 * - "Inventory" role authorization required for inventory data access
 * - Optional query parameters for enhanced data inclusion
 * - No request body needed
 *
 * **Response Data:**
 * - Returns array of `InventoryItem` objects with current stock and product information
 * - Response format: `[{ InventoryItem }, { InventoryItem }, ...]`
 * - Array may contain 0 to 5,000+ inventory items depending on location inventory size
 * - Returns empty array `[]` if no inventory items have stock or meet criteria
 * - Stock levels including available quantities, unit weights, flower equivalent amounts
 * - Product details with SKU, name, description, category, brand, pricing (retail/medical)
 * - Package data including package ID, batch name, package status, expiration dates
 * - Lab results with potency testing, cannabinoid profiles, test dates (when includeLabResults=true)
 * - Room breakdown showing quantities by storage location (when includeRoomQuantities=true)
 * - Compliance data including external package IDs (METRC/BioTrack), strain information, producer details
 *
 * **Filtering Options:**
 * - includeLabResults: Include detailed lab testing data and cannabinoid profiles (default: false)
 * - includeRoomQuantities: Include quantity breakdown by storage room/location (default: false)
 *
 * **Common Use Cases:**
 * - Update online store inventory levels and product availability for e-commerce sync
 * - Perform real-time stock checks during sales transactions for POS integration
 * - Monitor stock levels across multiple storage locations for inventory management
 * - Track package-level inventory for regulatory compliance reporting
 * - Show potency and testing information to customers for lab data display
 *
 * **Performance & Limits:**
 * - Response times optimized for high-volume integrations
 * - Use minimal parameters for fastest response times
 * - Standard rate limits apply for high-volume integrations
 * - Data reflects current system state with real-time accuracy
 *
 * **Related Endpoints:**
 * - `GET /products` - Complete product catalog regardless of stock levels (use for menu/catalog display)
 *
 * **Important Notes:**
 * - Only products enabled for API access are returned for access control
 * - Products with zero inventory are automatically excluded
 * - Results automatically filtered to authenticated user's location only
 * - Inventory data reflects current stock levels with real-time accuracy
 */
export const inventoryGet = <ThrowOnError extends boolean = false>(options?: Options<InventoryGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<InventoryGetResponses, InventoryGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/inventory',
        ...options
    });
};

export const inventoryLabresultsGet = <ThrowOnError extends boolean = false>(options?: Options<InventoryLabresultsGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<InventoryLabresultsGetResponses, InventoryLabresultsGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/inventory/labresults',
        ...options
    });
};

export const inventorySnapshotGet = <ThrowOnError extends boolean = false>(options?: Options<InventorySnapshotGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<InventorySnapshotGetResponses, InventorySnapshotGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/inventory/snapshot',
        ...options
    });
};

export const inventoryReceivedinventoryGet = <ThrowOnError extends boolean = false>(options?: Options<InventoryReceivedinventoryGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<InventoryReceivedinventoryGetResponses, InventoryReceivedinventoryGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/inventory/receivedinventory',
        ...options
    });
};

export const inventoryInventorytransactionGet = <ThrowOnError extends boolean = false>(options?: Options<InventoryInventorytransactionGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<InventoryInventorytransactionGetResponses, InventoryInventorytransactionGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/inventory/inventorytransaction',
        ...options
    });
};

/**
 * Create Receive Inventory Order
 * **Purpose:** Create a new inventory receive order for incoming transfers, purchase orders, or direct inventory additions.
 *
 * **Request Requirements:**
 * - "Inventory" role authorization required for inventory operations
 * - `ReceiveInventorySave` object in request body with vendor and item details
 * - Content-Type: application/json
 * - UserId or UserName required when ReceiveIntoInventory=true
 *
 * **Response Data:**
 * - Response format: `{ SavedReceive }`
 * - Returns transaction ID and processing status information
 *
 * **Processing Options:**
 * - **Draft Mode (ReceiveIntoInventory=false):** Creates a saved receive order that can be opened/edited in LeafLogix
 * - **Direct Processing (ReceiveIntoInventory=true):** Immediately processes items into inventory (requires UserId or UserName)
 *
 * **Required Information:**
 * - **Items Array:** Product details, quantities, costs, room assignments, batch information
 * - **Vendor Information:** VendorId, delivery details, licensing information
 * - **User Context:** UserId or UserName (required when ReceiveIntoInventory=true)
 *
 * **Item Details Required:**
 * - **Product Identification:** ProductId or SKU, product name
 * - **Quantities:** Receive quantity, unit of measure
 * - **Costs:** Unit cost, total cost (for cost tracking)
 * - **Storage:** Room assignment, expiration dates
 * - **Compliance:** Package tags, batch names, lab testing status
 *
 * **Common Use Cases:**
 * - **Transfer Processing:** Receive inventory from other licensed locations
 * - **Purchase Orders:** Process incoming vendor deliveries
 * - **Direct Additions:** Add inventory directly to stock levels
 * - **Compliance Tracking:** Maintain chain of custody for regulatory reporting
 * - **Batch Processing:** Handle multiple items in a single receive transaction
 *
 * **Validation Features:**
 * - **Vendor Verification:** Validates vendor exists and is active
 * - **Room Validation:** Confirms room assignments are valid for location
 * - **Potency Indicators:** Validates required compliance fields
 * - **Duplicate Prevention:** ExternalId checking prevents duplicate receives
 * - **User Authorization:** Verifies user permissions for inventory operations
 *
 * **Important Notes:**
 * - **User Requirement:** UserId or UserName required when ReceiveIntoInventory=true (cannot specify both)
 * - **External ID Uniqueness:** ExternalId must be unique or omitted to prevent duplicates
 * - **Vendor License Support:** Supports vendor license code mapping for compliance requirements
 * - **Location Scoped:** All operations scoped to authenticated user's location
 * - **Enhanced Validation:** Additional validation rules may apply based on location settings
 *
 * **Request Format:**
 * Provide a `ReceiveInventorySave` object containing vendor details, delivery information, and an array of items to receive.
 */
export const inventoryReceiveinventoryPost = <ThrowOnError extends boolean = false>(options?: Options<InventoryReceiveinventoryPostData, ThrowOnError>) => {
    return (options?.client ?? client).post<InventoryReceiveinventoryPostResponses, InventoryReceiveinventoryPostErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/inventory/receiveinventory',
        ...options,
        headers: {
            'Content-Type': 'application/json-patch+json',
            ...options?.headers
        }
    });
};

/**
 * Get Lineages
 * **Purpose:** Retrieves the complete list of genetic lineages available for the authenticated organization for product classification and cannabis genetic tracking.
 *
 * **Request Requirements:**
 * - Any authenticated role authorization (no specific role required)
 * - No query parameters or request body needed
 *
 * **Response Data:**
 * - Returns array of lineage objects: `[{ Lineage }, ...]`
 * - Array typically contains 10-50 genetic lineages per organization
 * - Returns empty array `[]` if no lineages configured (rare)
 * - Includes lineage ID, name, and genetic classification details
 * - Cannabis genetic lineages and hereditary information for product categorization
 * - Results filtered to authenticated organization level
 *
 * **Common Use Cases:**
 * - Track genetic lineage and hereditary information for cannabis products
 * - Support compliance reporting with genetic background documentation
 * - Populate lineage dropdown lists in product creation and strain management forms
 * - Validate genetic lineage assignments in product and cultivation systems
 * - Generate lineage-specific reports for cultivation and breeding programs
 * - Enable genetic tracking for quality control and consistency
 *
 * **Performance & Limits:**
 * - Lightweight reference data optimized for frequent access
 * - Small dataset suitable for client-side caching
 * - No pagination needed due to manageable number of genetic lineages
 * - Results consistent across all locations within organization
 *
 * **Related Endpoints:**
 * - `GET /strains` - Get strains that may be associated with these lineages
 * - `GET /products` - Get products with lineage genetic information
 * - Cultivation and breeding endpoints that utilize genetic lineage data
 *
 * **Important Notes:**
 * - Lineages are defined at organization level (LSP) for consistency
 * - Essential for cannabis genetic tracking and breeding program documentation
 * - Used for compliance reporting and genetic background verification
 * - Supports cultivation operations with genetic lineage documentation
 * - May be required for certain cannabis regulations and track-and-trace systems
 * - Helps maintain genetic consistency and quality control in cultivation
 */
export const lineagesGet = <ThrowOnError extends boolean = false>(options?: Options<LineagesGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<LineagesGetResponses, LineagesGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/lineages',
        ...options
    });
};

/**
 * Set Package Tags
 * **Purpose:** Set inventory tags for packages, completely replacing any existing tags with the new tag set for organization and tracking.
 *
 * **Request Requirements:**
 * - "PackageWrite" role authorization required for package tag operations
 * - `UpdatePackageTagsRequest` object in request body with package identifiers and tags
 * - Content-Type: application/json
 * - Must specify either InventoryIds OR PackageIds, but not both
 * - All specified packages must be accessible to your location
 *
 * **Response Data:**
 * - Returns success confirmation (HTTP 200) upon successful tag assignment
 * - No response body content (void return)
 * - Tags are validated and applied immediately to specified packages
 * - Changes are reflected immediately in inventory listings and package data
 *
 * **Package Identification Options:**
 * - **InventoryIds**: Target specific inventory records directly (one-to-one relationship)
 * - **PackageIds**: Target packages by serial numbers (may affect multiple inventory records)
 * - **Mutually Exclusive**: Specify either InventoryIds OR PackageIds, never both
 * - **Validation**: Using both types will result in 400 Bad Request error
 *
 * **Tag Operation Behavior:**
 * - **Complete Replacement**: All existing tags are removed and replaced with new tags
 * - **Tag Validation**: All tags must be valid and available in the system
 * - **Immediate Effect**: Changes apply immediately to all specified packages
 * - **Bulk Operation**: Can target multiple packages in a single request
 *
 * **Request Body Fields:**
 * - InventoryIds: Array of inventory record IDs (optional, mutually exclusive with PackageIds)
 * - PackageIds: Array of package serial numbers (optional, mutually exclusive with InventoryIds)
 * - Tags: Array of tag names to apply to the specified packages (required)
 *
 * **Common Use Cases:**
 * - Standardize tag sets across multiple packages for consistency
 * - Replace outdated or incorrect tags with current classification
 * - Implement new tagging schema by completely updating existing tags
 * - Clean up tag sets by removing unwanted tags and setting only desired ones
 * - Maintain organized inventory classification for operational efficiency
 *
 * **Performance & Limits:**
 * - Bulk operation optimized for multiple package updates
 * - Immediate validation and tag assignment
 * - Changes propagate to inventory systems immediately
 * - Efficient for large-scale tag management operations
 *
 * **Related Endpoints:**
 * - `POST /package/add-tags` - Add tags while preserving existing tags
 * - `POST /package/remove-tags` - Remove specific tags while preserving others
 * - `GET /tags` - Retrieve available tag options for validation
 * - `GET /inventory` - View packages with their current tag assignments
 *
 * **Important Notes:**
 * - **Complete Replacement**: This operation removes ALL existing tags and replaces them
 * - **Tag Validation**: All tags must exist in the system and be valid
 * - **Package Access**: All specified packages must be accessible to your authenticated location
 * - **Mutual Exclusion**: Cannot use both InventoryIds and PackageIds in the same request
 * - **Alternative Operations**: Use add-tags or remove-tags for partial tag modifications
 */
export const packageSetTagsPost = <ThrowOnError extends boolean = false>(options?: Options<PackageSetTagsPostData, ThrowOnError>) => {
    return (options?.client ?? client).post<PackageSetTagsPostResponses, PackageSetTagsPostErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/package/set-tags',
        ...options,
        headers: {
            'Content-Type': 'application/json-patch+json',
            ...options?.headers
        }
    });
};

/**
 * Add Package Tags
 * **Purpose:** Add new inventory tags to packages while preserving all existing tags for enhanced organization and classification.
 *
 * **Request Requirements:**
 * - "PackageWrite" role authorization required for package tag operations
 * - `UpdatePackageTagsRequest` object in request body with package identifiers and tags
 * - Content-Type: application/json
 * - Must specify either InventoryIds OR PackageIds, but not both
 * - All specified packages must be accessible to your location
 *
 * **Response Data:**
 * - Returns success confirmation (HTTP 200) upon successful tag addition
 * - No response body content (void return)
 * - New tags are validated and added immediately to specified packages
 * - Changes are reflected immediately in inventory listings and package data
 *
 * **Package Identification Options:**
 * - **InventoryIds**: Target specific inventory records directly (one-to-one relationship)
 * - **PackageIds**: Target packages by serial numbers (may affect multiple inventory records)
 * - **Mutually Exclusive**: Specify either InventoryIds OR PackageIds, never both
 * - **Validation**: Using both types will result in 400 Bad Request error
 *
 * **Tag Operation Behavior:**
 * - **Additive Operation**: New tags are added while preserving all existing tags
 * - **Duplicate Handling**: Duplicate tags are automatically ignored (no error)
 * - **Tag Validation**: All new tags must be valid and available in the system
 * - **Immediate Effect**: Changes apply immediately to all specified packages
 * - **Bulk Operation**: Can target multiple packages in a single request
 *
 * **Request Body Fields:**
 * - InventoryIds: Array of inventory record IDs (optional, mutually exclusive with PackageIds)
 * - PackageIds: Array of package serial numbers (optional, mutually exclusive with InventoryIds)
 * - Tags: Array of tag names to add to the specified packages (required)
 *
 * **Common Use Cases:**
 * - Add seasonal or promotional tags to existing products without losing current classification
 * - Enhance product categorization by adding supplementary organizational tags
 * - Apply new quality control or testing tags while maintaining existing product tags
 * - Add compliance or regulatory tags for audit trails without disrupting inventory organization
 * - Implement progressive tagging workflows where tags are added over time
 *
 * **Performance & Limits:**
 * - Bulk operation optimized for multiple package updates
 * - Immediate validation and tag addition
 * - Changes propagate to inventory systems immediately
 * - Efficient for incremental tag management operations
 *
 * **Related Endpoints:**
 * - `POST /package/set-tags` - Replace all existing tags with new tag set
 * - `POST /package/remove-tags` - Remove specific tags while preserving others
 * - `GET /tags` - Retrieve available tag options for validation
 * - `GET /inventory` - View packages with their current tag assignments
 *
 * **Important Notes:**
 * - **Preserves Existing**: This operation keeps ALL existing tags and adds new ones
 * - **Duplicate Safe**: Adding tags that already exist will not cause errors
 * - **Tag Validation**: All new tags must exist in the system and be valid
 * - **Package Access**: All specified packages must be accessible to your authenticated location
 * - **Mutual Exclusion**: Cannot use both InventoryIds and PackageIds in the same request
 */
export const packageAddTagsPost = <ThrowOnError extends boolean = false>(options?: Options<PackageAddTagsPostData, ThrowOnError>) => {
    return (options?.client ?? client).post<PackageAddTagsPostResponses, PackageAddTagsPostErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/package/add-tags',
        ...options,
        headers: {
            'Content-Type': 'application/json-patch+json',
            ...options?.headers
        }
    });
};

/**
 * Remove Package Tags
 * **Purpose:** Remove specific inventory tags from packages while preserving all other existing tags for selective tag management.
 *
 * **Request Requirements:**
 * - "PackageWrite" role authorization required for package tag operations
 * - `UpdatePackageTagsRequest` object in request body with package identifiers and tags to remove
 * - Content-Type: application/json
 * - Must specify either InventoryIds OR PackageIds, but not both
 * - All specified packages must be accessible to your location
 *
 * **Response Data:**
 * - Returns success confirmation (HTTP 200) upon successful tag removal
 * - No response body content (void return)
 * - Specified tags are removed immediately from specified packages
 * - Changes are reflected immediately in inventory listings and package data
 *
 * **Package Identification Options:**
 * - **InventoryIds**: Target specific inventory records directly (one-to-one relationship)
 * - **PackageIds**: Target packages by serial numbers (may affect multiple inventory records)
 * - **Mutually Exclusive**: Specify either InventoryIds OR PackageIds, never both
 * - **Validation**: Using both types will result in 400 Bad Request error
 *
 * **Tag Operation Behavior:**
 * - **Selective Removal**: Only specified tags are removed, all others are preserved
 * - **Missing Tag Handling**: Removing tags that don't exist is silently ignored (no error)
 * - **Immediate Effect**: Changes apply immediately to all specified packages
 * - **Bulk Operation**: Can target multiple packages in a single request
 * - **Preservation**: All non-specified tags remain unchanged
 *
 * **Request Body Fields:**
 * - InventoryIds: Array of inventory record IDs (optional, mutually exclusive with PackageIds)
 * - PackageIds: Array of package serial numbers (optional, mutually exclusive with InventoryIds)
 * - Tags: Array of tag names to remove from the specified packages (required)
 *
 * **Common Use Cases:**
 * - Remove outdated seasonal or promotional tags while keeping product classification
 * - Clean up temporary testing or quality control tags after completion
 * - Remove incorrect or duplicate tags while preserving accurate classification
 * - Implement tag lifecycle management by removing obsolete organizational tags
 * - Support compliance workflows by removing temporary audit or review tags
 *
 * **Performance & Limits:**
 * - Bulk operation optimized for multiple package updates
 * - Immediate tag removal processing
 * - Changes propagate to inventory systems immediately
 * - Efficient for selective tag cleanup operations
 *
 * **Related Endpoints:**
 * - `POST /package/set-tags` - Replace all existing tags with new tag set
 * - `POST /package/add-tags` - Add new tags while preserving existing tags
 * - `GET /tags` - Retrieve available tag options for validation
 * - `GET /inventory` - View packages with their current tag assignments
 *
 * **Important Notes:**
 * - **Preserves Others**: This operation keeps ALL non-specified tags unchanged
 * - **Missing Tag Safe**: Removing tags that don't exist will not cause errors
 * - **Package Access**: All specified packages must be accessible to your authenticated location
 * - **Mutual Exclusion**: Cannot use both InventoryIds and PackageIds in the same request
 * - **Selective Operation**: Use for precise tag management without affecting other classification
 */
export const packageRemoveTagsPost = <ThrowOnError extends boolean = false>(options?: Options<PackageRemoveTagsPostData, ThrowOnError>) => {
    return (options?.client ?? client).post<PackageRemoveTagsPostResponses, PackageRemoveTagsPostErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/package/remove-tags',
        ...options,
        headers: {
            'Content-Type': 'application/json-patch+json',
            ...options?.headers
        }
    });
};

/**
 * Get Plants
 * **Purpose:** Retrieve cannabis plant records for cultivation tracking, compliance monitoring, and operational management.
 *
 * **Request Requirements:**
 * - "Inventory" or "Cultivation" role authorization required for plant data access
 * - Optional query parameters for filtering by plant attributes and date ranges
 * - No request body needed
 *
 * **Response Data:**
 * - Response format: `[{ Plant }, { Plant }, ...]`
 * - Returns array of `Plant` objects with comprehensive plant information
 * - Array may contain 0 to 10,000+ plants depending on cultivation scale and filtering
 * - Returns empty array `[]` if no plants match criteria (not null)
 * - Plant details include identification, growth status, cultivation tracking, and compliance data
 * - Results automatically filtered to authenticated location
 *
 * **Filtering Options:**
 * - plantId: Filter by specific LeafLogix internal plant ID for individual plant lookup
 * - serialNumber: Filter by plant serial number for tracking system integration
 * - status: Filter by plant status (Active, Harvesting, Harvested, Retired)
 * - lastModifiedDateStart: Returns plants modified after this date for incremental sync
 * - lastModifiedDateEnd: Returns plants modified before this date for date range filtering
 *
 * **Plant Status Definitions:**
 * - **Active**: Plants currently growing and under cultivation
 * - **Harvesting**: Plants currently being harvested or in harvest process
 * - **Harvested**: Plants that have completed harvest operations
 * - **Retired**: Plants that have been retired from cultivation (destroyed, failed, etc.)
 *
 * **Common Use Cases:**
 * - Monitor plant growth progress and cultivation status for operational management
 * - Generate compliance reports for regulatory tracking and auditing
 * - Synchronize plant data with cultivation management and tracking systems
 * - Track plant lifecycle from cultivation through harvest completion
 * - Support inventory management and product traceability requirements
 *
 * **Performance & Limits:**
 * - Optimized for cultivation tracking and plant management workflows
 * - Date range filtering recommended for large cultivation operations
 * - Plant status filtering efficient for operational dashboards
 * - Location-scoped results for operational relevance and security
 *
 * **Related Endpoints:**
 * - `POST /plant/harvest` - Move plants into harvest status
 * - `POST /harvest` - Create harvest records for harvested plants
 * - `GET /inventory` - View products created from harvested plants
 * - Plant lifecycle and cultivation management endpoints
 *
 * **Important Notes:**
 * - **Compliance Tracking**: Plant records support cannabis regulatory compliance requirements
 * - **Lifecycle Management**: Tracks complete plant lifecycle from cultivation to harvest
 * - **Date Filtering**: Use date parameters for incremental sync and performance optimization
 * - **Status Filtering**: Essential for operational workflows and cultivation management
 * - **Traceability**: Links with harvest and inventory systems for complete product tracking
 */
export const plantGet = <ThrowOnError extends boolean = false>(options?: Options<PlantGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<PlantGetResponses, PlantGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/plant',
        ...options
    });
};

/**
 * Add Plant
 * **Purpose:** Create a new cannabis plant record in the cultivation system with unique identification and tracking for compliance monitoring and operational management.
 *
 * **Request Requirements:**
 * - "Inventory" or "Cultivation" role authorization required for plant creation operations
 * - `CreatePlantRequest` object in request body with plant identification and group details
 * - Content-Type: application/json
 * - Serial number must be unique within the facility
 * - Plant group must exist or strain must be provided for new group creation
 *
 * **Response Data:**
 * - Response format: `int` (Plant ID)
 * - Returns the newly created plant's unique LeafLogix plant ID
 * - Plant ID can be used in subsequent plant management operations
 * - Immediate plant creation with tracking system integration
 *
 * **Request Body Fields:**
 * - `PlantGroupName`: Name of plant group for batch tracking (required)
 * - `SerialNumber`: Unique plant identifier for compliance tracking (required, must be unique)
 * - `Strain`: Strain name for new plant groups (required when creating new plant group)
 * - `Room`: Cultivation room name for plant location (required when using state integrations)
 * - `BypassStateIntegration`: Skip external system integration (optional, default: false)
 * - `DateCreated`: Plant creation date (optional, defaults to current UTC time)
 * - `PhaseStartDate`: Initial growth phase start date (optional, defaults to current UTC time)
 *
 * **Plant Group Behavior:**
 * - **Existing Groups**: If plant group exists, strain information is inherited
 * - **New Groups**: If plant group doesn't exist, strain must be provided for group creation
 * - **Batch Tracking**: Plant groups enable batch-based cultivation tracking and compliance
 * - **Strain Assignment**: All plants in a group share the same strain genetics
 *
 * **Validation Rules:**
 * - **Serial Number**: Must be unique across the facility for compliance tracking
 * - **Plant Group**: Required for batch organization and cultivation management
 * - **Strain Requirement**: Must provide strain when creating new plant groups
 * - **Room Validation**: Room name must exist and be accessible when using integrations
 * - **State Integration**: Room required unless bypassing external system integration
 *
 * **Common Use Cases:**
 * - Register new clones or seedlings entering the cultivation facility
 * - Create plant records for compliance tracking and regulatory reporting
 * - Initialize plant tracking for cultivation workflow management
 * - Support batch-based cultivation and harvest planning
 * - Integrate with external cultivation and compliance systems
 *
 * **Performance & Limits:**
 * - Single plant creation for precise record management
 * - Immediate validation and unique identifier assignment
 * - Optional integration with external cultivation systems
 * - Efficient for individual plant registration workflows
 *
 * **Related Endpoints:**
 * - `GET /plant` - Retrieve created plant information and status
 * - `POST /plant/assign-plants-to-group` - Assign existing plants to groups
 * - `POST /plant/move` - Move plants between cultivation rooms
 * - Plant lifecycle management endpoints for complete workflow
 *
 * **Important Notes:**
 * - **Unique Tracking**: Serial numbers must be unique for compliance and tracking
 * - **Compliance Critical**: Plant registration is required for cannabis regulatory compliance
 * - **Group Management**: Plant groups support batch-based cultivation workflows
 * - **Integration**: External system integration supports cultivation management platforms
 * - **Immediate Processing**: Plant creation is immediate with tracking system updates
 */
export const plantPost = <ThrowOnError extends boolean = false>(options?: Options<PlantPostData, ThrowOnError>) => {
    return (options?.client ?? client).post<PlantPostResponses, PlantPostErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/plant',
        ...options,
        headers: {
            'Content-Type': 'application/json-patch+json',
            ...options?.headers
        }
    });
};

/**
 * Harvest Plants
 * **Purpose:** Move plants from cultivation into harvest status with optional weight tracking for cannabis cultivation compliance and operational management.
 *
 * **Request Requirements:**
 * - "CultivationWrite" role authorization required for plant harvest operations
 * - `HarvestPlantRequest` object in request body with plant identifiers and harvest details
 * - Content-Type: application/json
 * - Rate limited to 300 requests per minute
 * - All specified plants must be accessible to your location and in valid status for harvesting
 *
 * **Response Data:**
 * - Response format: No response body (void)
 * - Returns success confirmation (HTTP 200) upon successful harvest initiation
 * - No response body content (void return)
 * - Plants are moved to harvesting status immediately
 * - Changes are reflected immediately in plant listings and cultivation tracking
 *
 * **Request Body Fields:**
 * - Plant identifiers for the plants to be harvested
 * - Optional wet weight measurements for harvest tracking
 * - Harvest timing and operational details
 * - Compliance and tracking information required for regulatory reporting
 *
 * **Harvest Operation Behavior:**
 * - **Status Change**: Plants are moved from Active to Harvesting status
 * - **Weight Tracking**: Optional wet weight can be recorded for yield tracking
 * - **Bulk Processing**: Multiple plants can be harvested in a single operation
 * - **Compliance**: All operations logged for regulatory compliance requirements
 * - **Immediate Effect**: Status changes apply immediately to all specified plants
 *
 * **Common Use Cases:**
 * - Initiate harvest operations for mature cannabis plants ready for processing
 * - Record harvest timing and initial weight measurements for yield tracking
 * - Maintain compliance with cannabis cultivation and harvest regulations
 * - Support cultivation workflow transitions from growing to processing phases
 * - Track harvest operations for operational efficiency and planning
 *
 * **Performance & Limits:**
 * - Rate limited to 300 requests per minute for cultivation workflow protection
 * - Bulk operation optimized for multiple plant processing
 * - Immediate status updates and tracking system integration
 * - Efficient for large-scale cultivation harvest operations
 *
 * **Related Endpoints:**
 * - `GET /plant` - Retrieve plant records and current status
 * - `POST /harvest` - Create harvest records for tracking and compliance
 * - `GET /harvest` - Monitor harvest progress and completion status
 * - Cultivation and inventory management endpoints for complete workflow
 *
 * **Important Notes:**
 * - **Status Requirements**: Plants must be in Active status to be harvested
 * - **Compliance Critical**: Harvest operations are required for cannabis regulatory compliance
 * - **Weight Tracking**: Wet weight measurements support yield tracking and compliance
 * - **Rate Limiting**: 300 requests per minute limit for cultivation workflow stability
 * - **Immediate Processing**: Status changes are immediate and irreversible through this endpoint
 */
export const plantHarvestPost = <ThrowOnError extends boolean = false>(options?: Options<PlantHarvestPostData, ThrowOnError>) => {
    return (options?.client ?? client).post<PlantHarvestPostResponses, PlantHarvestPostErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/plant/harvest',
        ...options,
        headers: {
            'Content-Type': 'application/json-patch+json',
            ...options?.headers
        }
    });
};

/**
 * Move Plants
 * **Purpose:** Move cannabis plants to a different room or cultivation area within the same facility for cultivation workflow management and compliance tracking.
 *
 * **Request Requirements:**
 * - "CultivationWrite" role authorization required for plant movement operations
 * - `MovePlantRequest` object in request body with plant IDs and target room information
 * - Content-Type: application/json
 * - All specified plants must be accessible to your location and in moveable status
 * - Target room must be within the same facility (location)
 *
 * **Response Data:**
 * - Response format: No response body (void)
 * - Returns success confirmation (HTTP 200) upon successful plant movement
 * - No response body content (void return)
 * - Plants are moved to new room immediately
 * - Changes are reflected immediately in plant location tracking
 *
 * **Request Body Fields:**
 * - `PlantIds`: Array of LeafLogix plant IDs to move (required)
 * - `RoomId`: Target room ID within the same facility (required)
 * - `TableId`: Optional table assignment within the target room
 *
 * **Movement Operation Behavior:**
 * - **Location Validation**: Target room must belong to the same facility
 * - **Bulk Processing**: Multiple plants can be moved in a single operation
 * - **Stage Updates**: If target room has cultivation stage, plants automatically update to that stage
 * - **Compliance**: All movement operations logged for regulatory compliance requirements
 * - **Integration**: Movement synchronized with external cultivation systems when configured
 *
 * **Common Use Cases:**
 * - Move plants between cultivation rooms as they progress through growth stages
 * - Relocate plants for environmental optimization and cultivation management
 * - Transfer plants to harvest preparation areas when ready for processing
 * - Support cultivation workflow automation and plant lifecycle management
 * - Maintain compliance with cannabis cultivation and tracking regulations
 *
 * **Performance & Limits:**
 * - Bulk operation optimized for multiple plant processing
 * - Immediate location updates and tracking system integration
 * - Efficient for large-scale cultivation facility operations
 * - Location validation prevents cross-facility security violations
 *
 * **Related Endpoints:**
 * - `GET /plant` - Retrieve current plant locations and status
 * - `POST /plant/change-phase` - Update growth phases when moving between rooms
 * - `GET /room` - List available rooms for plant movement planning
 * - Cultivation management endpoints for complete workflow
 *
 * **Important Notes:**
 * - **Facility Restriction**: Plants cannot be moved to rooms in different facilities
 * - **Compliance Critical**: Plant movements are required for cannabis regulatory compliance
 * - **Stage Automation**: Room-specific cultivation stages applied automatically when configured
 * - **Immediate Processing**: Location changes are immediate and tracked for audit purposes
 * - **Integration**: Movement synchronized with external cultivation and compliance systems
 */
export const plantMovePost = <ThrowOnError extends boolean = false>(options?: Options<PlantMovePostData, ThrowOnError>) => {
    return (options?.client ?? client).post<PlantMovePostResponses, PlantMovePostErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/plant/move',
        ...options,
        headers: {
            'Content-Type': 'application/json-patch+json',
            ...options?.headers
        }
    });
};

/**
 * Change Plants Growth Phase
 * **Purpose:** Update the cultivation growth phase of cannabis plants to track their development stage and optimize cultivation management.
 *
 * **Request Requirements:**
 * - "CultivationWrite" role authorization required for plant growth phase operations
 * - `ChangeGrowthPhaseRequest` object in request body with plant IDs and growth phase information
 * - Content-Type: application/json
 * - All specified plants must be accessible to your location and in valid status for phase changes
 * - Growth phase must be one of the valid phase values
 *
 * **Response Data:**
 * - Response format: No response body (void)
 * - Returns success confirmation (HTTP 200) upon successful phase change
 * - No response body content (void return)
 * - Plants are updated to new growth phase immediately
 * - Changes are reflected immediately in plant cultivation tracking
 *
 * **Request Body Fields:**
 * - `PlantIds`: Array of LeafLogix plant IDs to update (required)
 * - `GrowthPhase`: Target cultivation phase - must be one of: `Vegetative`, `Propagation`, `Flowering` (required)
 * - `PhaseStartDate`: Date when new phase begins - defaults to current UTC time if omitted (optional)
 *
 * **Growth Phase Values:**
 * - **Propagation**: Initial plant development and cloning phase
 * - **Vegetative**: Active vegetative growth before flowering initiation
 * - **Flowering**: Reproductive growth phase leading to harvest
 *
 * **Phase Change Operation Behavior:**
 * - **Phase Validation**: Growth phase value validated against allowed phases
 * - **Bulk Processing**: Multiple plants can be updated in a single operation
 * - **Date Management**: Phase start date defaults to current time if not specified
 * - **Compliance**: All phase changes logged for regulatory compliance requirements
 * - **Integration**: Phase updates synchronized with external cultivation systems when configured
 *
 * **Common Use Cases:**
 * - Transition plants from vegetative to flowering phase for harvest timing
 * - Update plant phases during cultivation workflow automation
 * - Maintain accurate cultivation records for compliance reporting
 * - Support cultivation planning and scheduling optimization
 * - Synchronize growth phases with environmental control systems
 *
 * **Performance & Limits:**
 * - Bulk operation optimized for multiple plant processing
 * - Immediate phase updates and tracking system integration
 * - Efficient for large-scale cultivation facility operations
 * - Phase validation prevents invalid cultivation state transitions
 *
 * **Related Endpoints:**
 * - `GET /plant` - Retrieve current plant phases and cultivation status
 * - `POST /plant/move` - Move plants between rooms optimized for different phases
 * - `POST /plant/harvest` - Harvest plants when flowering phase is complete
 * - Cultivation management endpoints for complete workflow
 *
 * **Important Notes:**
 * - **Phase Validation**: Only `Vegetative`, `Propagation`, and `Flowering` phases are accepted
 * - **Compliance Critical**: Phase tracking is required for cannabis regulatory compliance
 * - **Date Tracking**: Phase start dates support cultivation timeline management
 * - **Immediate Processing**: Phase changes are immediate and tracked for audit purposes
 * - **Integration**: Phase updates synchronized with external cultivation and compliance systems
 */
export const plantChangePhasePost = <ThrowOnError extends boolean = false>(options?: Options<PlantChangePhasePostData, ThrowOnError>) => {
    return (options?.client ?? client).post<PlantChangePhasePostResponses, PlantChangePhasePostErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/plant/change-phase',
        ...options,
        headers: {
            'Content-Type': 'application/json-patch+json',
            ...options?.headers
        }
    });
};

/**
 * Retire Plants
 * **Purpose:** Permanently retire cannabis plants from cultivation due to various reasons such as disease, damage, or end-of-life for compliance tracking and waste management.
 *
 * **Request Requirements:**
 * - "CultivationWrite" role authorization required for plant retirement operations
 * - `RetirePlantRequest` object in request body with plant IDs and retirement details
 * - Content-Type: application/json
 * - Rate limited to 300 requests per minute
 * - All specified plants must be accessible to your location and in retirable status
 * - Either `ReasonId` or `ReasonCode` must be provided for retirement justification
 *
 * **Response Data:**
 * - Response format: No response body (void)
 * - Returns success confirmation (HTTP 200) upon successful plant retirement
 * - No response body content (void return)
 * - Plants are permanently retired from cultivation immediately
 * - Changes are reflected immediately in plant status and compliance tracking
 *
 * **Request Body Fields:**
 * - `PlantIds`: Array of LeafLogix plant IDs to retire (required)
 * - `ReasonId`: Numeric reason ID for retirement - use if known (optional if ReasonCode provided)
 * - `ReasonCode`: String reason code for retirement - use if ReasonId unknown (optional if ReasonId provided)
 * - `RoomId`: Room where retirement occurs for waste tracking (required)
 * - `WasteType`: Type of waste generated from retirement (optional)
 * - `WasteWeight`: Weight of waste material in specified units (optional)
 * - `PlantWeight`: Weight of plant material being retired (optional)
 * - `WasteDate`: Date of waste generation for compliance tracking (optional)
 * - Additional waste tracking and compliance fields
 *
 * **Reason Code Management:**
 * - **ReasonId Priority**: If both ReasonId and ReasonCode provided, ReasonId takes precedence
 * - **Code Lookup**: ReasonCode automatically looked up to find corresponding ReasonId
 * - **Validation**: Invalid ReasonId or ReasonCode will result in 400 Bad Request response
 * - **Flexibility**: Use ReasonCode when integrating without pre-knowledge of reason IDs
 *
 * **Retirement Operation Behavior:**
 * - **Permanent Action**: Plant retirement is irreversible once completed
 * - **Bulk Processing**: Multiple plants can be retired in a single operation
 * - **Waste Tracking**: Optional waste weight and material tracking for compliance
 * - **Compliance**: All retirement operations logged for regulatory compliance requirements
 * - **Integration**: Retirement synchronized with external cultivation and waste tracking systems
 *
 * **Common Use Cases:**
 * - Retire diseased or damaged plants to prevent contamination spread
 * - Remove plants that have reached end-of-life or failed quality standards
 * - Comply with regulatory requirements for plant destruction documentation
 * - Manage cultivation space by removing non-productive plants
 * - Support waste tracking and disposal compliance reporting
 *
 * **Performance & Limits:**
 * - Rate limited to 300 requests per minute for cultivation workflow protection
 * - Bulk operation optimized for multiple plant processing
 * - Immediate retirement status updates and tracking system integration
 * - Efficient for large-scale cultivation facility operations
 *
 * **Related Endpoints:**
 * - `GET /plant` - Retrieve current plant status before retirement
 * - `GET /plant/get-reason-codes` - List available retirement reason codes
 * - `POST /waste` - Create waste records for retired plant material
 * - Cultivation and compliance management endpoints
 *
 * **Important Notes:**
 * - **Irreversible Action**: Plant retirement cannot be undone once completed
 * - **Reason Required**: Either ReasonId or ReasonCode must be provided for compliance
 * - **Compliance Critical**: Retirement tracking is required for cannabis regulatory compliance
 * - **Rate Limiting**: 300 requests per minute limit for cultivation workflow stability
 * - **Waste Integration**: Retirement can generate waste records for disposal tracking
 */
export const plantRetirePost = <ThrowOnError extends boolean = false>(options?: Options<PlantRetirePostData, ThrowOnError>) => {
    return (options?.client ?? client).post<PlantRetirePostResponses, PlantRetirePostErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/plant/retire',
        ...options,
        headers: {
            'Content-Type': 'application/json-patch+json',
            ...options?.headers
        }
    });
};

/**
 * Get Plant Reason Codes
 * **Purpose:** Retrieve the list of valid reason codes for cannabis plant retirement operations to support compliance documentation and proper retirement categorization.
 *
 * **Request Requirements:**
 * - "Inventory" or "Cultivation" role authorization required for plant data access
 * - No query parameters or request body needed
 *
 * **Response Data:**
 * - Response format: `[string, string, ...]`
 * - Returns array of string reason codes for plant retirement
 * - Array typically contains 5-20 reason codes depending on organization configuration
 * - Returns empty array `[]` if no reason codes configured (rare)
 * - Reason codes are organization-specific and configurable by administrators
 * - Results automatically filtered to authenticated organization
 *
 * **Common Reason Code Examples:**
 * - Disease or pest infestation requiring plant destruction
 * - Physical damage or environmental stress failures
 * - Quality control failures or contamination issues
 * - End-of-life or harvest completion scenarios
 * - Regulatory compliance or audit requirements
 *
 * **Common Use Cases:**
 * - Populate reason code dropdown lists in plant retirement forms
 * - Validate reason codes before submitting plant retirement requests
 * - Generate compliance reports showing retirement reasons and frequencies
 * - Support cultivation management workflows with proper retirement categorization
 * - Maintain audit trails for regulatory compliance and operational analysis
 *
 * **Performance & Limits:**
 * - Lightweight reference data optimized for frequent access
 * - Small dataset suitable for client-side caching
 * - No pagination needed due to manageable reason code catalog sizes
 * - Results filtered to organization-specific reason configurations
 *
 * **Related Endpoints:**
 * - `POST /plant/retire` - Retire plants using these reason codes for compliance
 * - `GET /plant` - Retrieve plant status before determining retirement reasons
 * - Plant lifecycle and cultivation management endpoints
 *
 * **Important Notes:**
 * - **Organization-Specific**: Reason codes vary by organization and compliance requirements
 * - **Compliance Required**: Proper reason codes are essential for cannabis regulatory compliance
 * - **Validation**: Use these codes to validate retirement requests before submission
 * - **Reference Data**: Cache locally for performance in plant retirement workflows
 * - **Administrative**: Reason codes are configured by system administrators
 */
export const plantGetReasonCodesGet = <ThrowOnError extends boolean = false>(options?: Options<PlantGetReasonCodesGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<PlantGetReasonCodesGetResponses, PlantGetReasonCodesGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/plant/get-reason-codes',
        ...options
    });
};

/**
 * Assign Plants to Group
 * **Purpose:** Assign existing cannabis plants to a specific plant group for batch management and cultivation workflow organization using plant serial numbers.
 *
 * **Request Requirements:**
 * - "Inventory" or "Cultivation" role authorization required for plant group management operations
 * - `AssignPlantsToGroupRequest` object in request body with group name and plant serial numbers
 * - Content-Type: application/json
 * - All specified plant serial numbers must exist and be accessible to your location
 * - Target plant group must exist within the facility
 *
 * **Response Data:**
 * - Response format: No response body (void)
 * - Returns success confirmation (HTTP 200) upon successful plant assignment
 * - No response body content (void return)
 * - Plants are assigned to target group immediately
 * - Changes are reflected immediately in plant group organization and batch tracking
 *
 * **Request Body Fields:**
 * - `PlantGroupName`: Name of target plant group for batch organization (required)
 * - `PlantSerialNumbers`: Array of plant serial numbers to assign to the group (required)
 *
 * **Plant Group Assignment Behavior:**
 * - **Batch Organization**: Plants assigned to groups for batch-based cultivation tracking
 * - **Serial Number Lookup**: Plants identified by serial numbers for precise assignment
 * - **Group Validation**: Target plant group must exist before assignment
 * - **Bulk Processing**: Multiple plants can be assigned to the same group in a single operation
 * - **Immediate Processing**: Group assignments are immediate and tracked for compliance
 *
 * **Validation Rules:**
 * - **Plant Existence**: All serial numbers must correspond to existing plants
 * - **Location Access**: Plants must be accessible to the authenticated location
 * - **Group Existence**: Target plant group must exist within the facility
 * - **Serial Number Format**: Serial numbers must match existing plant tracking identifiers
 *
 * **Common Use Cases:**
 * - Reorganize plants into batch groups for cultivation workflow management
 * - Assign newly created plants to existing cultivation batches
 * - Support batch-based harvest planning and cultivation scheduling
 * - Maintain proper plant group organization for compliance reporting
 * - Facilitate cultivation management and operational efficiency
 *
 * **Performance & Limits:**
 * - Bulk operation optimized for multiple plant assignment
 * - Immediate group assignment and tracking system integration
 * - Efficient for cultivation workflow organization and batch management
 * - Serial number validation ensures accurate plant identification
 *
 * **Related Endpoints:**
 * - `GET /plant` - Retrieve current plant group assignments and status
 * - `POST /plant` - Create new plants that can be assigned to groups
 * - Plant group and cultivation management endpoints for complete workflow
 *
 * **Important Notes:**
 * - **Batch Management**: Plant groups enable batch-based cultivation tracking and compliance
 * - **Serial Number Precision**: Use exact serial numbers for accurate plant identification
 * - **Compliance Support**: Proper group organization supports regulatory compliance requirements
 * - **Immediate Processing**: Group assignments are immediate and tracked for audit purposes
 * - **Workflow Integration**: Supports cultivation management and harvest planning workflows
 */
export const plantAssignPlantsToGroupPost = <ThrowOnError extends boolean = false>(options?: Options<PlantAssignPlantsToGroupPostData, ThrowOnError>) => {
    return (options?.client ?? client).post<PlantAssignPlantsToGroupPostResponses, PlantAssignPlantsToGroupPostErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/plant/assign-plants-to-group',
        ...options,
        headers: {
            'Content-Type': 'application/json-patch+json',
            ...options?.headers
        }
    });
};

/**
 * Update Existing Plants (Non-State Tracking)
 * **Purpose:** Update existing plant records with cultivation data without reporting to state traceability systems for internal plant management.
 *
 * **Request Requirements:**
 * - "Inventory" or "Cultivation" role authorization required for plant data modification
 * - `UpdatePlantsRequest` object in request body with plant update details
 * - Content-Type: application/json
 * - Valid PlantId required for each plant to be updated
 * - Feature flag "rollout.trym-integration" must be enabled
 *
 * **Response Data:**
 * - Returns single `SuccessResult` object (not array) with operation confirmation
 * - Includes success message confirming plants were updated
 * - Operation status and any relevant update information
 *
 * **Sparse Update Behavior:**
 * - **Null/Empty/Omitted Fields**: Will NOT have their data updated (preserves existing values)
 * - **Provided Fields**: Only fields with values in the request will be updated
 * - **Field Independence**: Each field can be updated independently without affecting others
 * - **Safe Updates**: Omitted fields maintain their current database values
 *
 * **Non-State Tracking (NONSTS) Behavior:**
 * - **Internal Only**: Updates are for internal cultivation tracking only
 * - **No External Reporting**: Changes are NOT reported to state traceability systems
 * - **Cultivation Focus**: Designed for internal plant management and cultivation workflows
 * - **Compliance Safe**: Does not interfere with official state tracking requirements
 *
 * **Common Use Cases:**
 * - Update internal plant cultivation notes and observations
 * - Modify plant growth stage information for internal tracking
 * - Update plant location within cultivation facility
 * - Record internal plant health and development data
 * - Maintain cultivation workflow information without state system updates
 *
 * **Performance & Limits:**
 * - Batch plant updates for efficient cultivation management
 * - Validation performed before any changes to ensure data integrity
 * - Changes reflected immediately in internal cultivation systems
 * - Optimized for cultivation facility management workflows
 *
 * **Related Endpoints:**
 * - `GET /plant` - Retrieve current plant data before updates
 * - `POST /plant/nonsts` - Create new plants for internal tracking
 * - `POST /plant/harvest` - Official plant harvest operations (state tracked)
 *
 * **Important Notes:**
 * - **Feature Gated**: Requires "rollout.trym-integration" feature flag to be enabled
 * - **Internal Tracking**: Updates are for internal cultivation management only
 * - **State Compliance**: Does not affect official state traceability system records
 * - **Validation Required**: Plant IDs must exist and be valid for the location
 * - **Cultivation Focus**: Designed specifically for cultivation facility workflows
 */
export const plantNonstsUpdatePost = <ThrowOnError extends boolean = false>(options?: Options<PlantNonstsUpdatePostData, ThrowOnError>) => {
    return (options?.client ?? client).post<PlantNonstsUpdatePostResponses, PlantNonstsUpdatePostErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/plant/nonsts/update',
        ...options,
        headers: {
            'Content-Type': 'application/json-patch+json',
            ...options?.headers
        }
    });
};

/**
 * Create Immature Plant Batch (Non-State Tracking)
 * **Purpose:** Create a batch of immature plants for internal cultivation tracking without reporting to state traceability systems.
 *
 * **Request Requirements:**
 * - "Inventory" or "Cultivation" role authorization required for plant creation
 * - `PostImmatureBatchRequest` object in request body with batch details
 * - Content-Type: application/json
 * - Valid plant data for each immature plant in the batch
 * - Feature flag "rollout.trym-integration" must be enabled
 *
 * **Response Data:**
 * - Returns single `ApiResult<CreateImmatureBatchResponse>` object (not array) with creation results
 * - Includes array of created plant IDs for tracking and reference
 * - Batch creation status and success confirmation
 * - Plant ID assignments for newly created immature plants
 *
 * **Batch Creation Process:**
 * - **Multiple Plants**: Creates multiple immature plants in a single operation
 * - **ID Assignment**: Each plant receives a unique PlantId for future operations
 * - **Validation**: All plant data validated before batch creation
 * - **Atomic Operation**: Batch succeeds or fails as a complete unit
 *
 * **Non-State Tracking (NONSTS) Behavior:**
 * - **Internal Only**: Plant creation for internal cultivation tracking only
 * - **No External Reporting**: Plant creation NOT transmitted to state traceability systems
 * - **Cultivation Focus**: Designed for internal plant management and cultivation workflows
 * - **Compliance Safe**: Does not interfere with official state tracking requirements
 *
 * **Immature Plant Characteristics:**
 * - **Growth Stage**: Plants in early vegetative or seedling stage
 * - **Tracking Ready**: Created with unique identifiers for cultivation tracking
 * - **Development Phase**: Pre-flowering plants requiring cultivation management
 * - **Internal Records**: Maintained in internal cultivation systems only
 *
 * **Common Use Cases:**
 * - Create batches of seedlings for internal cultivation tracking
 * - Initialize plant records for new cultivation cycles
 * - Set up immature plant inventory for facility management
 * - Start cultivation workflows without state system integration
 * - Manage internal plant genetics and breeding programs
 *
 * **Performance & Limits:**
 * - Batch processing for efficient plant creation workflows
 * - Validation performed before any plant creation
 * - Changes reflected immediately in internal cultivation systems
 * - Optimized for cultivation facility startup and expansion workflows
 *
 * **Related Endpoints:**
 * - `POST /plant/nonsts/update` - Update created plants with cultivation data
 * - `GET /plant` - Retrieve created plant information
 * - `POST /plant/harvest` - Official plant harvest operations (state tracked)
 *
 * **Important Notes:**
 * - **Feature Gated**: Requires "rollout.trym-integration" feature flag to be enabled
 * - **Plant IDs Returned**: Save returned plant IDs for future plant management operations
 * - **Internal Tracking**: Plants created for internal cultivation management only
 * - **State Compliance**: Does not affect official state traceability system records
 * - **Batch Efficiency**: Creates multiple plants efficiently in single operation
 */
export const plantNonstsBatchImmatureplantsPost = <ThrowOnError extends boolean = false>(options?: Options<PlantNonstsBatchImmatureplantsPostData, ThrowOnError>) => {
    return (options?.client ?? client).post<PlantNonstsBatchImmatureplantsPostResponses, PlantNonstsBatchImmatureplantsPostErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/plant/nonsts/batch/immatureplants',
        ...options,
        headers: {
            'Content-Type': 'application/json-patch+json',
            ...options?.headers
        }
    });
};

/**
 * Convert Immature Plant Batch to Mature (Non-State Tracking)
 * **Purpose:** Convert immature plant batches to mature plant status for internal cultivation tracking without reporting to state traceability systems.
 *
 * **Request Requirements:**
 * - "Inventory" or "Cultivation" role authorization required for plant conversion
 * - `ConvertImmatureBatchRequest` object in request body with conversion details
 * - Content-Type: application/json
 * - Valid immature batch data for conversion to mature plants
 * - Feature flag "rollout.trym-integration" must be enabled
 *
 * **Response Data:**
 * - Returns single `ApiResult<ConvertImmaturePlantResponse>` object (not array) with conversion results
 * - Includes array of converted plant IDs for tracking and reference
 * - Plant conversion status and success confirmation
 * - Mature plant ID assignments for newly converted plants
 *
 * **Plant Conversion Process:**
 * - **Status Transition**: Converts immature plants to mature plant status
 * - **ID Retention**: Existing plant IDs maintained through conversion process
 * - **Validation**: All conversion data validated before processing
 * - **Batch Processing**: Multiple immature plants converted in single operation
 *
 * **Non-State Tracking (NONSTS) Behavior:**
 * - **Internal Only**: Plant creation for internal cultivation tracking only
 * - **No External Reporting**: Plant conversion NOT transmitted to state traceability systems
 * - **Cultivation Focus**: Designed for internal plant management and cultivation workflows
 * - **Compliance Safe**: Does not interfere with official state tracking requirements
 *
 * **Maturity Transition:**
 * - **Growth Stage**: Immature to mature plant status transition
 * - **Cultivation Ready**: Mature plants ready for flowering phase management
 * - **Tracking Continuity**: Maintains plant tracking through maturity transition
 * - **Workflow Integration**: Supports cultivation facility growth phase workflows
 *
 * **Common Use Cases:**
 * - Convert vegetative plants to mature flowering status
 * - Transition immature batches to mature cultivation phases
 * - Progress plants through cultivation development stages
 * - Support internal cultivation workflow maturity management
 * - Manage plant lifecycle transitions without state system integration
 *
 * **Performance & Limits:**
 * - Efficient plant conversion for cultivation management
 * - Validation performed before any plant conversion
 * - Changes reflected immediately in internal cultivation systems
 * - Optimized for cultivation facility maturity workflows
 *
 * **Related Endpoints:**
 * - `POST /plant/nonsts/update` - Update converted plants with cultivation data
 * - `GET /plant` - Retrieve converted plant information
 * - `POST /plant/harvest` - Official plant harvest operations (state tracked)
 *
 * **Important Notes:**
 * - **Feature Gated**: Requires "rollout.trym-integration" feature flag to be enabled
 * - **Plant IDs Returned**: Save returned plant IDs for future plant management operations
 * - **Internal Tracking**: Plants converted for internal cultivation management only
 * - **State Compliance**: Does not affect official state traceability system records
 * - **Cultivation Ready**: Mature plants ready for internal cultivation tracking workflows
 */
export const plantNonstsBatchConvertImmatureplantsPost = <ThrowOnError extends boolean = false>(options?: Options<PlantNonstsBatchConvertImmatureplantsPostData, ThrowOnError>) => {
    return (options?.client ?? client).post<PlantNonstsBatchConvertImmatureplantsPostResponses, PlantNonstsBatchConvertImmatureplantsPostErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/plant/nonsts/batch/convert/immatureplants',
        ...options,
        headers: {
            'Content-Type': 'application/json-patch+json',
            ...options?.headers
        }
    });
};

/**
 * Create Mature Plant Batch (Non-State Tracking)
 * **Purpose:** Create a batch of mature plants ready for flowering phase cultivation tracking without reporting to state traceability systems.
 *
 * **Request Requirements:**
 * - "Inventory" or "Cultivation" role authorization required for mature plant creation
 * - `CreateMatureBatchRequest` object in request body with mature plant batch details
 * - Content-Type: application/json
 * - Valid mature plant data for each plant in the batch
 * - Feature flag "rollout.trym-integration" must be enabled
 *
 * **Response Data:**
 * - Returns single `ApiResult<CreateMaturePlantsResponse>` object (not array) with creation results
 * - Includes array of created plant IDs for tracking and reference
 * - Batch creation status and success confirmation
 * - Plant ID assignments for newly created mature plants
 *
 * **Mature Plant Batch Creation:**
 * - **Multiple Plants**: Creates multiple mature plants in a single operation
 * - **Flowering Ready**: Plants created at mature stage ready for flowering phase
 * - **ID Assignment**: Each plant receives a unique PlantId for future operations
 * - **Validation**: All plant data validated before batch creation
 * - **Atomic Operation**: Batch succeeds or fails as a complete unit
 *
 * **Non-State Tracking (NONSTS) Behavior:**
 * - **Internal Only**: Plant creation for internal cultivation tracking only
 * - **No External Reporting**: Plant creation NOT transmitted to state traceability systems
 * - **Cultivation Focus**: Designed for internal mature plant management and flowering workflows
 * - **Compliance Safe**: Does not interfere with official state tracking requirements
 *
 * **Mature Plant Characteristics:**
 * - **Growth Stage**: Plants ready for flowering phase cultivation
 * - **Cultivation Ready**: Created with unique identifiers for flowering management
 * - **Production Phase**: Mature plants prepared for harvest cultivation workflows
 * - **Internal Records**: Maintained in internal cultivation systems only
 *
 * **Common Use Cases:**
 * - Create batches of mature plants for flowering room management
 * - Initialize mature plant inventory for production cycles
 * - Set up flowering phase plant tracking for facility management
 * - Start mature cultivation workflows without state system integration
 * - Manage internal mature plant genetics and production programs
 *
 * **Performance & Limits:**
 * - Batch processing for efficient mature plant creation workflows
 * - Validation performed before any plant creation
 * - Changes reflected immediately in internal cultivation systems
 * - Optimized for cultivation facility flowering phase workflows
 *
 * **Related Endpoints:**
 * - `POST /plant/nonsts/update` - Update created mature plants with cultivation data
 * - `POST /plant/nonsts/batch/immatureplants` - Create immature plant batches
 * - `POST /plant/nonsts/batch/convert/immatureplants` - Convert immature to mature plants
 * - `GET /plant` - Retrieve created mature plant information
 * - `POST /plant/harvest` - Official plant harvest operations (state tracked)
 *
 * **Important Notes:**
 * - **Feature Gated**: Requires "rollout.trym-integration" feature flag to be enabled
 * - **Plant IDs Returned**: Save returned plant IDs for future mature plant management operations
 * - **Internal Tracking**: Plants created for internal cultivation management only
 * - **State Compliance**: Does not affect official state traceability system records
 * - **Flowering Ready**: Mature plants ready for flowering phase cultivation workflows
 * - **Batch Efficiency**: Creates multiple mature plants efficiently in single operation
 */
export const plantNonstsBatchMatureplantsPost = <ThrowOnError extends boolean = false>(options?: Options<PlantNonstsBatchMatureplantsPostData, ThrowOnError>) => {
    return (options?.client ?? client).post<PlantNonstsBatchMatureplantsPostResponses, PlantNonstsBatchMatureplantsPostErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/plant/nonsts/batch/matureplants',
        ...options,
        headers: {
            'Content-Type': 'application/json-patch+json',
            ...options?.headers
        }
    });
};

/**
 * Retag Plant or Clone (Non-State Tracking)
 * **Purpose:** Update plant or clone tag identification for internal cultivation tracking without reporting to state traceability systems.
 *
 * **Request Requirements:**
 * - "Inventory" or "Cultivation" role authorization required for plant retagging
 * - `RetagPlantRequest` object in request body with retagging details
 * - Content-Type: application/json
 * - Valid existing plant identification and new tag information
 * - Feature flag "rollout.trym-integration" must be enabled
 *
 * **Response Data:**
 * - Returns HTTP 200 with no response body on success
 * - No data returned - operation confirmation only
 * - Operation status confirms successful retagging completion
 *
 * **Retagging Process:**
 * - **Tag Replacement**: Updates existing plant tag with new identification
 * - **Plant Identification**: Maintains plant record while updating tag reference
 * - **Validation**: Ensures new tag is unique and valid for the facility
 * - **Immediate Update**: Tag change reflected immediately in cultivation systems
 *
 * **Non-State Tracking (NONSTS) Behavior:**
 * - **Internal Only**: Tag updates for internal cultivation tracking only
 * - **No External Reporting**: Retagging NOT transmitted to state traceability systems
 * - **Cultivation Focus**: Designed for internal plant management and tag organization
 * - **Compliance Safe**: Does not interfere with official state tracking requirements
 *
 * **Retagging Applications:**
 * - **Tag Damage**: Replace damaged or unreadable plant tags
 * - **Organization**: Update tag numbering for facility organization
 * - **Growth Stage**: Retag plants when moving between cultivation areas
 * - **Clone Management**: Update clone tags for genetic tracking
 *
 * **Common Use Cases:**
 * - Replace damaged plant tags for continued tracking
 * - Update plant identification for facility reorganization
 * - Retag clones for genetic lineage management
 * - Maintain plant tag consistency across cultivation areas
 * - Support internal cultivation workflow tag requirements
 *
 * **Performance & Limits:**
 * - Single plant retagging operation for targeted tag management
 * - Validation performed before any tag changes
 * - Changes reflected immediately in internal cultivation systems
 * - Optimized for cultivation facility tag management workflows
 *
 * **Related Endpoints:**
 * - `POST /plant/nonsts/update` - Update other plant data beyond tags
 * - `GET /plant` - Retrieve plant information with current tags
 * - `POST /plant/nonsts` - Create new plants with initial tags
 *
 * **Important Notes:**
 * - **Feature Gated**: Requires "rollout.trym-integration" feature flag to be enabled
 * - **Tag Uniqueness**: New tag must be unique within the cultivation facility
 * - **Internal Tracking**: Tag changes for internal cultivation management only
 * - **State Compliance**: Does not affect official state traceability system records
 * - **Cultivation Continuity**: Maintains plant tracking continuity with updated identification
 */
export const plantNonstsRetagPost = <ThrowOnError extends boolean = false>(options?: Options<PlantNonstsRetagPostData, ThrowOnError>) => {
    return (options?.client ?? client).post<PlantNonstsRetagPostResponses, PlantNonstsRetagPostErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/plant/nonsts/retag',
        ...options,
        headers: {
            'Content-Type': 'application/json-patch+json',
            ...options?.headers
        }
    });
};

/**
 * Retire Immature Plant Batch (Non-State Tracking)
 * **Purpose:** Retire batches of immature plants or clones from active cultivation for internal tracking without reporting to state traceability systems.
 *
 * **Request Requirements:**
 * - "Inventory" or "Cultivation" role authorization required for plant retirement
 * - `RetireImmaturePlantsRequest` object in request body with retirement details
 * - Content-Type: application/json
 * - Valid immature plant or clone identification for retirement
 * - Plants must be in immature stage for this operation
 *
 * **Response Data:**
 * - Returns HTTP 200 with no response body on success
 * - No data returned - operation confirmation only
 * - Status confirmation indicates successful plant retirement completion
 *
 * **Plant Retirement Process:**
 * - **Batch Retirement**: Retires multiple immature plants or clones in single operation
 * - **Status Change**: Updates plant status to retired/inactive in cultivation systems
 * - **Validation**: Ensures plants are valid and in immature stage before retirement
 * - **Immediate Effect**: Retirement status applied immediately to cultivation records
 *
 * **Non-State Tracking (NONSTS) Behavior:**
 * - **Internal Only**: Plant retirement for internal cultivation tracking only
 * - **No External Reporting**: Retirement actions NOT transmitted to state traceability systems
 * - **Cultivation Focus**: Designed for internal plant lifecycle management
 * - **Compliance Safe**: Does not interfere with official state tracking requirements
 *
 * **Immature Plant Retirement Reasons:**
 * - **Quality Control**: Remove plants that don't meet cultivation standards
 * - **Space Management**: Retire excess plants for cultivation area optimization
 * - **Health Issues**: Remove unhealthy or diseased plants from active cultivation
 * - **Selection Process**: Retire plants not selected for continued cultivation
 * - **Facility Management**: Clear immature plants for cultivation workflow changes
 *
 * **Common Use Cases:**
 * - Retire poor-performing immature plants or clones
 * - Remove excess immature plants to optimize cultivation space
 * - Clear unhealthy plants from cultivation areas
 * - Support cultivation selection and quality control processes
 * - Manage immature plant inventory for facility efficiency
 *
 * **Performance & Limits:**
 * - Batch processing for efficient plant retirement workflows
 * - Validation performed before any retirement actions
 * - Changes reflected immediately in internal cultivation systems
 * - Optimized for cultivation facility plant lifecycle management
 *
 * **Related Endpoints:**
 * - `POST /plant/nonsts/batch/immatureplants` - Create immature plant batches
 * - `POST /plant/nonsts/update` - Update immature plants before retirement
 * - `GET /plant` - Retrieve plant information including retirement status
 * - `POST /plant/nonsts/batch/convert/immatureplants` - Convert immature to mature plants
 *
 * **Important Notes:**
 * - **Immature Only**: This endpoint specifically handles immature plants and clones
 * - **Batch Operation**: Can retire multiple plants efficiently in single request
 * - **Internal Tracking**: Retirement for internal cultivation management only
 * - **State Compliance**: Does not affect official state traceability system records
 * - **Irreversible**: Plant retirement action cannot be easily undone
 * - **Validation Required**: Plants must exist and be in immature stage for retirement
 */
export const plantNonstsBatchRetirePost = <ThrowOnError extends boolean = false>(options?: Options<PlantNonstsBatchRetirePostData, ThrowOnError>) => {
    return (options?.client ?? client).post<PlantNonstsBatchRetirePostResponses, PlantNonstsBatchRetirePostErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/plant/nonsts/batch/retire',
        ...options,
        headers: {
            'Content-Type': 'application/json-patch+json',
            ...options?.headers
        }
    });
};

/**
 * Finish or Unfinish Harvest Batch (Non-State Tracking)
 * **Purpose:** Mark harvest batches as finished or unfinished for internal cultivation tracking without reporting to state traceability systems.
 *
 * **Request Requirements:**
 * - "Inventory" or "Cultivation" role authorization required for harvest status management
 * - `FinishHarvestBatchRequest` object in request body with harvest batch details
 * - Content-Type: application/json
 * - Valid harvest batch identification and finish/unfinish action
 * - Feature flag "rollout.trym-integration" must be enabled
 *
 * **Response Data:**
 * - Returns HTTP 200 with no response body on success
 * - No data returned - operation confirmation only
 * - Status confirmation indicates successful harvest batch update
 *
 * **Finish/Unfinish Operations:**
 * - **FINISH**: Marks harvest batch as completed and ready for processing
 * - **UNFINISH**: Reverts harvest batch to in-progress status for continued work
 * - **Status Toggle**: Can switch between finished and unfinished states as needed
 * - **Batch Management**: Affects entire harvest batch status uniformly
 *
 * **Non-State Tracking (NONSTS) Behavior:**
 * - **Internal Only**: Harvest status updates for internal cultivation tracking only
 * - **No External Reporting**: Status changes NOT transmitted to state traceability systems
 * - **Cultivation Focus**: Designed for internal harvest workflow management
 * - **Compliance Safe**: Does not interfere with official state tracking requirements
 *
 * **Harvest Batch Status Management:**
 * - **Workflow Control**: Controls harvest batch progression through processing stages
 * - **Quality Gates**: Finish status indicates batch readiness for next processing steps
 * - **Reversible Actions**: Unfinish allows returning to active harvest work
 * - **Batch Integrity**: Maintains harvest batch data consistency
 *
 * **Common Use Cases:**
 * - Mark harvest batches as complete when cultivation work is finished
 * - Unfinish harvest batches to allow additional cultivation work
 * - Control harvest workflow progression through processing stages
 * - Manage harvest batch status for internal tracking and reporting
 * - Support cultivation facility harvest workflow requirements
 *
 * **Performance & Limits:**
 * - Single batch operation for targeted harvest status management
 * - Immediate status update reflected in cultivation systems
 * - Optimized for harvest workflow management and status tracking
 * - Validation performed before any status changes
 *
 * **Related Endpoints:**
 * - `GET /harvest` - Retrieve harvest batch information and current status
 * - `POST /plant/harvest` - Official plant harvest operations (state tracked)
 * - `POST /plant/nonsts/update` - Update plant data related to harvest
 *
 * **Important Notes:**
 * - **Feature Gated**: Requires "rollout.trym-integration" feature flag to be enabled
 * - **Reversible Operation**: Finish and unfinish actions can be toggled as needed
 * - **Internal Tracking**: Status changes for internal cultivation management only
 * - **State Compliance**: Does not affect official state traceability system records
 * - **Workflow Control**: Critical for managing internal harvest processing workflows
 */
export const plantNonstsBatchFinishHarvestPost = <ThrowOnError extends boolean = false>(options?: Options<PlantNonstsBatchFinishHarvestPostData, ThrowOnError>) => {
    return (options?.client ?? client).post<PlantNonstsBatchFinishHarvestPostResponses, PlantNonstsBatchFinishHarvestPostErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/plant/nonsts/batch/finish-harvest',
        ...options,
        headers: {
            'Content-Type': 'application/json-patch+json',
            ...options?.headers
        }
    });
};

/**
 * Split Immature Plant Batch (Non-State Tracking)
 * **Purpose:** Split immature plant or clone batches into two separate batches for internal cultivation management without reporting to state traceability systems.
 *
 * **Request Requirements:**
 * - "Inventory" or "Cultivation" role authorization required for batch splitting
 * - `SplitImmaturePlantsRequest` object in request body with split details
 * - Content-Type: application/json
 * - Valid immature batch identification and split configuration
 * - Source batch must contain multiple plants to enable splitting
 *
 * **Response Data:**
 * - Returns single `ApiResult<SplitImmaturePlantResult>` object (not array) with split results
 * - Includes details of both resulting batches after split operation
 * - Batch split status and success confirmation
 * - Plant distribution information for the two new batches
 *
 * **Batch Splitting Process:**
 * - **Source Division**: Divides single immature batch into two separate batches
 * - **Plant Distribution**: Distributes plants between original and new batch
 * - **Batch Integrity**: Maintains plant tracking continuity through split operation
 * - **Validation**: Ensures source batch is valid and contains sufficient plants for splitting
 * - **Atomic Operation**: Split succeeds or fails as complete operation
 *
 * **Non-State Tracking (NONSTS) Behavior:**
 * - **Internal Only**: Batch splitting for internal cultivation tracking only
 * - **No External Reporting**: Split operations NOT transmitted to state traceability systems
 * - **Cultivation Focus**: Designed for internal batch management and cultivation workflows
 * - **Compliance Safe**: Does not interfere with official state tracking requirements
 *
 * **Immature Batch Splitting Applications:**
 * - **Facility Management**: Split large batches for different cultivation areas
 * - **Growth Phase Management**: Separate plants based on development stage
 * - **Quality Control**: Isolate high-performing plants from standard batches
 * - **Genetic Management**: Separate clones for different breeding programs
 * - **Space Optimization**: Distribute plants across multiple cultivation rooms
 *
 * **Common Use Cases:**
 * - Split large immature plant batches for better facility management
 * - Separate high-quality clones from standard cultivation batches
 * - Distribute plants across different cultivation rooms or areas
 * - Create specialized batches for different cultivation treatments
 * - Support cultivation workflow organization and plant management
 *
 * **Performance & Limits:**
 * - Single batch operation creating two resulting batches
 * - Validation performed before any batch splitting
 * - Changes reflected immediately in internal cultivation systems
 * - Optimized for cultivation facility batch management workflows
 *
 * **Related Endpoints:**
 * - `POST /plant/nonsts/batch/immatureplants` - Create original immature plant batches
 * - `POST /plant/nonsts/update` - Update plants within split batches
 * - `GET /plant` - Retrieve plant information for both resulting batches
 * - `POST /plant/nonsts/batch/convert/immatureplants` - Convert split batches to mature
 *
 * **Important Notes:**
 * - **Immature Only**: This endpoint specifically handles immature plant and clone batches
 * - **Two-Batch Result**: Split operation always creates exactly two batches
 * - **Plant Continuity**: All plants maintain their tracking through the split process
 * - **Internal Tracking**: Split operations for internal cultivation management only
 * - **State Compliance**: Does not affect official state traceability system records
 * - **Batch Requirements**: Source batch must contain multiple plants to enable splitting
 */
export const plantNonstsSplitPost = <ThrowOnError extends boolean = false>(options?: Options<PlantNonstsSplitPostData, ThrowOnError>) => {
    return (options?.client ?? client).post<PlantNonstsSplitPostResponses, PlantNonstsSplitPostErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/plant/nonsts/split',
        ...options,
        headers: {
            'Content-Type': 'application/json-patch+json',
            ...options?.headers
        }
    });
};

/**
 * Update Plant Batch (Non-State Tracking)
 * **Purpose:** Update plant batch information such as strain or location for internal cultivation tracking without reporting to state traceability systems.
 *
 * **Request Requirements:**
 * - "Inventory" or "Cultivation" role authorization required for batch data modification
 * - `UpdateBatchRequest` object in request body with batch update details
 * - Content-Type: application/json
 * - Valid batch identification and field updates
 * - Feature flag "rollout.trym-integration" must be enabled
 *
 * **Response Data:**
 * - Returns HTTP 200 with no response body on success
 * - No data returned - operation confirmation only
 * - Status confirmation indicates successful batch update completion
 *
 * **Batch Update Capabilities:**
 * - **Strain Updates**: Modify strain information for entire plant batch
 * - **Location Updates**: Change cultivation location or room assignment for batch
 * - **Batch Properties**: Update other batch-level cultivation characteristics
 * - **Bulk Changes**: Apply updates to all plants within the specified batch
 *
 * **Sparse Update Behavior:**
 * - **Selective Updates**: Only provided fields in the request will be updated
 * - **Field Independence**: Each batch property can be updated independently
 * - **Preservation**: Omitted fields maintain their current values
 * - **Validation**: All provided updates validated before application
 *
 * **Non-State Tracking (NONSTS) Behavior:**
 * - **Internal Only**: Batch updates for internal cultivation tracking only
 * - **No External Reporting**: Changes NOT transmitted to state traceability systems
 * - **Cultivation Focus**: Designed for internal batch management and cultivation workflows
 * - **Compliance Safe**: Does not interfere with official state tracking requirements
 *
 * **Common Use Cases:**
 * - Update strain information when batch genetics are reclassified
 * - Move plant batches to different cultivation rooms or areas
 * - Modify batch properties for improved cultivation tracking
 * - Correct batch information for accurate facility management
 * - Support cultivation workflow batch organization requirements
 *
 * **Performance & Limits:**
 * - Single batch operation affecting all plants in the specified batch
 * - Validation performed before any batch changes
 * - Changes reflected immediately in internal cultivation systems
 * - Optimized for cultivation facility batch management workflows
 *
 * **Related Endpoints:**
 * - `POST /plant/nonsts/update` - Update individual plant data within batches
 * - `GET /plant` - Retrieve current plant and batch information
 * - `POST /plant/nonsts` - Create new plant batches with initial properties
 *
 * **Important Notes:**
 * - **Feature Gated**: Requires "rollout.trym-integration" feature flag to be enabled
 * - **Batch-Wide Impact**: Updates affect all plants within the specified batch
 * - **Internal Tracking**: Changes for internal cultivation management only
 * - **State Compliance**: Does not affect official state traceability system records
 * - **Cultivation Efficiency**: Streamlines batch-level cultivation management operations
 */
export const plantNonstsBatchPost = <ThrowOnError extends boolean = false>(options?: Options<PlantNonstsBatchPostData, ThrowOnError>) => {
    return (options?.client ?? client).post<PlantNonstsBatchPostResponses, PlantNonstsBatchPostErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/plant/nonsts/batch',
        ...options,
        headers: {
            'Content-Type': 'application/json-patch+json',
            ...options?.headers
        }
    });
};

/**
 * Create PreOrder
 * **Purpose:** Create a new customer pre-order by submitting cart items with customer information and fulfillment details.
 *
 * **Request Requirements:**
 * - "PreOrder" role authorization required for order creation
 * - `CreatePreOrderRequest` object in request body with complete order details
 * - Content-Type: application/json
 * - Valid customer ID that exists in the system
 * - **Idempotency Support**: Requires `ConsumerKey` header and `IdempotencyKey` field for duplicate prevention (see [Idempotency Documentation](/pages/idempotency.html))
 *
 * **Response Data:**
 * - Returns `PreOrderResponse` object with assigned order ID and transaction ID
 * - Order ID can be used for tracking and future order operations
 * - Transaction ID links to the transaction for fulfillment tracking
 *
 * **Required Request Information:**
 * - Valid CustomerId for the order recipient
 * - Array of cart items with products, quantities, and any special instructions
 * - Order source for tracking and reporting (Web, In-Store, Express)
 * - Fulfillment details with pickup or delivery information and timing
 *
 * **Order Sources Available:**
 * - Web: Online orders from e-commerce platforms
 * - In-Store: Orders placed directly at dispensary location
 * - Express: Expedited or curbside pickup orders
 * - Note: Order Source is deprecated and will be replaced with more comprehensive tracking values
 *
 * **Delivery Time Windows:**
 * - TimeWindowXXXDateUtc fields express desired delivery time windows
 * - May be expanded to pickup orders in the future
 * - Data exposed to locations with "Delivery Management" feature enabled
 *
 * **Redemptions Support:**
 * - Third-party loyalty redemptions and LeafLogix discount codes supported
 * - Valid types: SpringBig Rewards/Offers, Alpine IQ, LeafLogix Codes, Fyllo
 * - Redemption ID should be discount code, reward ID, offer ID, or template ID
 *
 * **Common Use Cases:**
 * - Process e-commerce orders from online platforms
 * - Create pickup orders for customer convenience
 * - Handle delivery orders with specified time windows
 * - Apply loyalty rewards and promotional discounts
 * - Enable customers to secure products before visiting store
 *
 * **Performance & Limits:**
 * - Uses idempotency key to prevent duplicate order creation
 * - Product validation ensures availability and purchase limits
 * - Customer verification confirms validity for location
 * - Compliance checking for local regulations and restrictions
 *
 * **Related Endpoints:**
 * - `POST /preorder/price-cart` - Calculate pricing before order submission
 * - `POST /transaction/create-anonymous` - Anonymous customers without full profiles
 *
 *
 * **Important Notes:**
 * - Payment occurs later at pickup/delivery, not during order creation
 * - System validates product availability and customer purchase limits
 * - Customer must exist and be valid for the authenticated location
 * - Orders must comply with local regulations and purchase restrictions
 * - Use IdempotencyKey to prevent duplicate order creation
 */
export const preorderSubmitPost = <ThrowOnError extends boolean = false>(options?: Options<PreorderSubmitPostData, ThrowOnError>) => {
    return (options?.client ?? client).post<PreorderSubmitPostResponses, PreorderSubmitPostErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/preorder/submit',
        ...options,
        headers: {
            'Content-Type': 'application/json-patch+json',
            ...options?.headers
        }
    });
};

/**
 * Update PreOrder
 * **✏️ Purpose:** Modify an existing pre-order's items, delivery information, notes, or redemptions.
 *
 * **🔄 Updatable Fields:**
 * - **Cart Items:** Add, remove, or modify product quantities and special instructions
 * - **Order Notes:** Update customer notes or special handling instructions
 * - **Delivery Information:** Change delivery address or timing preferences
 * - **Loyalty Redemptions:** Add, remove, or modify applied discounts and rewards
 * - **Order Source:** Update tracking source information
 *
 * **🚫 Non-Updatable Fields:**
 * - **Customer ID:** Cannot transfer order to different customer
 * - **Idempotency Key:** Cannot modify unique transaction identifier
 * - **Order ID:** Core order identifier remains fixed
 *
 * **📋 Update Behavior:**
 * - **Redemptions:** If redemptions field is omitted, existing redemptions are preserved
 * - **Items:** Complete replacement of cart items with provided array
 * - **Delivery:** Updates only if delivery information is provided
 * - **Incremental Changes:** Only provided fields are modified
 *
 * **⏰ Update Restrictions:**
 * Orders can only be updated while in specific states:
 * - ✅ **Submitted/Pending:** Full updates allowed
 * - ✅ **Processing:** Limited updates may be available
 * - ❌ **Filled/Complete:** No updates permitted
 * - ❌ **Checked Out:** Payment completed, updates blocked
 *
 * **🎯 Common Use Cases:**
 * - **Cart Modifications:** Customer wants to add/remove items before fulfillment
 * - **Address Changes:** Update delivery location for customer convenience
 * - **Special Instructions:** Add preparation notes or customer preferences
 * - **Discount Updates:** Apply newly available promotions or loyalty rewards
 * - **Fulfillment Changes:** Switch between pickup and delivery options
 *
 * **🔧 Request Format:**
 * Provide an `UpdatePreOrderRequest` object with OrderId and the fields to be updated.
 *
 * **⚠️ Important Notes:**
 * - **Status Check:** Use the status endpoint to verify order is still updateable
 * - **Inventory Impact:** Item changes may affect product availability
 * - **Pricing Recalculation:** Updates may change order totals and taxes
 * - **Delivery Validation:** Address changes subject to delivery zone verification
 */
export const preorderUpdatePost = <ThrowOnError extends boolean = false>(options?: Options<PreorderUpdatePostData, ThrowOnError>) => {
    return (options?.client ?? client).post<PreorderUpdatePostResponses, PreorderUpdatePostErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/preorder/update',
        ...options,
        headers: {
            'Content-Type': 'application/json-patch+json',
            ...options?.headers
        }
    });
};

/**
 * Cancel PreOrder
 * **❌ Purpose:** Cancel an existing pre-order and release any reserved inventory.
 *
 * **🔍 Cancellation Requirements:**
 * Order must be in a cancellable state - use the status endpoint to verify before attempting cancellation.
 *
 * **✅ Cancellable States:**
 * - **Submitted/Pending:** Order not yet started by staff
 * - **Processing:** Order in early preparation stages (may vary by location)
 *
 * **🚫 Non-Cancellable States:**
 * - **Checked Out:** Payment has been processed
 * - **Filled/Complete:** Order fulfillment finished
 * - **Partially Filled:** Some items already prepared/dispensed
 * - **In Transit:** Delivery orders already out for delivery
 *
 * **🔄 Cancellation Effects:**
 * - **Inventory Release:** Reserved items returned to available inventory
 * - **Payment Handling:** Refunds processed according to payment method
 * - **Loyalty Redemptions:** Applied rewards/discounts are restored to customer account
 * - **Order Status:** Permanently marked as cancelled
 * - **Customer Notification:** Automated notifications sent if configured
 *
 * **🎯 Common Cancellation Reasons:**
 * - **Customer Request:** Customer no longer wants the order
 * - **Inventory Issues:** Items became unavailable after order placement
 * - **Payment Problems:** Payment processing failed or was declined
 * - **Delivery Issues:** Address problems or delivery zone restrictions
 * - **Business Operations:** Store closure or emergency situations
 *
 * **🔧 Request Format:**
 * Provide a `CancelPreOrderRequest` object with the OrderId to cancel.
 *
 * **Performance & Limits:**
 * - Rate limited to 240 requests per minute for order management protection
 * - Single order cancellation operation for targeted processing
 * - Immediate inventory and payment processing upon successful cancellation
 *
 * **⚠️ Important Notes:**
 * - **Irreversible Action:** Cancelled orders cannot be restored or reactivated
 * - **Status Verification:** Always check cancellable status before attempting cancellation
 * - **Refund Processing:** Payment refunds may take time depending on payment method
 * - **Inventory Impact:** Cancellation immediately releases reserved inventory
 * - **Customer Communication:** Consider notifying customer of cancellation reason
 */
export const preorderCancelPost = <ThrowOnError extends boolean = false>(options?: Options<PreorderCancelPostData, ThrowOnError>) => {
    return (options?.client ?? client).post<PreorderCancelPostResponses, PreorderCancelPostErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/preorder/cancel',
        ...options,
        headers: {
            'Content-Type': 'application/json-patch+json',
            ...options?.headers
        }
    });
};

/**
 * Get PreOrder Status
 * **📊 Purpose:** Retrieve current status and details for pre-orders to track fulfillment progress.
 *
 * **🔍 Query Options:**
 * - **Specific Order:** Provide PreOrderId to get detailed status for a single order
 * - **All Open Orders:** Omit PreOrderId to retrieve all recent active orders (last 14 days)
 * - **Line Item Details:** Set includeLineItems=true for detailed product information (requires PreOrderId)
 *
 * **📋 Status Information Returned:**
 * - **Order Details:** Order ID, transaction ID, customer information, timestamps
 * - **Current Status:** Order state (Submitted, Processing, Filled, Complete, Cancelled)
 * - **Fulfillment Info:** Pickup/delivery details, estimated completion times
 * - **Update Permissions:** Whether order can still be modified or cancelled
 * - **Payment Status:** Payment processing state and totals
 * - **Line Items:** Product details, quantities, allocated inventory (when requested)
 *
 * **📦 Order Status States:**
 * - **Submitted:** Order received and queued for processing
 * - **Processing:** Staff actively preparing order items
 * - **Filled:** All items prepared and ready for customer
 * - **Complete:** Customer has received order (pickup/delivery completed)
 * - **Cancelled:** Order cancelled and inventory released
 *
 * **⚡ Performance Features:**
 * - **Optimized for Real-Time:** Designed for frequent status checking and monitoring
 * - **Batch Queries:** Retrieve multiple order statuses efficiently without PreOrderId
 * - **Selective Detail:** Choose level of detail needed with includeLineItems parameter
 *
 * **🎯 Common Use Cases:**
 * - **Customer Updates:** Provide real-time order progress to customers
 * - **Operations Dashboard:** Monitor all active orders across fulfillment workflow
 * - **Integration Sync:** Keep external systems updated with current order states
 * - **Customer Service:** Quick lookup of order status for support inquiries
 * - **Automated Notifications:** Trigger customer alerts based on status changes
 *
 * **⚠️ Important Notes:**
 * - **Line Item Restriction:** includeLineItems requires a specific PreOrderId
 * - **Recent Orders Filter:** Bulk queries return orders from last 14 days only
 * - **Location Scoped:** Results filtered to authenticated user's location
 * - **Real-Time Data:** Status reflects current state, may change during fulfillment
 */
export const preorderStatusGet = <ThrowOnError extends boolean = false>(options?: Options<PreorderStatusGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<PreorderStatusGetResponses, PreorderStatusGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/preorder/Status',
        ...options
    });
};

/**
 * Calculate Cart Pricing
 * **💰 Purpose:** Calculate accurate pricing for a cart before order submission, including taxes, discounts, and final totals.
 *
 * **📋 Required Information:**
 * - **Customer Identity:** Either CustomerId (existing customer) OR CustomerTypeId (customer category)
 * - **Cart Items:** Array of products with quantities to be priced
 * - **Fulfillment Type:** Specify if delivery pricing applies (affects taxes/fees)
 *
 * **💵 Pricing Components Calculated:**
 * - **Subtotal:** Base product prices multiplied by quantities
 * - **Taxes:** Location-specific tax rates applied to taxable items
 * - **Discounts:** Customer-specific pricing, loyalty discounts, promotional offers
 * - **Delivery Fees:** Additional charges for delivery service (if applicable)
 * - **Final Total:** Complete order amount including all fees and adjustments
 *
 * **🎯 Customer Pricing Options:**
 * - **Existing Customer:** Use CustomerId for personalized pricing and loyalty benefits
 * - **Customer Type:** Use CustomerTypeId for category-based pricing (Medical, Recreational, etc.)
 * - **Delivery Context:** Set IsDelivery=true to include delivery-specific pricing
 *
 * **🔍 Pricing Accuracy:**
 * - **Real-Time Calculations:** Pricing reflects current product costs and tax rates
 * - **Location-Specific:** Taxes and fees calculated based on dispensary location
 * - **Customer-Specific:** Applies individual discounts, loyalty rewards, and membership benefits
 * - **Delivery Zones:** Delivery fees calculated based on customer address when provided
 *
 * **🎯 Common Use Cases:**
 * - **Cart Preview:** Show customers accurate totals before checkout
 * - **Price Comparison:** Compare costs across different customer types or delivery options
 * - **Integration Sync:** Keep external e-commerce platforms synchronized with current pricing
 * - **Customer Service:** Provide accurate quotes for customer inquiries
 * - **Mobile Apps:** Real-time cart totals for mobile ordering experiences
 *
 * **🔧 Request Format:**
 * Provide a `PriceCartRequest` object with customer information, cart items, and delivery preferences.
 *
 * **Performance & Limits:**
 * - Rate limited to 240 requests per minute for pricing calculation protection
 * - Real-time pricing calculations optimized for responsive user experience
 * - Single cart operation for immediate pricing feedback
 *
 * **⚠️ Important Notes:**
 * - **Unique Products:** Each product should only appear once in the cart array
 * - **Customer Requirement:** Must specify either CustomerId OR CustomerTypeId (not both)
 * - **Pricing Volatility:** Prices may change between calculation and order submission
 * - **Location Dependency:** Pricing is specific to the authenticated dispensary location
 * - **Address Impact:** Delivery address affects tax calculations and delivery fees
 */
export const preorderPriceCartPost = <ThrowOnError extends boolean = false>(options?: Options<PreorderPriceCartPostData, ThrowOnError>) => {
    return (options?.client ?? client).post<PreorderPriceCartPostResponses, PreorderPriceCartPostErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/preorder/price-cart',
        ...options,
        headers: {
            'Content-Type': 'application/json-patch+json',
            ...options?.headers
        }
    });
};

/**
 * Get Pricing Tiers
 * **Purpose:** Retrieves the complete list of pricing tiers available for the authenticated organization for product pricing strategy and customer segmentation.
 *
 * **Request Requirements:**
 * - Any authenticated role authorization (no specific role required)
 * - No query parameters or request body needed
 *
 * **Response Data:**
 * - Returns array of pricing tier objects: `[{ PricingTier }, ...]`
 * - Array typically contains 2-8 pricing tiers per organization
 * - Returns empty array `[]` if no pricing tiers configured (rare)
 * - Includes tier ID, name, and configuration details
 * - Organization-level pricing tiers for customer segmentation (e.g., "Retail", "Wholesale", "Medical", "VIP")
 * - Results filtered to authenticated organization level
 *
 * **Common Use Cases:**
 * - Configure product pricing based on customer tier assignments
 * - Support tiered pricing strategies for different customer segments
 * - Populate pricing tier dropdown lists in customer management forms
 * - Validate pricing tier assignments in product and order management systems
 * - Generate tier-specific pricing reports and analytics
 * - Enable dynamic pricing based on customer classifications
 *
 * **Performance & Limits:**
 * - Lightweight reference data optimized for frequent access
 * - Small dataset suitable for client-side caching
 * - No pagination needed due to limited number of pricing tiers
 * - Results consistent across all locations within organization
 *
 * **Related Endpoints:**
 * - `GET /products` - Get products with tier-based pricing
 * - `GET /customer/customer-types` - Get customer types that may use pricing tiers
 * - Pricing calculation endpoints that utilize these tiers
 *
 * **Important Notes:**
 * - Pricing tiers are defined at organization level (LSP) not location level
 * - Essential for implementing tiered pricing strategies and customer segmentation
 * - Used for dynamic pricing calculations based on customer classifications
 * - Supports business models with wholesale, retail, and VIP pricing structures
 * - May be used in conjunction with customer types for comprehensive pricing strategies
 */
export const pricingTiersGet = <ThrowOnError extends boolean = false>(options?: Options<PricingTiersGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<PricingTiersGetResponses, PricingTiersGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/pricing-tiers',
        ...options
    });
};

/**
 * Get Producers
 * **Purpose:** Retrieve basic producer identification information for product attribution and reference data needs.
 *
 * **Request Requirements:**
 * - Valid authentication required for producer data access
 * - No request body needed
 * - No query parameters required
 *
 * **Response Data:**
 * - Returns array of producer objects: `[{ Producer }, ...]`
 * - Array typically contains 1-50 producers per organization
 * - Returns empty array `[]` if no producers configured (rare)
 * - Producer details include basic identification information only
 * - Results automatically filtered to authenticated organization and exclude deleted records
 *
 * **Producer Information:**
 * - **Producer ID**: Unique identifier for the producer
 * - **Producer Name**: Display name of the producer
 *
 * **Common Use Cases:**
 * - Populate producer dropdown lists in product management forms
 * - Display producer names for product attribution and branding
 * - Support basic producer identification in product catalogs
 * - Enable producer-based filtering and organization in product displays
 * - Provide producer reference data for product creation workflows
 *
 * **Performance & Limits:**
 * - Lightweight reference data optimized for frequent access
 * - Organization-scoped results for operational relevance and security
 * - Small dataset suitable for client-side caching
 * - Essential reference data for basic producer identification
 *
 * **Related Endpoints:**
 * - `GET /products` - View products that include producer information
 * - `GET /brands` - Related brand information for product attribution
 * - `GET /vendors` - Related vendor information and business relationships
 *
 * **Important Notes:**
 * - **Basic Reference Data**: Provides minimal producer identification information
 * - **Organization Scoped**: Results filtered to authenticated organization level and exclude deleted records
 * - **Limited Data**: Only includes producer ID and name - no licensing, contact, or compliance details
 * - **Product Attribution**: Enables basic producer attribution for product displays
 */
export const producersGet = <ThrowOnError extends boolean = false>(options?: Options<ProducersGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<ProducersGetResponses, ProducersGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/producers',
        ...options
    });
};

/**
 * Get Location Product Overrides
 * **Purpose:** Retrieve all location-specific product overrides for pricing, availability, and display customization at the current location.
 *
 * **Request Requirements:**
 * - "Inventory" role authorization required for product override data access
 * - No query parameters required
 * - No request body needed
 *
 * **Response Data:**
 * - Returns array of `LocationProductOverride` objects with location-specific settings
 * - Array typically contains 50-5,000+ overrides depending on location customization
 * - Returns empty array `[]` if no overrides exist for the location (not null)
 * - If a field is `null`, then the product master version of that field applies
 * - Includes pricing overrides, availability settings, and display configurations
 * - Results automatically filtered to authenticated location
 *
 * **Override Behavior:**
 * - **Null Fields**: When override field is null, the product master value is used
 * - **Set Fields**: When override field has a value, it replaces the master value
 * - **Location Specific**: Overrides only apply to the authenticated location
 * - **Inheritance**: Non-overridden fields inherit from product master data
 *
 * **Common Use Cases:**
 * - Retrieve location-specific pricing for multi-location businesses
 * - Get availability overrides for location inventory management
 * - Access display customizations for location-specific product presentation
 * - Synchronize location overrides with external point-of-sale systems
 * - Generate location-specific product catalogs and pricing sheets
 *
 * **Performance & Limits:**
 * - Optimized for location-specific product management workflows
 * - Results filtered automatically to current location scope
 * - Efficient for multi-location businesses with location-specific pricing
 * - Consider caching for frequent access to override data
 *
 * **Related Endpoints:**
 * - `POST /products/location-overrides` - Create or update location overrides
 * - `GET /products` - Get product master data with default values
 * - `GET /inventory` - Get current inventory levels for overridden products
 *
 * **Important Notes:**
 * - **Inheritance Model**: Null override fields inherit from product master data
 * - **Location Scoped**: Results automatically filtered to authenticated location
 * - **Override Priority**: Location overrides take precedence over master product data
 * - **Multi-Location**: Essential for businesses operating multiple dispensary locations
 * - **Pricing Control**: Enables location-specific pricing strategies and market adaptation
 */
export const productsLocationOverridesGet = <ThrowOnError extends boolean = false>(options?: Options<ProductsLocationOverridesGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<ProductsLocationOverridesGetResponses, ProductsLocationOverridesGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/products/location-overrides',
        ...options
    });
};

/**
 * Create or Update Location Product Overrides
 * **Purpose:** Create or update location-specific product overrides for pricing, availability, and display customization to support multi-location business operations.
 *
 * **Request Requirements:**
 * - "Inventory" role authorization required for product override modification
 * - Array of `LocationProductOverrideRequest` objects in request body
 * - Content-Type: application/json
 * - Valid ProductId required for each override
 *
 * **Response Data:**
 * - Returns HTTP 200 with no response body on success
 * - No data returned - operation confirmation only
 * - Returns HTTP 400 with validation errors if request data is invalid
 * - Partial success possible: some overrides may save even if others fail
 *
 * **Create vs Update Behavior:**
 * - **CREATE**: When no existing override exists for the ProductId at this location, a new override is created
 * - **UPDATE**: When an override already exists for the ProductId at this location, it is updated
 * - **Identification**: Override existence determined by ProductId and authenticated location
 * - **Automatic Detection**: System automatically determines create vs update based on existing data
 *
 * **Sparse Update Behavior:**
 * - **Omitted Fields**: Retain their current override value (no change)
 * - **Null Values**: Remove the override for that field (product master value will apply)
 * - **Set Values**: Update the override with the provided value
 * - **Field Independence**: Each field can be updated independently without affecting others
 *
 * **Override Management:**
 * - **Removal**: Set fields to null to remove overrides and revert to product master values
 * - **Addition**: Set fields to specific values to create new overrides
 * - **Location Scoped**: All overrides apply only to the authenticated location
 * - **Dual Pricing**: Automatically handles recreational price sync when dual pricing is disabled
 *
 * **Common Use Cases:**
 * - Set location-specific pricing for multi-location businesses
 * - Override product availability for location inventory management
 * - Customize product display settings for location-specific presentation
 * - Manage location-based pricing strategies and market adaptation
 * - Synchronize pricing changes from external systems to specific locations
 *
 * **Performance & Limits:**
 * - Batch processing for efficient multi-product override updates
 * - Validation performed before any changes to ensure data integrity
 * - Partial success handling: some overrides may succeed even if others fail
 * - Optimized for location-specific product management workflows
 *
 * **Related Endpoints:**
 * - `GET /products/location-overrides` - Retrieve current location overrides
 * - `GET /products` - Get product master data for comparison
 * - `GET /inventory` - Check inventory levels for overridden products
 *
 * **Important Notes:**
 * - **Partial Success**: Some overrides may save successfully even if others fail validation
 * - **Null Behavior**: Setting fields to null removes overrides and reverts to master data
 * - **Location Isolation**: Overrides only affect the authenticated location
 * - **Validation Required**: All ProductIds must exist and be valid for the location
 * - **Dual Pricing Sync**: Recreational prices automatically sync with medical when dual pricing disabled
 */
export const productsLocationOverridesPost = <ThrowOnError extends boolean = false>(options?: Options<ProductsLocationOverridesPostData, ThrowOnError>) => {
    return (options?.client ?? client).post<ProductsLocationOverridesPostResponses, ProductsLocationOverridesPostErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/products/location-overrides',
        ...options,
        headers: {
            'Content-Type': 'application/json-patch+json',
            ...options?.headers
        }
    });
};

/**
 * Get Products
 * **Purpose:** Retrieve comprehensive product catalog information for API-enabled products, regardless of current inventory levels.
 *
 * **Request Requirements:**
 * - "Inventory" role authorization required for product data access
 * - Optional query parameters for filtering results
 * - No request body needed
 *
 * **Response Data:**
 * - Returns array of product objects: `[{ ProductDetail }, ...]`
 * - Array may contain 0 to 10,000+ products depending on location inventory size
 * - Returns empty array `[]` if no products match criteria (not null)
 * - Product details including SKU, name, description, category, brand, strain information
 * - Pricing data with retail and medical pricing, tax rates, discount eligibility
 * - Classification data including product types, categories, regulatory classifications
 * - Lab results with potency data, cannabinoid profiles, test results when available
 * - Inventory data showing stock levels and availability status
 * - Media assets including product images and visual content
 * - Compliance data with external IDs, producer information, regulatory data
 *
 * **Filtering Options:**
 * - No parameters: Returns all API-enabled products for the location
 * - fromLastModifiedDateUTC: Returns products modified after this date for incremental sync
 * - isActive: Filter by active status (true/false/null for all)
 *
 * **Product Filtering Logic:**
 * - Only products specifically enabled for API access are returned
 * - Only includes products with online availability enabled (onlyOnlineAvailable = true)
 * - Products returned even if currently out of stock
 * - Results automatically filtered to authenticated user's location only
 *
 * **Common Use Cases:**
 * - Get complete product catalog for first-time integration setup
 * - Use incremental updates with fromLastModifiedDateUTC to sync only recent changes
 * - Populate e-commerce online store with complete product information
 * - Maintain up-to-date product database for point-of-sale systems
 * - Build dispensary menus with detailed product information
 * - Analyze product catalog for purchasing and inventory planning decisions
 *
 * **Performance & Limits:**
 * - Use incremental sync with fromLastModifiedDateUTC for regular updates to minimize data transfer
 * - Filter by isActive=true to exclude discontinued products for better performance
 * - Run full catalog sync during off-peak hours for optimal performance
 * - Large product catalogs may require pagination in future versions
 *
 * **Related Endpoints:**
 * - `GET /inventory` - Current stock levels for products with available inventory
 * - `GET /products/strains` - Strain-specific information and genetics data
 * - `GET /products/external-categories` - Product categorization and classification data
 *
 * **Important Notes:**
 * - This endpoint respects the "API access" setting on products for access control
 * - Returns only online-available products (excludes products not enabled for online sales)
 * - Response includes comprehensive product information for full integration capabilities
 * - Products are automatically filtered to the authenticated location
 */
export const productsGet = <ThrowOnError extends boolean = false>(options?: Options<ProductsGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<ProductsGetResponses, ProductsGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/products',
        ...options
    });
};

/**
 * Create or Update Product
 * **Purpose:** Creates a new product or updates an existing product with comprehensive product information for inventory management.
 *
 * **Request Requirements:**
 * - "Inventory" role authorization required for product data access
 * - `ProductDetailUpload` object in request body with product details
 * - Content-Type: application/json
 * - SKU and ProductName required for new products
 *
 * **Response Data:**
 * - Returns single `ProductDetail` object (not array) with updated product information
 * - Response format: `{ ProductDetail }`
 * - Includes assigned product ID for new products or updated ID for existing products
 * - Complete product information with all fields populated
 *
 * **CRITICAL DATA LOSS WARNING:**
 * Most fields will be overwritten with null/zero values if not provided in the request.
 * RECOMMENDED APPROACH: First GET the existing product, modify only the fields you want to change, then POST the complete object back.
 *
 * **Required Fields:**
 * - For CREATE: SKU and ProductName are required
 * - For UPDATE: Only ProductId is required (SKU and ProductName can be omitted to preserve existing values)
 *
 * **Field Behavior:**
 * - Optional<T> Fields: Can be explicitly set to null or omitted to preserve existing values
 * - Regular Fields: Will be set to null/zero if omitted, potentially causing data loss
 * - Exception: Fields like SKU and ProductName preserve existing values when omitted during updates
 *
 * **Common Use Cases:**
 * - Add new products to the catalog for inventory management
 * - Update existing product information when details change
 * - Synchronize product data from external inventory systems
 * - Bulk product updates for pricing or categorization changes
 * - Maintain accurate product information for compliance and sales
 *
 * **Performance & Limits:**
 * - Single product operation for targeted updates
 * - Immediate validation and response
 * - Changes reflected immediately in product catalogs
 * - Consider using GET before POST to avoid data loss
 *
 * **Related Endpoints:**
 * - `GET /products` - Retrieve existing product data before updates
 * - `GET /brand` - Get valid brand IDs for product association
 * - `GET /strains` - Get valid strain IDs for product classification
 *
 * **Important Notes:**
 * - Data loss risk: Always retrieve existing product data before updates
 * - Product ID assignment for successful new product creation
 * - Validation performed before creation/update to ensure data integrity
 * - Changes propagate to inventory and sales systems immediately
 */
export const productsProductPost = <ThrowOnError extends boolean = false>(options?: Options<ProductsProductPostData, ThrowOnError>) => {
    return (options?.client ?? client).post<ProductsProductPostResponses, ProductsProductPostErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/products/product',
        ...options,
        headers: {
            'Content-Type': 'application/json-patch+json',
            ...options?.headers
        }
    });
};

/**
 * Bulk Create or Update Products
 * **Purpose:** Create or update multiple products in a single operation for efficient catalog management and bulk data synchronization.
 *
 * **Request Requirements:**
 * - "Inventory" role authorization required for product data operations
 * - Array of `ProductDetailUpload` objects in request body with product details
 * - Content-Type: application/json
 * - Each product requires SKU and ProductName for creation, ProductId for updates
 *
 * **Response Data:**
 * - Returns mixed array: `[{ ProductDetail }, { SaveProductError }, ...]`
 * - Successful operations return complete `ProductDetail` objects with updated product information
 * - Failed operations return `SaveProductError` objects with ProductId, SKU, ProductName, and ErrorMessage
 * - HTTP 200 for successful processing - check individual items in response array for success/error status
 * - HTTP 400 for validation errors that prevent processing
 * - Mixed array allows partial success - some products may succeed while others fail
 *
 * **CRITICAL DATA LOSS WARNING:**
 * Most fields will be overwritten with null/zero values if not provided in the request.
 * **RECOMMENDED APPROACH:** First GET existing products, modify only desired fields, then POST complete objects back.
 *
 * **Create vs Update Behavior:**
 * - **CREATE**: When ProductId is null or omitted, new product records will be created
 * - **UPDATE**: When ProductId is provided with valid product IDs, existing products will be updated
 * - **Mixed Operations**: Single request can include both create and update operations
 * - **Validation**: SKU and ProductName required for creates, ProductId required for updates
 * - **Individual Processing**: Each product processed independently - some may succeed while others fail
 *
 * **Field Preservation Behavior:**
 * - **Optional<T> Fields**: Can be explicitly set to null or omitted to preserve existing values
 * - **Regular Fields**: Will be set to null/zero if omitted, potentially causing data loss
 * - **Preserved Fields**: SKU and ProductName preserve existing values when omitted during updates
 * - **Best Practice**: Always provide complete product objects to avoid unintended data loss
 *
 * **Error Handling:**
 * - **Partial Success**: Some products may succeed while others fail within the same request
 * - **Error Identification**: Failed products include ErrorMessage, ProductId, SKU, and ProductName
 * - **Validation Errors**: Returns HTTP 400 for validation errors that prevent processing
 * - **Processing Errors**: Returns HTTP 200 with mixed results for individual product errors
 * - **Rollback Behavior**: No automatic rollback - successful operations persist even if others fail
 *
 * **Common Use Cases:**
 * - Import large product catalogs from external systems efficiently
 * - Synchronize product changes across multiple products simultaneously
 * - Bulk update pricing, categorization, or product attributes
 * - Migrate product data between systems with batch processing
 * - Update multiple products after inventory or regulatory changes
 *
 * **Performance & Limits:**
 * - Optimized for bulk product operations and catalog management
 * - Individual product validation and processing for data integrity
 * - No automatic external system broadcasting for performance
 * - Efficient for large-scale product catalog updates
 *
 * **Related Endpoints:**
 * - `GET /products` - Retrieve existing product data before bulk updates
 * - `POST /products/product` - Create or update individual products with external sync
 * - `GET /brand` - Get valid brand IDs for product associations
 * - `GET /strains` - Get valid strain IDs for product classifications
 *
 * **Important Notes:**
 * - **Individual Processing**: Each product processed independently with separate success/failure results
 * - **No External Broadcast**: Traceability system broadcasting not supported on this endpoint
 * - **Data Loss Risk**: Always retrieve existing product data before bulk updates
 * - **Error Checking Required**: Always check response for individual product errors
 * - **Performance Optimized**: Designed for efficient bulk operations without external system overhead
 */
export const productsProductsPost = <ThrowOnError extends boolean = false>(options?: Options<ProductsProductsPostData, ThrowOnError>) => {
    return (options?.client ?? client).post<ProductsProductsPostResponses, ProductsProductsPostErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/products/products',
        ...options,
        headers: {
            'Content-Type': 'application/json-patch+json',
            ...options?.headers
        }
    });
};

/**
 * Set Product Image
 * **Purpose:** Add or update a single image for a product to enhance product presentation and visual merchandising.
 *
 * **Request Requirements:**
 * - "Inventory" role authorization required for product image management
 * - `SetImageRequest` object in request body with ProductId and image data
 * - Content-Type: application/json
 * - Valid ProductId and base64-encoded image data required
 *
 * **Response Data:**
 * - Returns single image response object: `{ SetImageResponse }`
 * - Includes unique image ID for future image management operations
 * - Provides image URL for immediate access to uploaded image
 * - Contains ImageId (integer) and ImageUrl (string) fields only
 *
 * **Image Processing:**
 * - **Single Image**: Adds one image per request to the specified product
 * - **Image ID Assignment**: Returns unique DPOS product image ID for tracking
 * - **Format Support**: Supports standard image formats via base64 encoding
 * - **Validation**: Validates image data and product existence before processing
 *
 * **Integration Behavior:**
 * - **Metrc Integration**: If using Metrc with upload product images enabled, the image will automatically upload to Metrc on next product save
 * - **Automatic Sync**: Integration occurs when `Save Product` is called for this ProductId
 * - **Compliance**: Supports regulatory compliance through integrated system image sync
 * - **External Systems**: Compatible with cultivation and compliance system requirements
 *
 * **Common Use Cases:**
 * - Add product photos for e-commerce and point-of-sale display
 * - Update existing product images for marketing and merchandising
 * - Comply with regulatory requirements for product visual documentation
 * - Enhance customer experience with high-quality product imagery
 * - Support integrated systems with automated image synchronization
 *
 * **Performance & Limits:**
 * - Single image processing for targeted product updates
 * - Base64 encoding for secure image data transmission
 * - Validation performed before processing to ensure data integrity
 * - Optimized for product visual merchandising workflows
 *
 * **Related Endpoints:**
 * - `POST /products/remove-image` - Remove product images using the returned image ID
 * - `POST /products/product` - Save product data and trigger Metrc image sync
 * - `GET /products` - Retrieve products with associated image information
 *
 * **Important Notes:**
 * - **Image ID Required**: Save the returned image ID for future image management operations
 * - **Metrc Auto-Upload**: Images automatically sync to Metrc on next product save when enabled
 * - **Single Operation**: One image per request - use multiple requests for multiple images
 * - **Validation Required**: ProductId must exist and image data must be valid
 * - **Integration Ready**: Supports automated compliance system synchronization
 */
export const productsSetImagePost = <ThrowOnError extends boolean = false>(options?: Options<ProductsSetImagePostData, ThrowOnError>) => {
    return (options?.client ?? client).post<ProductsSetImagePostResponses, ProductsSetImagePostErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/products/set-image',
        ...options,
        headers: {
            'Content-Type': 'application/json-patch+json',
            ...options?.headers
        }
    });
};

/**
 * Delete Product Image
 * **Purpose:** Remove a specific image from a product using the image ID to maintain clean product presentation and manage visual merchandising.
 *
 * **Request Requirements:**
 * - "Inventory" role authorization required for product image management
 * - `DeleteImageRequest` object in request body with ProductId and ImageId
 * - Content-Type: application/json
 * - Valid ProductId and ImageId required (ImageId obtained from set-image response)
 *
 * **Response Data:**
 * - Returns success confirmation object: `{ SuccessResult }`
 * - Simple success confirmation with HTTP 200 status
 * - No additional data fields returned beyond success indicator
 *
 * **Image Removal Process:**
 * - **Targeted Deletion**: Removes specific image identified by ImageId
 * - **Product Association**: Verifies image belongs to the specified ProductId
 * - **Validation**: Ensures both ProductId and ImageId exist and are valid
 * - **Clean Removal**: Permanently removes image from product and storage systems
 *
 * **Safety & Validation:**
 * - **Existence Check**: Validates ProductId and ImageId before deletion
 * - **Ownership Verification**: Ensures image belongs to the specified product
 * - **Authorization**: Confirms user has permission to modify product images
 * - **Error Handling**: Returns appropriate errors for invalid requests
 *
 * **Common Use Cases:**
 * - Remove outdated or incorrect product images from visual merchandising
 * - Clean up product galleries by deleting unwanted or duplicate images
 * - Manage product image lifecycle for marketing and compliance requirements
 * - Maintain accurate product representation in e-commerce and point-of-sale systems
 * - Support product image management workflows and content updates
 *
 * **Performance & Limits:**
 * - Single image deletion for targeted image management
 * - Immediate removal from product and storage systems
 * - Validation performed before deletion to ensure data integrity
 * - Optimized for product visual merchandising and content management workflows
 *
 * **Related Endpoints:**
 * - `POST /products/set-image` - Add images and obtain ImageId for future deletion
 * - `GET /products` - Retrieve products with current image information
 * - `POST /products/product` - Update product data and manage overall product information
 *
 * **Important Notes:**
 * - **ImageId Required**: Use ImageId returned from set-image endpoint for deletion
 * - **Permanent Operation**: Image deletion is permanent and cannot be undone
 * - **Validation Critical**: Both ProductId and ImageId must be valid and associated
 * - **Single Target**: One image per request - use multiple requests for multiple deletions
 * - **Clean Management**: Essential for maintaining organized product image galleries
 */
export const productsRemoveImagePost = <ThrowOnError extends boolean = false>(options?: Options<ProductsRemoveImagePostData, ThrowOnError>) => {
    return (options?.client ?? client).post<ProductsRemoveImagePostResponses, ProductsRemoveImagePostErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/products/remove-image',
        ...options,
        headers: {
            'Content-Type': 'application/json-patch+json',
            ...options?.headers
        }
    });
};

/**
 * Get Product Strains
 * **Purpose:** Retrieve all available cannabis strains for product classification and inventory management in compliance with industry standards.
 *
 * **Request Requirements:**
 * - "Inventory" role authorization required for strain data access
 * - No query parameters required
 * - No request body needed
 *
 * **Response Data:**
 * - Returns array of strain objects: `[{ StrainDetail }, ...]`
 * - Array typically contains 50-1,000+ strains depending on dispensary catalog
 * - Returns empty array `[]` if no strains are configured (not null)
 * - Basic strain information including ID, name, description, type, and external ID
 * - Results automatically filtered to authenticated location strain catalog
 *
 * **Strain Information:**
 * - **Strain ID**: Unique identifier for the strain
 * - **Strain Name**: Display name of the strain
 * - **Strain Description**: Basic text description of the strain
 * - **Strain Abbreviation**: Short code or abbreviation for the strain
 * - **Strain Type**: Basic type classification (e.g., Indica, Sativa, Hybrid)
 * - **External ID**: External system identifier for integration
 *
 * **Common Use Cases:**
 * - Populate strain dropdown lists in product creation and management forms
 * - Display basic strain information for product attribution
 * - Support strain-based product categorization and filtering
 * - Enable strain identification in inventory management systems
 * - Provide strain reference data for product classification workflows
 *
 * **Performance & Limits:**
 * - Optimized for product classification and strain selection workflows
 * - Comprehensive strain database for complete cannabis product categorization
 * - Results filtered to location-specific strain catalog
 * - Efficient for strain-based product search and filtering operations
 *
 * **Related Endpoints:**
 * - `GET /products` - View products with assigned strain classifications
 * - `POST /products/product` - Assign strains to products during creation/update
 * - `GET /strains` - Manage strain master data and configurations
 *
 * **Important Notes:**
 * - **Basic Reference Data**: Provides essential strain identification information only
 * - **Limited Data**: Only includes basic strain details - no cannabinoid profiles, genetics, or effects
 * - **Product Classification**: Strains used for basic product categorization and identification
 * - **Location Catalog**: Results filtered to strains available for the authenticated location
 * - **External Integration**: Includes External ID for traceability system integration
 */
export const productsStrainsGet = <ThrowOnError extends boolean = false>(options?: Options<ProductsStrainsGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<ProductsStrainsGetResponses, ProductsStrainsGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/products/strains',
        ...options
    });
};

/**
 * Get External Categories
 * **Purpose:** Retrieve external system categories for product classification to support integration with traceability and compliance systems.
 *
 * **Request Requirements:**
 * - "Inventory" role authorization required for external category data access
 * - UserId query parameter highly recommended for traceability system integration
 * - No request body needed
 *
 * **Response Data:**
 * - Returns array of string values with external category names
 * - Response format: `[string, string, ...]`
 * - Array contains categories available from integrated traceability systems
 * - Returns empty array `[]` if no external categories are available (not null)
 * - Category names correspond to external system classification standards
 * - Used for populating ExternalCategory field in product data
 * - Results depend on configured integrated systems and user permissions
 *
 * **Integration Requirements:**
 * - **Traceability Systems**: Categories pulled from connected compliance systems (e.g., Metrc, BioTrack)
 * - **User Context**: UserId parameter provides system access context for category retrieval
 * - **System Configuration**: Available categories depend on integrated system configuration
 * - **Compliance Mapping**: Categories align with regulatory compliance requirements
 *
 * **Parameter Guidelines:**
 * - **UserId**: Technically optional but highly recommended for traceability system calls
 * - **System Failure**: Call may fail without UserId when categories come from traceability systems
 * - **Permission Context**: UserId provides proper system access permissions for category retrieval
 * - **Default Fallback**: Uses default user (ID 6) when UserId not provided
 *
 * **Common Use Cases:**
 * - Populate product ExternalCategory field with valid compliance categories
 * - Synchronize product classifications with regulatory traceability systems
 * - Ensure product categories align with state compliance requirements
 * - Support automated product categorization for integrated systems
 * - Validate product classifications against external system standards
 *
 * **Performance & Limits:**
 * - Real-time integration with external traceability systems
 * - Response time dependent on external system availability
 * - Error handling for external system connectivity issues
 * - Optimized for product classification and compliance workflows
 *
 * **Related Endpoints:**
 * - `POST /products/product` - Use external categories in ExternalCategory field
 * - `GET /products` - View products with assigned external categories
 * - `POST /products/products` - Bulk assign external categories to products
 *
 * **Important Notes:**
 * - **UserId Critical**: Highly recommended to prevent traceability system call failures
 * - **External Dependency**: Categories sourced from integrated traceability systems
 * - **Compliance Essential**: External categories required for regulatory compliance
 * - **System Specific**: Available categories depend on configured integrated systems
 * - **Error Handling**: May return errors if external systems are unavailable
 */
export const productsExternalCategoriesGet = <ThrowOnError extends boolean = false>(options?: Options<ProductsExternalCategoriesGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<ProductsExternalCategoriesGetResponses, ProductsExternalCategoriesGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/products/external-categories',
        ...options
    });
};

/**
 * Get Product Categories
 * **Purpose:** Retrieves the complete list of product categories available for the authenticated organization for product classification and menu organization.
 *
 * **Request Requirements:**
 * - Any authenticated role authorization (no specific role required)
 * - No query parameters or request body needed
 *
 * **Response Data:**
 * - Returns array of product category objects: `[{ ProductCategory }, ...]`
 * - Array typically contains 10-30 product categories per organization
 * - Returns empty array `[]` if no categories configured (rare)
 * - Includes category ID, name, and master category classification
 * - Standard cannabis product categories (Flower, Edibles, Concentrates, etc.)
 * - Results filtered to authenticated organization level and exclude deleted records
 *
 * **Common Use Cases:**
 * - Populate product category dropdown lists in product creation forms
 * - Organize product menus by category for customer browsing
 * - Validate product categorization in inventory management systems
 * - Generate category-specific reports for sales analytics
 * - Support e-commerce product filtering and navigation
 *
 * **Performance & Limits:**
 * - Lightweight reference data optimized for frequent access
 * - Small dataset suitable for client-side caching
 * - No pagination needed due to limited number of categories
 * - Results consistent across all locations within organization
 *
 * **Related Endpoints:**
 * - `GET /products` - Get products that use these categories
 * - `POST /product` - Create products with category assignments
 * - `GET /regulatory-category` - Get regulatory category classifications
 *
 * **Important Notes:**
 * - Categories are defined at organization level (LSP) not location level
 * - Standard cannabis industry categories for compliance and consistency
 * - Used for product menu organization and customer filtering
 * - Essential reference data for product management workflows
 */
export const productCategoryGet = <ThrowOnError extends boolean = false>(options?: Options<ProductCategoryGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<ProductCategoryGetResponses, ProductCategoryGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/product-category',
        ...options
    });
};

/**
 * Get Purchase Orders
 * **Purpose:** Retrieve purchase orders with comprehensive filtering options to support procurement management and vendor relationship tracking.
 *
 * **Request Requirements:**
 * - "PurchaseOrder" role authorization required for purchase order data access
 * - Optional query parameters available for filtering purchase orders
 * - Purchase order management permissions for procurement operations
 *
 * **Response Data:**
 * - Response format: `[{ PurchaseOrderData }, { PurchaseOrderData }, ...]`
 * - **No pagination metadata**: Response contains only data array without total counts or page information
 * - Array contains up to PageSize purchase orders (default 1000)
 * - Returns empty array `[]` if no purchase orders match filtering criteria
 * - Includes comprehensive purchase order details and line item information
 * - Results automatically filtered to authenticated location
 *
 * **Pagination Usage:**
 * - **First Request**: Call with PageNumber=0 to get first page
 * - **Subsequent Requests**: Increment PageNumber for each additional page
 * - **End Detection**: Continue requesting pages until you receive an empty array `[]`
 * - **Page Size Control**: Use PageSize parameter to control items per page
 * - **Example Flow**: Request PageNumber=0 → Process results → Increment PageNumber → Repeat until empty `[]` response
 *
 * **Pagination Detection:**
 * - **End of data detection**: Continue requesting pages until you receive an empty array `[]`
 * - **No metadata provided**: Response does not include total counts, page counts, or hasNextPage indicators
 * - **Sequential access**: Increment PageNumber from 0 until empty response indicates no more data
 *
 * **Filtering Options:**
 * - **FromDateCreated**: Optional date parameter to filter orders created after specific date
 * - **ToDateCreated**: Optional date parameter to filter orders created before specific date
 * - **PurchaseOrderId**: Optional integer parameter to retrieve specific purchase order
 * - **IncludeItemDetails**: Optional boolean to include detailed line item information
 *
 * **Purchase Order Information Included:**
 * - **Order Details**: Purchase order identification, status, and vendor information
 * - **Line Items**: Product details and quantities (when IncludeItemDetails is true)
 * - **Dates**: Creation, modification, and expected delivery dates
 * - **Financial Data**: Order totals, costs, and payment information
 *
 * **Common Use Cases:**
 * - Display purchase orders for procurement management and vendor tracking
 * - Filter orders by date ranges for reporting and analysis
 * - Retrieve specific purchase orders for detailed review and management
 * - Support vendor relationship management and procurement workflows
 * - Generate procurement reports and purchase order analytics
 *
 * **Performance & Limits:**
 * - Use consistent page size throughout pagination sequence for efficiency
 * - Monitor response times and adjust page size for optimal performance
 * - Cache results locally to minimize API calls and improve responsiveness
 * - Validation performed on all query parameters before processing
 * - Optimized for procurement management and vendor tracking workflows
 *
 * **Related Endpoints:**
 * - `POST /purchase-order` - Create or update purchase orders
 * - `GET /vendors` - View vendors associated with purchase orders
 * - `GET /inventory` - View inventory levels for procurement planning
 *
 * **Important Notes:**
 * - **Procurement Integration**: Essential for vendor management and procurement workflows
 * - **Flexible Filtering**: Multiple parameters can be combined for precise order lookup
 * - **Location Scoped**: Purchase orders filtered to authenticated location operations
 * - **Validation Required**: All query parameters validated before purchase order retrieval
 */
export const purchaseOrderGet = <ThrowOnError extends boolean = false>(options?: Options<PurchaseOrderGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<PurchaseOrderGetResponses, PurchaseOrderGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/purchase-order',
        ...options
    });
};

/**
 * Create or Update Purchase Orders
 * **Purpose:** Create new purchase orders or update existing purchase orders for procurement management and vendor relationship operations.
 *
 * **Request Requirements:**
 * - "PurchaseOrder" role authorization required for purchase order modification
 * - `CreateUpdatePurchaseOrdersRequest` object in request body with purchase order details
 * - Content-Type: application/json
 * - Purchase order management permissions for procurement operations
 *
 * **Response Data:**
 * - Returns result object with purchase order creation/update status
 * - Response format: `{ "createdPurchaseOrderIds": [int, ...], "updatedPurchaseOrderIds": [int, ...] }`
 * - Includes arrays of created and updated purchase order IDs
 * - Purchase order identification and processing results
 *
 * **Create vs Update Behavior:**
 * - **CREATE**: When PurchaseOrderId is null, a new purchase order will be created
 * - **UPDATE**: When PurchaseOrderId is non-null, the existing purchase order will be updated
 * - **Identification**: Purchase order existence determined by PurchaseOrderId value
 * - **Line Item Updates**: Updates affect both purchase order header and line item details
 *
 * **Purchase Order Data Fields:**
 * - **Header Information**: Vendor details, order dates, and procurement specifications
 * - **Line Items**: Product details, quantities, costs, and delivery requirements
 * - **Financial Data**: Order totals, taxes, and payment terms
 * - **Status Information**: Order status and processing workflow details
 *
 * **Common Use Cases:**
 * - Create new purchase orders for vendor procurement operations
 * - Update existing purchase orders with revised quantities or specifications
 * - Modify purchase order line items for procurement adjustments
 * - Support vendor relationship management and procurement workflows
 * - Maintain accurate procurement records and vendor tracking
 *
 * **Performance & Limits:**
 * - Validation performed before any purchase order processing
 * - Batch processing for multiple purchase order operations
 * - Optimized for procurement management and vendor tracking workflows
 * - Changes reflected immediately in procurement and vendor systems
 *
 * **Related Endpoints:**
 * - `GET /purchase-order` - Retrieve purchase orders for review before updates
 * - `GET /vendors` - View vendors for purchase order creation
 * - `GET /inventory` - Check inventory levels for procurement planning
 *
 * **Important Notes:**
 * - **Validation Critical**: All purchase order data validated before processing
 * - **Procurement Integration**: Purchase orders affect vendor management and procurement workflows
 * - **Location Scoped**: Purchase orders automatically associated with authenticated location
 * - **Batch Processing**: Multiple purchase orders can be processed in single operation
 * - **Vendor Relationships**: Purchase order creation strengthens vendor tracking and management
 */
export const purchaseOrderPost = <ThrowOnError extends boolean = false>(options?: Options<PurchaseOrderPostData, ThrowOnError>) => {
    return (options?.client ?? client).post<PurchaseOrderPostResponses, PurchaseOrderPostErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/purchase-order',
        ...options,
        headers: {
            'Content-Type': 'application/json-patch+json',
            ...options?.headers
        }
    });
};

/**
 * Get Units
 * **Purpose:** Retrieves the complete list of measurement units available for product tracking and inventory management.
 *
 * **Request Requirements:**
 * - Any authenticated role authorization (no specific role required)
 * - No query parameters or request body needed
 *
 * **Response Data:**
 * - Returns array of unit objects: `[{ Unit }, ...]`
 * - Array typically contains 20-30 measurement units
 * - Returns empty array `[]` if no units configured (rare)
 * - Includes unit ID, name, abbreviation, and conversion factors
 * - Standard measurement units (grams, ounces, pounds, units, etc.)
 * - Essential reference data for product weight and quantity tracking
 *
 * **Common Use Cases:**
 * - Configure product measurement units in inventory systems
 * - Support weight-based pricing and inventory calculations
 * - Validate unit measurements in product and package operations
 * - Generate reports with proper unit conversions and formatting
 * - Enable accurate compliance reporting with regulatory weight requirements
 *
 * **Performance & Limits:**
 * - Lightweight reference data optimized for frequent access
 * - Small static dataset suitable for client-side caching
 * - No pagination needed due to limited number of standard units
 * - Consistent across all organizations and locations
 *
 * **Related Endpoints:**
 * - `GET /reference/unit-types` - Get unit type classifications
 * - `GET /products` - Get products with unit measurements
 * - `GET /inventory` - Get inventory with unit-based quantities
 *
 * **Important Notes:**
 * - Standard cannabis industry measurement units for compliance
 * - Essential for accurate weight tracking and regulatory reporting
 * - Used throughout the system for product and inventory operations
 * - Supports both metric and imperial measurement systems
 */
export const referenceUnitsGet = <ThrowOnError extends boolean = false>(options?: Options<ReferenceUnitsGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<ReferenceUnitsGetResponses, ReferenceUnitsGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/reference/units',
        ...options
    });
};

/**
 * Get Unit Types
 * **Purpose:** Retrieves the complete list of unit type classifications used to categorize different measurement units.
 *
 * **Request Requirements:**
 * - Any authenticated role authorization (no specific role required)
 * - No query parameters or request body needed
 *
 * **Response Data:**
 * - Returns array of unit type objects: `[{ UnitType }, ...]`
 * - Array typically contains 5-10 unit type categories
 * - Returns empty array `[]` if no unit types configured (rare)
 * - Includes type ID, name, and category descriptions
 * - Unit type categories (Weight, Volume, Count, etc.) for measurement classification
 * - Reference data for organizing units by measurement type
 *
 * **Common Use Cases:**
 * - Organize units by measurement type in user interfaces
 * - Validate unit assignments based on product type requirements
 * - Support advanced filtering and categorization of measurement units
 * - Enable proper unit selection based on product characteristics
 * - Generate reports organized by measurement type categories
 *
 * **Performance & Limits:**
 * - Lightweight reference data optimized for frequent access
 * - Small static dataset suitable for client-side caching
 * - No pagination needed due to limited number of unit types
 * - Consistent across all organizations and locations
 *
 * **Related Endpoints:**
 * - `GET /reference/units` - Get specific units within these types
 * - `GET /products` - Get products using typed unit measurements
 * - `GET /inventory` - Get inventory with type-based unit tracking
 *
 * **Important Notes:**
 * - Standard measurement type categories for consistent classification
 * - Helps organize units for better user experience and validation
 * - Used for advanced unit selection and validation logic
 * - Essential for proper measurement type categorization
 */
export const referenceUnitTypesGet = <ThrowOnError extends boolean = false>(options?: Options<ReferenceUnitTypesGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<ReferenceUnitTypesGetResponses, ReferenceUnitTypesGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/reference/unit-types',
        ...options
    });
};

/**
 * Get Lab Result Units
 * **Purpose:** Retrieves the complete list of measurement units specifically used for laboratory test results and cannabinoid/terpene reporting.
 *
 * **Request Requirements:**
 * - Any authenticated role authorization (no specific role required)
 * - No query parameters or request body needed
 *
 * **Response Data:**
 * - Returns array of lab result unit objects: `[{ LabResultUnitData }, ...]`
 * - Array typically contains 5-15 specialized lab measurement units
 * - Returns empty array `[]` if no lab units configured (rare)
 * - Includes lab result unit ID and unit name/abbreviation
 * - Specialized units for cannabinoid and terpene concentration measurements
 * - Essential reference data for laboratory test result reporting
 *
 * **Common Use Cases:**
 * - Configure lab result units in testing and compliance systems
 * - Validate unit measurements in laboratory data submissions
 * - Support cannabinoid and terpene concentration reporting
 * - Generate compliance reports with proper lab result unit formatting
 * - Enable accurate potency testing and COA (Certificate of Analysis) generation
 *
 * **Performance & Limits:**
 * - Lightweight reference data optimized for frequent access
 * - Small static dataset suitable for client-side caching
 * - No pagination needed due to limited number of lab result units
 * - Consistent across all organizations and locations
 *
 * **Related Endpoints:**
 * - `GET /reference/lab-results-names` - Get available lab result names
 * - `GET /reference/units` - Get general measurement units
 * - Lab result POST endpoints (for submitting test data)
 *
 * **Important Notes:**
 * - Specialized units for cannabis laboratory testing and analysis
 * - Essential for compliance with cannabis testing regulations
 * - Used specifically for cannabinoid and terpene concentration measurements
 * - Required for accurate Certificate of Analysis (COA) reporting
 * - Different from general product measurement units
 */
export const referenceLabResultUnitsGet = <ThrowOnError extends boolean = false>(options?: Options<ReferenceLabResultUnitsGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<ReferenceLabResultUnitsGetResponses, ReferenceLabResultUnitsGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/reference/lab-result-units',
        ...options
    });
};

/**
 * Get Lab Result Names
 * **Purpose:** Retrieves the complete list of available lab result names that can be used with lab result POST endpoints for cannabinoid and terpene testing.
 *
 * **Request Requirements:**
 * - Any authenticated role authorization (no specific role required)
 * - No query parameters or request body needed
 *
 * **Response Data:**
 * - Returns array of strings with valid lab result names: `["string", ...]`
 * - Array typically contains 50-100 cannabinoid and terpene names
 * - Returns empty array `[]` if no lab result names configured (rare)
 * - Standard cannabinoid names (THC, CBD, CBG, CBN, etc.)
 * - Common terpene names (Myrcene, Limonene, Pinene, etc.)
 * - All acceptable values for lab result name validation
 *
 * **Common Use Cases:**
 * - Validate lab result names before submitting test data
 * - Populate dropdown lists for lab result entry forms
 * - Reference data for cannabinoid and terpene testing workflows
 * - Support laboratory data integration and validation
 * - Generate dynamic forms for Certificate of Analysis (COA) entry
 *
 * **Performance & Limits:**
 * - Lightweight reference data optimized for frequent access
 * - Static dataset suitable for client-side caching
 * - No pagination needed due to manageable list size
 * - Consistent across all organizations and locations
 *
 * **Related Endpoints:**
 * - `GET /reference/lab-result-units` - Get valid units for these results
 * - Lab result POST endpoints - Submit test data using these names
 * - `GET /products` - Get products with lab result data
 *
 * **Important Notes:**
 * - These are the only valid values accepted for lab result names
 * - Standard cannabis testing terminology for consistency
 * - Essential for proper cannabinoid and terpene data submission
 * - Used throughout the system for lab result validation
 * - Required for compliance with cannabis testing standards
 */
export const referenceLabResultsNamesGet = <ThrowOnError extends boolean = false>(options?: Options<ReferenceLabResultsNamesGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<ReferenceLabResultsNamesGetResponses, ReferenceLabResultsNamesGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/reference/lab-results-names',
        ...options
    });
};

/**
 * Get Regulatory Categories
 * **Purpose:** Retrieves the complete list of regulatory categories available for the authenticated location for compliance reporting and state-mandated product classification.
 *
 * **Request Requirements:**
 * - Any authenticated role authorization (no specific role required)
 * - No query parameters or request body needed
 *
 * **Response Data:**
 * - Returns array of regulatory category objects: `[{ RegulatoryCategory }, ...]`
 * - Array typically contains 5-20 regulatory categories per jurisdiction
 * - Returns empty array `[]` if no regulatory categories configured (rare)
 * - Includes category ID, name, and state-specific compliance codes
 * - State-mandated product categories for regulatory reporting (varies by jurisdiction)
 * - Results filtered to authenticated location's regulatory requirements
 *
 * **Common Use Cases:**
 * - Validate product regulatory classification for compliance reporting
 * - Generate state-mandated reports with proper category classifications
 * - Ensure product data meets regulatory requirements for each jurisdiction
 * - Support track-and-trace system integration with proper categorization
 * - Populate regulatory category fields in product management systems
 *
 * **Performance & Limits:**
 * - Lightweight reference data optimized for frequent access
 * - Small dataset specific to location's regulatory jurisdiction
 * - No pagination needed due to limited number of regulatory categories
 * - Results may vary by location based on state/local regulations
 *
 * **Related Endpoints:**
 * - `GET /product-category` - Get general product categories
 * - `GET /products` - Get products with regulatory category assignments
 * - `POST /product` - Create products with regulatory category classifications
 *
 * **Important Notes:**
 * - Categories are specific to location's regulatory jurisdiction
 * - Required for compliance with state cannabis regulations
 * - Essential for accurate track-and-trace system reporting
 * - Category requirements may change based on evolving regulations
 * - Used for state-mandated reporting and audit compliance
 */
export const regulatoryCategoryGet = <ThrowOnError extends boolean = false>(options?: Options<RegulatoryCategoryGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<RegulatoryCategoryGetResponses, RegulatoryCategoryGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/regulatory-category',
        ...options
    });
};

export const reportingInventoryGet = <ThrowOnError extends boolean = false>(options?: Options<ReportingInventoryGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<ReportingInventoryGetResponses, ReportingInventoryGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/reporting/inventory',
        ...options
    });
};

/**
 * Transactions List
 * Retrieves POS and Wholesale transaction(s) from the provided dates and/or transactionId.
 *
 * The use of transactionId, to/from transaction date, and to/from last modified date are mutually exclusive.
 * Providing more than one will result in a validation error.
 *
 * **Performance & Limits:**
 * - Rate limited to 600 requests per minute (higher limit for frequently accessed transaction data)
 * - Optimized for transaction reporting and financial analysis workflows
 * - Use date range filtering to limit result size for better performance
 */
export const reportingTransactionsGet = <ThrowOnError extends boolean = false>(options?: Options<ReportingTransactionsGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<ReportingTransactionsGetResponses, ReportingTransactionsGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/reporting/transactions',
        ...options
    });
};

/**
 * Customers List (Reporting)
 * **Purpose:** Retrieves a comprehensive list of wholesale and POS customers optimized for reporting and analytics.
 *
 * **Request Requirements:**
 * - "Reporting" role authorization required for analytics data access
 * - Optional UTC date parameters for filtering
 * - No request body needed
 *
 * **Response Data:**
 * - Response format: `[{ Customer }, { Customer }, ...]`
 * - Array of `Customer` objects with complete customer information
 * - Includes primary and secondary qualifying conditions for medical customers
 * - Contains customer profile data, contact information, and preferences
 * - Results are automatically filtered by the authenticated location
 *
 * **How This Differs from `/customer/customers`:**
 * - Requires "Reporting" role instead of "Customer" role authorization
 * - Optimized for reporting and analytics rather than operational management
 * - Returns ALL customers for comprehensive reporting purposes
 * - Enhanced date range filtering designed for reporting workflows
 * - Performance tuned for bulk data export and analysis
 *
 * **Common Use Cases:**
 * - Generate comprehensive customer reports and analytics
 * - Export customer data for external systems or compliance requirements
 * - Synchronize customer changes with external databases using incremental sync
 * - Review customer records for regulatory compliance audits
 * - Analyze customer demographics and behavior patterns for marketing
 *
 * **Performance & Limits:**
 * - Rate limited to 600 requests per minute (higher limit for frequently accessed reporting data)
 * - Use date range filtering to limit result size for better performance
 * - Consider using `/reporting/customers-paginated` for very large datasets
 * - Cache results locally and use incremental sync for regular updates
 * - May return large datasets as it includes ALL customer types
 *
 * **Related Endpoints:**
 * - `GET /reporting/customers-paginated` - Paginated version for large datasets
 * - `GET /customer/customers` - Operational customer management endpoint
 *
 * **Important Notes:**
 * - This endpoint returns ALL customers (wholesale and POS) and may return large datasets
 * - Requires reporting authorization role for access
 * - Use date filtering to improve performance with large customer bases
 */
export const reportingCustomersGet = <ThrowOnError extends boolean = false>(options?: Options<ReportingCustomersGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<ReportingCustomersGetResponses, ReportingCustomersGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/reporting/customers',
        ...options
    });
};

/**
 * Get Customers (Paginated, Reporting)
 * **Purpose:** Retrieve paginated customer data optimized for reporting and analytics with enhanced performance for large-scale customer analysis.
 *
 * **Request Requirements:**
 * - "Reporting" role authorization required for analytics data access
 * - Optional query parameters for filtering and pagination control
 * - No request body needed
 * - Maximum page size of 10,000 customers for optimal performance
 *
 * **Response Data:**
 * - Response format: `[{ Customer }, { Customer }, ...]`
 * - Returns array of `Customer` objects for the requested page
 * - Array contains up to PageSize customers (default 1000, max 10,000)
 * - Returns empty array `[]` if no customers match criteria for the page (not null)
 * - **No pagination metadata**: Response contains only customer data without total counts or page information
 * - Includes primary and secondary qualifying conditions for medical customers
 * - Contains customer profile data, contact information, and preferences
 * - Results automatically filtered to authenticated location
 *
 * **Pagination Usage:**
 * - **First Request**: Call with PageNumber=0 to get first page
 * - **Subsequent Requests**: Increment PageNumber for each additional page
 * - **End Detection**: Continue requesting pages until you receive an empty array `[]`
 * - **Page Size Control**: Use PageSize parameter to control items per page (max 10,000)
 * - **Example Flow**: Request PageNumber=0 → Process results → Increment PageNumber → Repeat until empty `[]` response
 *
 * **Key Differences from `/customer/customers-paginated`:**
 * - **Authorization**: Requires "Reporting" role vs "Customer" role
 * - **Purpose**: Optimized for reporting and analytics vs operational customer management
 * - **Page Size**: Higher maximum page size limits for bulk reporting
 * - **Profile Sharing**: Enhanced customer profile sharing logic for reporting
 * - **Performance**: Designed for large-scale data export and analysis
 *
 * **Filtering Options:**
 * - fromLastModifiedDateUTC: Returns customers modified after this date (incremental sync)
 * - toLastModifiedDateUTC: Returns customers modified before this date (date range filtering)
 * - includeAnonymous: Include anonymous customers in results (default: true)
 *
 * **Common Use Cases:**
 * - Handle thousands of customers efficiently with paginated processing
 * - Process customers in manageable chunks for batch operations
 * - Avoid loading entire customer base at once for memory-conscious applications
 * - Stream customer data for live reporting dashboards and analytics
 * - Transfer customer data between systems in controlled batches
 *
 * **Performance & Limits:**
 * - Maximum 10,000 customers per page for optimal performance
 * - Start with PageNumber=0 and increment until no more data available
 * - Use consistent PageSize throughout pagination sequence for efficiency
 * - Monitor response times and adjust PageSize for optimal performance
 * - Cache results locally to minimize API calls and improve responsiveness
 *
 * **Pagination Detection:**
 * - **End of data detection**: Continue requesting pages until you receive an empty array `[]`
 * - **No metadata provided**: Response does not include total counts, page counts, or hasNextPage indicators
 * - **Sequential access**: Increment PageNumber from 0 until empty response indicates no more data
 *
 * **Related Endpoints:**
 * - `GET /reporting/customers` - Non-paginated version for smaller datasets
 * - `GET /customer/customers` - Operational customer management endpoint
 *
 * **Important Notes:**
 * - **Pagination Required**: Large customer bases require multiple page requests
 * - **Enhanced Profile Logic**: Uses advanced customer profile sharing based on LSP configuration
 * - **Reporting Optimized**: Designed for analytics and large-scale data processing
 * - **Location Scoped**: Results automatically filtered to authenticated location
 * - **Page Size Validation**: Requests exceeding 10,000 customers per page will be rejected
 */
export const reportingCustomersPaginatedGet = <ThrowOnError extends boolean = false>(options?: Options<ReportingCustomersPaginatedGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<ReportingCustomersPaginatedGetResponses, ReportingCustomersPaginatedGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/reporting/customers-paginated',
        ...options
    });
};

/**
 * Get Register Adjustments
 * **Purpose:** Retrieve register adjustment transactions for cash management and reconciliation reporting with detailed audit trail information.
 *
 * **Request Requirements:**
 * - "Reporting" role authorization required for financial data access
 * - Optional query parameters for date range filtering
 * - No request body needed
 *
 * **Response Data:**
 * - Response format: `[{ RegisterAdjustment }, { RegisterAdjustment }, ...]`
 * - Returns array of `RegisterAdjustment` objects with detailed transaction information
 * - Array may contain 0 to 1,000+ adjustments depending on date range and activity
 * - Returns empty array `[]` if no adjustments match criteria (not null)
 * - Includes adjustment amounts, types, timestamps, and employee information
 * - Contains reason codes and descriptions for each adjustment
 * - Results automatically filtered to authenticated location
 *
 * **Transaction Types Included:**
 * - **Adjustments**: Manual cash register corrections and balancing entries
 * - **Close Outs**: End-of-shift register closing transactions
 * - **Deposits**: Cash deposits made to the register
 * - **Withdrawals**: Cash withdrawals from the register
 * - **Cash Drops**: Safe drops and cash removal transactions
 *
 * **Filtering Options:**
 * - fromLastModifiedDateUTC: Returns adjustments modified after this date (incremental sync)
 * - toLastModifiedDateUTC: Returns adjustments modified before this date (date range filtering)
 *
 * **Common Use Cases:**
 * - Track all register cash movements for balancing and reconciliation
 * - Maintain detailed records of cash handling activities for audit trails
 * - Generate end-of-shift cash management summaries and reports
 * - Document cash handling for regulatory requirements and compliance
 * - Analyze cash flow patterns and adjustment trends for financial analysis
 * - Monitor unusual adjustment patterns or discrepancies for loss prevention
 *
 * **Performance & Limits:**
 * - Use date range filtering to limit results to specific time periods for optimal performance
 * - Combine with cash-summary endpoint for comprehensive cash reporting
 * - Cache results locally and use incremental sync for regular updates
 * - Optimized for financial reconciliation and audit trail workflows
 *
 * **Related Endpoints:**
 * - `GET /reporting/register-transactions` - Complete register activity including sales
 * - `GET /reporting/cash-summary` - Comprehensive cash reporting and summaries
 * - `GET /reporting/closing-report` - Financial closing reports with cash details
 *
 * **Important Notes:**
 * - **Adjustment Focus**: This endpoint focuses specifically on register adjustments only
 * - **Complete Activity**: For complete register activity including sales, use register-transactions
 * - **Audit Trail**: Maintains detailed records of all cash handling activities
 * - **Location Scoped**: Results automatically filtered to authenticated location
 * - **Employee Tracking**: Includes employee information for accountability and audit purposes
 */
export const reportingRegisterAdjustmentsGet = <ThrowOnError extends boolean = false>(options?: Options<ReportingRegisterAdjustmentsGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<ReportingRegisterAdjustmentsGetResponses, ReportingRegisterAdjustmentsGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/reporting/register-adjustments',
        ...options
    });
};

/**
 * Get Register Transactions (Comprehensive Transaction History)
 * **Purpose:** Retrieve comprehensive register transaction history including sales, adjustments, cash management, and operational activities for complete financial reporting.
 *
 * **Request Requirements:**
 * - "Reporting" role authorization required for financial transaction data access
 * - Optional query parameters for date range filtering
 * - No request body needed
 *
 * **Response Data:**
 * - Response format: `[{ RegisterTransaction }, { RegisterTransaction }, ...]`
 * - Returns array of `RegisterTransaction` objects with comprehensive transaction data
 * - Array may contain 0 to 50,000+ transactions depending on date range and business volume
 * - Returns empty array `[]` if no transactions match criteria (not null)
 * - Includes financial details, customer information, product details, and employee tracking
 * - Complete audit trail with timestamps, register context, and status information
 * - Results automatically filtered to authenticated location
 *
 * **Transaction Types Included:**
 * - **Sales Transactions**: Completed customer purchases and returns
 * - **Register Adjustments**: Manual cash corrections and balance adjustments
 * - **Cash Management**: Deposits, withdrawals, cash drops, and till operations
 * - **Register Close-Outs**: End-of-shift register balancing and reconciliation
 * - **Payment Processing**: Credit card, cash, and other payment method transactions
 * - **Operational Activities**: Register opening, closing, and maintenance operations
 *
 * **Transaction Data Returned:**
 * - **Financial Details**: Transaction amounts, payment methods, taxes, and fees
 * - **Customer Information**: Customer IDs, types, and transaction associations
 * - **Product Details**: Items sold, quantities, prices, and categories
 * - **Employee Tracking**: Staff members who processed transactions
 * - **Timestamps**: Creation, modification, and completion times
 * - **Register Context**: Terminal/register identification and session information
 * - **Status Information**: Transaction status, voiding, and modification history
 *
 * **Filtering Options:**
 * - fromLastModifiedDateUTC: Returns transactions modified after this date (incremental sync)
 * - toLastModifiedDateUTC: Returns transactions modified before this date (date range filtering)
 *
 * **Common Use Cases:**
 * - Balance daily sales across all registers and payment methods for financial reconciliation
 * - Generate comprehensive revenue reports and analytics for sales reporting
 * - Maintain detailed transaction records for compliance and audit preparation
 * - Track all cash movements and register balancing activities for cash management
 * - Analyze sales patterns, employee performance, and business trends for performance analysis
 * - Extract detailed tax information for regulatory compliance and tax reporting
 * - Monitor transaction patterns for unusual activities and fraud prevention
 *
 * **Performance & Limits:**
 * - Large datasets: This endpoint can return substantial amounts of transaction data
 * - Use date range filtering to limit results for better performance
 * - Use fromLastModifiedDateUTC for regular data synchronization and incremental sync
 * - Schedule large data exports during low-traffic periods for optimal performance
 * - Optimized for comprehensive financial reporting and audit trail requirements
 *
 * **Related Endpoints:**
 * - `GET /reporting/register-adjustments` - Cash adjustments and corrections only
 * - `GET /reporting/closing-report` - Summary financial reports for specific date ranges
 * - `GET /reporting/cash-summary` - Cash-specific summaries and balancing information
 *
 * **Important Notes:**
 * - **Comprehensive Data**: Returns ALL register activities, resulting in potentially large datasets
 * - **Real-Time Updates**: Transaction data reflects current state and may include recent modifications
 * - **Location Scoped**: Results automatically filtered to authenticated dispensary location
 * - **Historical Accuracy**: Maintains complete audit trail for all register operations
 * - **Complete Activity**: This is the most comprehensive endpoint for all register transaction types
 */
export const reportingRegisterTransactionsGet = <ThrowOnError extends boolean = false>(options?: Options<ReportingRegisterTransactionsGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<ReportingRegisterTransactionsGetResponses, ReportingRegisterTransactionsGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/reporting/register-transactions',
        ...options
    });
};

/**
 * Get Cash Summary (Real-time Register Activity)
 * **Purpose:** Retrieve real-time register cash activity summary with comprehensive financial reconciliation data for cash management and balancing.
 *
 * **Request Requirements:**
 * - "Reporting" role authorization required for financial data access
 * - Optional query parameters for date range filtering
 * - Date range must be within the last 7 days for optimal performance
 * - No request body needed
 *
 * **Response Data:**
 * - Response format: `[{ RegisterCashSummary }, { RegisterCashSummary }, ...]`
 * - Returns array of `RegisterCashSummary` objects with detailed cash flow information
 * - Array may contain 1-50+ register summaries depending on number of active registers
 * - Returns empty array `[]` if no cash activity matches criteria (not null)
 * - Real-time data reflecting current register status and activities
 * - Includes variance calculations and reconciliation details
 * - Results automatically filtered to authenticated location
 *
 * **Summary Data Included:**
 * - **Starting Balance**: Register opening cash amount for the period
 * - **Ending Balance**: Current or closing register cash amount
 * - **Sales**: Total cash sales transactions processed
 * - **Returns**: Cash refunds and return transactions
 * - **Deposits**: Cash deposits added to the register
 * - **Adjustments**: Manual cash corrections and modifications
 * - **Over/Short**: Cash variance from expected amounts
 *
 * **Filtering Options:**
 * - fromLastModifiedDateUTC: Returns activity after this date (incremental sync, within 7 days)
 * - toLastModifiedDateUTC: Returns activity before this date (date range filtering)
 *
 * **Common Use Cases:**
 * - Track current register cash status throughout the day for real-time monitoring
 * - Balance register cash at shift changes for reconciliation
 * - Generate end-of-day cash summaries for closing procedures
 * - Identify and investigate cash discrepancies for variance analysis
 * - Create comprehensive cash flow reports for financial reporting
 * - Maintain detailed cash handling records for audit preparation
 *
 * **Performance & Limits:**
 * - Rate limited to 480 requests per minute (higher limit for frequent cash monitoring)
 * - Date range restriction: fromLastModifiedDateUTC must be within the last 7 days
 * - Use recent date ranges (within 7 days) for fastest response times
 * - Combine with register-adjustments endpoint for detailed transaction breakdown
 * - Cache results and refresh periodically for dashboard applications
 * - Optimized for real-time cash monitoring and reconciliation workflows
 *
 * **Related Endpoints:**
 * - `GET /reporting/register-adjustments` - Detailed transaction breakdown
 * - `GET /reporting/register-transactions` - Complete register transaction history
 * - `GET /reporting/closing-report` - Comprehensive financial closing reports
 *
 * **Important Notes:**
 * - **Real-time Data**: Provides real-time data and may show different results than historical reports during active business hours
 * - **7-Day Limit**: Date filtering restricted to last 7 days for optimal performance
 * - **Active Business Hours**: Results may vary during active operations due to real-time updates
 * - **Location Scoped**: Results automatically filtered to authenticated location
 * - **Variance Tracking**: Includes over/short calculations for cash discrepancy identification
 */
export const reportingCashSummaryGet = <ThrowOnError extends boolean = false>(options?: Options<ReportingCashSummaryGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<ReportingCashSummaryGetResponses, ReportingCashSummaryGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/reporting/cash-summary',
        ...options
    });
};

/**
 * Get Loyalty Balance Snapshot (Daily)
 * **Purpose:** Retrieve current loyalty point balances for all customers with nightly batch processing for comprehensive loyalty program reporting and analysis.
 *
 * **Request Requirements:**
 * - "Reporting" role authorization required for loyalty data access
 * - No query parameters required
 * - No request body needed
 * - Rate limited to 1 request per minute for system protection
 *
 * **Response Data:**
 * - Response format: `[{ LoyaltySnapshot }, { LoyaltySnapshot }, ...]`
 * - Returns array of `LoyaltySnapshot` objects with customer loyalty information
 * - Array typically contains 100-10,000+ customers depending on loyalty program participation
 * - Returns empty array `[]` if no customers have loyalty activity (not null)
 * - Includes current point balances, loyalty tier information, and customer identifiers
 * - Contains earned points, redeemed points, and available balance details
 * - Results automatically filtered to authenticated location
 *
 * **Data Characteristics:**
 * - **Update Frequency**: Nightly batch processing (updated once per day)
 * - **Data Freshness**: Reflects loyalty activity through the previous business day
 * - **Scope**: All customers with loyalty program participation
 * - **Balance Types**: Current available points, earned points, redeemed points
 * - **Configuration**: Uses either loyalty ledger service or database depending on system configuration
 *
 * **Common Use Cases:**
 * - Generate end-of-day loyalty summaries for daily loyalty reports
 * - Check customer loyalty balances and history for customer service
 * - Identify customers by loyalty tier or balance ranges for marketing campaigns
 * - Document loyalty program activity for audits and compliance reporting
 * - Export loyalty data to external systems for data synchronization
 * - Analyze loyalty program engagement and effectiveness for analytics
 *
 * **Consumption Guidelines:**
 * - **Recommended Frequency**: Once per day (after nightly processing completes)
 * - **Optimal Timing**: Early morning hours after batch processing
 * - **Caching Strategy**: Cache results for 24 hours, refresh daily
 *
 * **Performance & Limits:**
 * - Rate limited to 1 request per minute for system protection
 * - Schedule automated calls during off-peak hours for optimal performance
 * - Cache results locally to avoid repeated calls within the same day
 * - Use for batch processing rather than real-time customer lookups
 * - Optimized for daily loyalty program management and reporting workflows
 *
 * **Related Endpoints:**
 * - `GET /reporting/customer-loyalty-snapshot` - Individual customer loyalty data
 * - `GET /reporting/loyalty-transactions-paginated` - Detailed loyalty transaction history
 * - `GET /reporting/national-loyalty-snapshot-paginated` - Cross-organization loyalty data
 *
 * **Important Notes:**
 * - **Snapshot Data**: This is a snapshot of loyalty balances as of the last nightly processing
 * - **Real-time Alternative**: For real-time loyalty transactions, use other loyalty endpoints
 * - **Nightly Processing**: Data reflects activity through the previous business day
 * - **Location Scoped**: Results filtered to authenticated location loyalty participants
 * - **Rate Limited**: Maximum 1 request per minute to protect system resources
 */
export const reportingLoyaltySnapshotGet = <ThrowOnError extends boolean = false>(options?: Options<ReportingLoyaltySnapshotGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<ReportingLoyaltySnapshotGetResponses, ReportingLoyaltySnapshotGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/reporting/loyalty-snapshot',
        ...options
    });
};

/**
 * Get Products (Master List, Reporting)
 * **Purpose:** Retrieve the complete product master list with comprehensive product data for reporting and analytics, including all products regardless of API or online availability settings.
 *
 * **Request Requirements:**
 * - "Reporting" role authorization required for comprehensive product data access
 * - Optional query parameters for incremental sync filtering
 * - No request body needed
 *
 * **Response Data:**
 * - Response format: `[{ ProductDetail }, { ProductDetail }, ...]`
 * - Returns array of `ProductDetail` objects with complete product information
 * - Array typically contains 100-50,000+ products depending on catalog size
 * - Returns empty array `[]` if no products exist or match criteria (not null)
 * - Includes ALL products in the system (active and inactive)
 * - Contains pricing, categories, strains, lab results, and inventory data
 * - Results automatically filtered to authenticated location
 *
 * **Key Differences from `/products`:**
 * - **No API Access Filter**: Returns ALL products, not just those enabled for API access
 * - **No Online Filter**: Ignores online availability settings used by standard products endpoint
 * - **Master Data Focus**: Designed for comprehensive product data exports and reporting
 * - **Complete Dataset**: Includes inactive and non-public products for complete catalog view
 *
 * **Filtering Options:**
 * - fromLastModifiedDateUTC: Returns products modified after this date (incremental sync)
 *
 * **Common Use Cases:**
 * - Get complete product catalog for analysis and comprehensive reporting
 * - Export all product data for external systems and data warehousing
 * - Review all products regardless of API/online settings for inventory audits
 * - Maintain complete product records for master data management
 * - Generate reports including all products for compliance reporting
 *
 * **When to Use This vs `/products`:**
 * - **Use `/reporting/products`**: For complete data exports, reporting, audits, and analytics
 * - **Use `/products`**: For e-commerce, POS integration, and customer-facing applications
 *
 * **Performance & Limits:**
 * - Large datasets: This endpoint can return substantial product catalogs
 * - Use fromLastModifiedDateUTC for incremental sync to optimize performance
 * - Optimized for comprehensive product reporting and analytics workflows
 * - Consider pagination for very large product catalogs (50,000+ products)
 *
 * **Related Endpoints:**
 * - `GET /products` - Customer-facing products with API and online filters
 * - `GET /inventory` - Product inventory levels and availability
 * - `GET /product-categories` - Product categorization data
 *
 * **Important Notes:**
 * - **Complete Dataset**: Returns ALL products, including those not intended for public API access or online sales
 * - **Master Data**: This is the authoritative source for complete product catalog data
 * - **Reporting Focus**: Designed for analytics and reporting rather than customer-facing operations
 * - **Location Scoped**: Results filtered to authenticated location product catalog
 * - **Incremental Sync**: Use date filtering for efficient data synchronization
 */
export const reportingProductsGet = <ThrowOnError extends boolean = false>(options?: Options<ReportingProductsGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<ReportingProductsGetResponses, ReportingProductsGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/reporting/products',
        ...options
    });
};

/**
 * Get Closing Report (Comprehensive Financial Summary)
 * **Purpose:** Retrieve comprehensive closing report with detailed financial summaries, payment breakdowns, and business analytics for specified date range reporting.
 *
 * **Request Requirements:**
 * - "Reporting" role authorization required for financial data access
 * - fromDateUTC and toDateUTC parameters required (both must be provided)
 * - Date range must be between 12 hours and 31 days maximum
 * - UTC datetime format required for all date parameters
 *
 * **Response Data:**
 * - Response format: `{ ClosingReport }` or `{ ClosingReportV2 }` (structure varies by system configuration)
 * - Returns `ClosingReport` or `ClosingReportV2` object with comprehensive financial data
 * - Single object containing multi-dimensional analysis across all business aspects
 * - Not an array - returns one comprehensive report object for the date range
 * - Multi-dimensional analysis across payment methods, customer types, and product categories
 * - Detailed tax calculations and compliance information
 * - Payment processor-specific data and settlement details
 * - Results automatically filtered to authenticated location
 *
 * **Date Range Restrictions:**
 * - **Maximum Range**: 31 days or less
 * - **Minimum Range**: Greater than 12 hours
 * - **Format**: UTC datetime values
 * - **Both Required**: fromDateUTC and toDateUTC must be provided
 *
 * **Report Sections Included:**
 * - **Payment Summary**: Breakdown by payment method (cash, card, etc.)
 * - **Customer Type Summary**: Sales analysis by customer categories
 * - **Category Summary**: Revenue breakdown by product categories
 * - **Tax Summary**: Detailed tax calculations and rates
 * - **Order Source Summary**: Sales by channel (online, in-store, etc.)
 * - **Order Type Summary**: Analysis by order types (delivery, pickup, etc.)
 * - **Fees & Donations**: Processing fees and charitable donations (when enabled)
 * - **Pay-by-Bank Details**: ACH transaction summaries and batch files (when enabled)
 *
 * **Response Version Determination:**
 * - Response structure varies based on internal system configuration
 * - **V1 (ClosingReport)**: Standard financial summaries without tips/fees
 * - **V2 (ClosingReportV2)**: Enhanced with tips, fees, and Pay-by-Bank details
 * - **API Consumer Guidance**: Both versions share common base fields, V2 extends V1 with additional properties
 * - **Breaking Change Protection**: V2 is additive-only (safe to parse as V1 and ignore extra fields)
 *
 * **Handling Variable Response Types:**
 * - **Recommended Approach**: Parse response for common fields first, then check for V2-specific properties
 * - **Common Base Properties**: All versions include PaymentSummary, CustomerTypeSummary, CategorySummary, TaxSummary
 * - **V2 Additional Properties**: TipsSummary, FeesSummary, PayByBankDetails (when present)
 *
 * **Common Use Cases:**
 * - Generate end-of-period financial summaries for daily/weekly closing
 * - Balance sales across all payment methods and channels for financial reconciliation
 * - Extract detailed tax information for compliance and tax reporting
 * - Analyze sales performance across multiple dimensions for business analytics
 * - Reconcile payment processor settlements for payment processing
 * - Generate comprehensive financial documentation for audit preparation
 *
 * **Performance & Limits:**
 * - This report processes large amounts of transactional data
 * - Longer date ranges may take additional time to generate
 * - Use shorter date ranges for faster processing
 * - Schedule report generation during off-peak hours for optimal performance
 * - Cache results for frequently accessed date ranges
 *
 * **Related Endpoints:**
 * - `GET /reporting/register-transactions` - Detailed transaction-level data
 * - `GET /reporting/cash-summary` - Cash-specific summaries
 * - `GET /reporting/register-adjustments` - Register adjustment details
 *
 * **Important Notes:**
 * - **Processing Intensive**: This report processes large amounts of transactional data
 * - **Date Range Validation**: Requests with invalid date ranges will be rejected
 * - **Comprehensive Data**: Includes all financial aspects of business operations
 * - **Location Scoped**: Results filtered to authenticated location financial data
 * - **Version Dependent**: Response object type depends on system configuration and features enabled
 */
export const reportingClosingReportGet = <ThrowOnError extends boolean = false>(options?: Options<ReportingClosingReportGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<ReportingClosingReportGetResponses, ReportingClosingReportGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/reporting/closing-report',
        ...options
    });
};

/**
 * Get Discounts (Complete Discount Configuration)
 * **Purpose:** Retrieve comprehensive discount configuration data for all discounts regardless of status, type, or activation state for promotional reporting and analysis.
 *
 * **Request Requirements:**
 * - "Reporting" role authorization required for discount configuration data access
 * - Optional query parameter for including deleted discounts
 * - No request body needed
 *
 * **Response Data:**
 * - Response format: `[{ ReportingDiscountDetail }, { ReportingDiscountDetail }, ...]`
 * - Returns array of `ReportingDiscountDetail` objects with complete discount configurations
 * - Array typically contains 5-500+ discounts depending on promotional activity
 * - Returns empty array `[]` if no discounts exist (not null)
 * - Includes all restriction types and eligibility criteria
 * - Contains scheduling and recurrence information
 * - Provides location-specific applicability data
 * - Results automatically filtered to authenticated location
 *
 * **Unique Endpoint:** This is the only discounts endpoint in the Public API - there is no parallel non-reporting version.
 *
 * **Filtering Options:**
 * - includeDeleted: Include deleted/archived discounts in results (default: false)
 *
 * **Discount Information Included:**
 * - **Basic Details**: Discount names, descriptions, and identifiers
 * - **Status Information**: Active/inactive status and deletion state
 * - **Type Classification**: Manual vs automatic discount types
 * - **Validity Periods**: Start and end dates (converted to UTC)
 * - **Discount Groups**: Associated discount group memberships
 * - **Product Restrictions**: Specific products eligible for the discount
 * - **Category Restrictions**: Product categories covered by the discount
 * - **Strain Restrictions**: Cannabis strain-specific discount rules
 * - **Brand Restrictions**: Brand-specific discount applications
 * - **Vendor Restrictions**: Vendor-specific discount configurations
 * - **Weekly Recurrence**: Recurring discount schedule information
 * - **Location Mapping**: Multi-location discount applicability
 *
 * **Common Use Cases:**
 * - Analyze discount effectiveness and usage patterns for discount analysis
 * - Export complete discount configurations for configuration backup
 * - Document promotional activities for regulatory review and compliance reporting
 * - Synchronize discount rules with external systems for system integration
 * - Review existing promotions for campaign planning and marketing planning
 * - Maintain comprehensive records of all promotional activities for audit preparation
 *
 * **Performance & Limits:**
 * - Use includeDeleted=false for active discount analysis to optimize performance
 * - Cache results locally as discount configurations change infrequently
 * - Process restriction arrays to understand discount eligibility logic
 * - Optimized for promotional reporting and marketing analysis workflows
 *
 * **Related Endpoints:**
 * - `GET /reporting/closing-report` - Financial impact of discount usage
 * - `GET /reporting/register-transactions` - Transaction-level discount application
 * - `GET /products` - Products eligible for discount restrictions
 *
 * **Important Notes:**
 * - **Complete Configuration**: Returns ALL discount configurations including inactive and deleted discounts when requested
 * - **Use Filtering**: Use includeDeleted parameter appropriately for your use case
 * - **UTC Conversion**: All validity periods are automatically converted to UTC
 * - **Location Scoped**: Results filtered to authenticated location discount configurations
 * - **Unique Endpoint**: This is the only public API endpoint for discount data access
 */
export const reportingDiscountsGet = <ThrowOnError extends boolean = false>(options?: Options<ReportingDiscountsGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<ReportingDiscountsGetResponses, ReportingDiscountsGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/reporting/discounts',
        ...options
    });
};

/**
 * Get Rooms
 * **Purpose:** Retrieve cultivation rooms and facility areas configured for the location to support cultivation operations and facility management.
 *
 * **Request Requirements:**
 * - "Room" role authorization required for room data access
 * - Optional filtering parameters available for specific room lookup
 * - Cultivation facility management permissions required
 *
 * **Response Data:**
 * - Returns array of `Room` objects with room identification and type information
 * - Array typically contains 5-50 rooms depending on cultivation facility size
 * - Returns empty array `[]` if no rooms match criteria (not null)
 * - Includes room identification, naming, and functional type flags
 * - Results automatically filtered to authenticated location
 *
 * **Filtering Options:**
 * - **roomId**: Optional integer parameter to retrieve specific room by ID
 * - **roomName**: Optional string parameter to search rooms by name
 * - **Combined Filtering**: Parameters can be used together for precise room lookup
 * - **No Filters**: Returns all rooms when no parameters provided
 *
 * **Room Information Included:**
 * - **RoomId**: Unique identifier for each cultivation room or facility area
 * - **RoomName**: Human-readable name for room identification and management
 * - **Location Information**: Facility location details (when integrator is Dutchie)
 * - **Room Type Flags**: Boolean flags indicating room functionality (IsQuarantineRoom, IsVaultRoom, IsSalesFloor, etc.)
 *
 * **Common Use Cases:**
 * - Populate room dropdown lists in cultivation management interfaces
 * - Display available rooms for plant placement and cultivation tracking
 * - Support cultivation facility room management and organization
 * - Enable room-specific cultivation tracking and environmental monitoring
 * - Facilitate cultivation workflow room assignments and plant movement
 *
 * **Performance & Limits:**
 * - Efficient room lookup optimized for cultivation facility workflows
 * - Optimized database queries for improved performance
 * - Flexible filtering for specific room management needs
 * - Results consistent across cultivation and facility management systems
 *
 * **Related Endpoints:**
 * - `POST /room` - Create or update room configuration
 * - `GET /plant` - View plants assigned to specific cultivation rooms
 * - `GET /harvest` - Track harvest operations by cultivation room
 *
 * **Important Notes:**
 * - **Cultivation Integration**: Essential for cultivation facility management and plant tracking
 * - **Location Specific**: Results filtered to authenticated location facility setup
 * - **Integrator Dependent**: Location information visibility controlled by integrator type
 * - **Cultivation Ready**: Room data used throughout cultivation tracking workflows
 */
export const roomRoomsGet = <ThrowOnError extends boolean = false>(options?: Options<RoomRoomsGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<RoomRoomsGetResponses, RoomRoomsGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/room/rooms',
        ...options
    });
};

/**
 * Create or Update Room
 * **Purpose:** Create a new cultivation room or update an existing room configuration for cultivation facility management and plant tracking operations.
 *
 * **Request Requirements:**
 * - "Room" role authorization required for room data modification
 * - `Room` object in request body with room configuration details
 * - Content-Type: application/json
 * - Cultivation facility management permissions required
 *
 * **Response Data:**
 * - Returns single `Room` object (not array) with updated room information
 * - Includes assigned RoomId for new rooms or updated ID for existing rooms
 * - Complete room information with all fields populated
 * - Room identification, naming, and type flag information
 *
 * **Create vs Update Behavior:**
 * - **CREATE**: When RoomId is null or 0, a new room record will be created
 * - **UPDATE**: When RoomId is provided with a valid room ID, the existing room will be updated
 * - **Identification**: Room existence determined by RoomId value
 * - **Automatic Detection**: System automatically determines create vs update based on RoomId
 *
 * **Room Data Fields:**
 * - **RoomId**: Unique identifier for room (null/0 for new rooms, specific ID for updates)
 * - **RoomName**: Human-readable name for room identification and cultivation tracking
 * - **Room Type Flags**: Boolean indicators for room functionality (IsQuarantineRoom, IsVaultRoom, etc.)
 *
 * **Common Use Cases:**
 * - Add new cultivation rooms to facility management system
 * - Update existing room names or configuration details
 * - Modify room setup for cultivation facility reorganization
 * - Create room assignments for cultivation tracking workflows
 * - Support cultivation facility expansion and room management
 *
 * **Performance & Limits:**
 * - Single room operation for targeted cultivation facility management
 * - Immediate room configuration update reflected in cultivation systems
 * - Optimized for cultivation facility management and plant tracking workflows
 * - Changes reflected immediately in room assignment and cultivation systems
 *
 * **Related Endpoints:**
 * - `GET /room/rooms` - Retrieve existing room configuration before updates
 * - `GET /plant` - View plants assigned to cultivation rooms
 * - `POST /plant/nonsts/update` - Update plant room assignments
 *
 * **Important Notes:**
 * - **RoomId Assignment**: New rooms receive automatically generated RoomId
 * - **Cultivation Integration**: Room configuration affects plant tracking and cultivation workflows
 * - **Location Scoped**: Rooms automatically associated with authenticated location
 * - **Cultivation Ready**: Room data immediately available for plant assignment operations
 * - **Facility Management**: Supports cultivation facility organization and room tracking
 */
export const roomPost = <ThrowOnError extends boolean = false>(options?: Options<RoomPostData, ThrowOnError>) => {
    return (options?.client ?? client).post<RoomPostResponses, RoomPostErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/room',
        ...options,
        headers: {
            'Content-Type': 'application/json-patch+json',
            ...options?.headers
        }
    });
};

/**
 * Get Product Sizes
 * **Purpose:** Retrieves the complete list of product sizes available for the authenticated organization for product configuration and inventory management.
 *
 * **Request Requirements:**
 * - Any authenticated role authorization (no specific role required)
 * - No query parameters or request body needed
 *
 * **Response Data:**
 * - Returns array of size objects: `[{ Size }, ...]`
 * - Response format: `[{ Size }, { Size }, ...]`
 * - Example: `[{ "SizeId": 1, "SizeName": "1g", "Description": "One gram flower package" }, { "SizeId": 2, "SizeName": "3.5g", "Description": "Eighth ounce flower package" }, ...]`
 * - Array typically contains 15-40 product sizes per organization
 * - Returns empty array `[]` if no sizes configured (rare)
 * - Includes size ID, name, and measurement details
 * - Standard product sizes (grams, ounces, units, etc.) for cannabis products
 * - Results filtered to authenticated organization level
 *
 * **Common Use Cases:**
 * - Populate product size dropdown lists in product creation forms
 * - Configure product variants with different size options
 * - Support inventory management with size-based tracking
 * - Generate size-specific pricing and inventory reports
 * - Enable e-commerce product configuration with size selections
 *
 * **Performance & Limits:**
 * - Lightweight reference data optimized for frequent access
 * - Small dataset suitable for client-side caching
 * - No pagination needed due to limited number of standard sizes
 * - Results consistent across all locations within organization
 *
 * **Related Endpoints:**
 * - `GET /products` - Get products that use these size configurations
 * - `POST /product` - Create products with size assignments
 * - `GET /inventory` - Get inventory levels by product size
 *
 * **Important Notes:**
 * - Sizes are defined at organization level (LSP) not location level
 * - Standard cannabis industry size configurations for consistency
 * - Used for product configuration and inventory tracking
 * - Essential reference data for product and pricing management
 * - Supports both weight-based and unit-based product sizing
 */
export const sizesGet = <ThrowOnError extends boolean = false>(options?: Options<SizesGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<SizesGetResponses, SizesGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/sizes',
        ...options
    });
};

/**
 * Get Strains
 * **Purpose:** Retrieves all cannabis strains available for the authenticated location with genetic and classification information.
 *
 * **Request Requirements:**
 * - "Inventory" role authorization required for strain data access
 * - No query parameters or request body needed
 *
 * **Response Data:**
 * - Response format: `[{ StrainDetail }, { StrainDetail }, ...]`
 * - Array typically contains 10-100 strains per location
 * - Returns empty array `[]` if no strains configured for location
 * - Results automatically filtered to authenticated location
 * - See `StrainDetail` model for complete field descriptions
 *
 * **Data Filtering:**
 * - Results are automatically scoped to the authenticated location
 * - Only active strains are included in the response
 * - Strain types include full classification information for categorization
 *
 * **Common Use Cases:**
 * - Populate strain dropdown lists in product creation and editing forms
 * - Display available strain genetics for product categorization and filtering
 * - Synchronize strain catalog with external inventory management systems
 * - Generate strain-specific compliance reports and analytics
 * - Support product menu organization by genetic type and characteristics
 * - Cache strain data for offline product creation workflows
 *
 * **Performance & Limits:**
 * - Lightweight data optimized for frequent access and caching
 * - Typically small dataset (10-100 strains) suitable for client-side storage
 * - No pagination needed due to manageable strain catalog sizes per location
 * - Response time typically under 50ms for standard strain catalogs
 * - Safe for frequent polling (recommended: cache for 5-10 minutes)
 *
 * **Integration Patterns:**
 * - **UI Dropdowns**: Cache response locally for form population
 * - **Product Creation**: Use strain IDs for product categorization
 * - **External Sync**: Compare ExternalId values for third-party integration
 * - **Menu Display**: Filter products by strain type and characteristics
 *
 * **Related Endpoints:**
 * - `POST /strains` - Create or update strain information in this catalog
 * - `GET /strains/types` - Get valid strain type classifications for filtering
 *
 * **Important Notes:**
 * - Strain catalog is location-specific and varies by dispensary
 * - External ID values enable synchronization with cultivation management systems
 * - Strain information directly affects product categorization and compliance reporting
 */
export const strainsGet = <ThrowOnError extends boolean = false>(options?: Options<StrainsGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<StrainsGetResponses, StrainsGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/strains',
        ...options
    });
};

export const strainsPost = <ThrowOnError extends boolean = false>(options?: Options<StrainsPostData, ThrowOnError>) => {
    return (options?.client ?? client).post<StrainsPostResponses, StrainsPostErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/strains',
        ...options,
        headers: {
            'Content-Type': 'application/json-patch+json',
            ...options?.headers
        }
    });
};

/**
 * Get Strain Types
 * **Purpose:** Retrieves the list of valid strain type classifications for cannabis strain categorization.
 *
 * **Request Requirements:**
 * - "Inventory" role authorization required for strain data access
 * - No query parameters or request body needed
 *
 * **Response Data:**
 * - Response format: `[string, string, string, string]`
 * - Example: `["Indica", "Sativa", "Hybrid", "CBD"]`
 * - Returns available strain type classifications
 * - Includes standard classifications: Indica, Sativa, Hybrid, CBD
 * - Reference data for strain type validation
 *
 * **Common Use Cases:**
 * - Validate strain type values before creating or updating strains
 * - Populate strain type dropdown lists in user interfaces
 * - Reference data for strain classification validation
 * - Support product categorization by genetic type
 * - Ensure consistency in strain type terminology
 *
 * **Performance & Limits:**
 * - Reference data with immediate response
 * - Small dataset suitable for frequent caching
 * - No location filtering needed for standard classifications
 * - Consistent across all locations and organizations
 *
 * **Related Endpoints:**
 * - `POST /strains` - Create or update strains (validates against these types)
 * - `GET /strains` - Get all strains with their assigned types
 *
 * **Important Notes:**
 * - These are the only valid values accepted for strain type in strain creation/updates
 * - Values are case-sensitive when used in strain operations
 * - Standard cannabis industry classifications for genetic types
 * - Used for product menu organization and customer filtering
 */
export const strainsTypesGet = <ThrowOnError extends boolean = false>(options?: Options<StrainsTypesGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<StrainsTypesGetResponses, StrainsTypesGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/strains/types',
        ...options
    });
};

/**
 * Get Tables
 * **Purpose:** Retrieve dining tables or seating areas configured for the location to support hospitality operations and table management.
 *
 * **Request Requirements:**
 * - "Room" role authorization required for table data access
 * - Optional filtering parameters available for specific table lookup
 * - Table management permissions for hospitality operations
 *
 * **Response Data:**
 * - Returns array of `Table` objects with table identification details
 * - Array typically contains 10-100 tables depending on hospitality operation size
 * - Returns empty array `[]` if no tables match criteria (not null)
 * - Includes table identification and naming information (TableId, TableName)
 * - Results automatically filtered to authenticated location
 *
 * **Filtering Options:**
 * - **tableId**: Optional integer parameter to retrieve specific table by ID
 * - **tableName**: Optional string parameter to search tables by name
 * - **Combined Filtering**: Parameters can be used together for precise table lookup
 * - **No Filters**: Returns all tables when no parameters provided
 *
 * **Table Information Included:**
 * - **TableId**: Unique identifier for each dining table or seating area
 * - **TableName**: Human-readable name for table identification and assignment
 *
 * **Common Use Cases:**
 * - Populate table dropdown lists in reservation and seating management
 * - Display available tables for customer seating assignments
 * - Support hospitality operation table management and configuration
 * - Enable table-specific service tracking and order management
 * - Facilitate dining room management and table allocation workflows
 *
 * **Performance & Limits:**
 * - Efficient table lookup optimized for hospitality operation workflows
 * - Flexible filtering for specific table management needs
 * - No pagination needed for typical table counts per location
 * - Results consistent across hospitality and service management systems
 *
 * **Related Endpoints:**
 * - `POST /table` - Create or update table configuration
 * - `GET /guest-list` - View guest check-ins by table assignments
 * - `POST /transaction` - Process transactions linked to table service
 *
 * **Important Notes:**
 * - **Hospitality Integration**: Essential for dining room management and table service
 * - **Table Management**: Supports table configuration and seating assignments
 * - **Location Specific**: Results filtered to authenticated location table setup
 * - **Service Ready**: Table data used throughout hospitality service workflows
 * - **Flexible Lookup**: Multiple filtering options for precise table management
 */
export const tableTablesGet = <ThrowOnError extends boolean = false>(options?: Options<TableTablesGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<TableTablesGetResponses, TableTablesGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/table/tables',
        ...options
    });
};

/**
 * Create or Update Table
 * **Purpose:** Create a new dining table or update an existing table configuration for hospitality operations and seating management.
 *
 * **Request Requirements:**
 * - "Room" role authorization required for table data modification
 * - `Table` object in request body with table information
 * - Content-Type: application/json
 * - Table management permissions for hospitality operations
 *
 * **Response Data:**
 * - Returns single `Table` object (not array) with updated table information
 * - Includes assigned TableId for new tables or updated ID for existing tables
 * - Complete table information with all fields populated (TableId, TableName)
 * - Table identification and naming information
 *
 * **Create vs Update Behavior:**
 * - **CREATE**: When TableId is null or 0, a new table record will be created
 * - **UPDATE**: When TableId is provided with a positive integer, the existing table will be updated
 * - **Identification**: Table existence determined by TableId value (null/0 = create, positive = update)
 * - **Automatic Detection**: System automatically determines create vs update based on TableId
 *
 * **Table Data Fields:**
 * - **TableId**: Unique identifier for table (null/0 for new tables, positive integer for updates)
 * - **TableName**: Human-readable name for table identification and assignment
 *
 * **Common Use Cases:**
 * - Add new dining tables to hospitality seating configuration
 * - Update existing table names or configuration details
 * - Modify table setup for dining room reorganization
 * - Create table assignments for hospitality service workflows
 * - Support dining room management and table allocation systems
 *
 * **Performance & Limits:**
 * - Single table operation for targeted table management
 * - Immediate table configuration update reflected in hospitality systems
 * - Optimized for dining room management and seating workflows
 * - Changes reflected immediately in table assignment and service systems
 *
 * **Related Endpoints:**
 * - `GET /table/tables` - Retrieve existing table configuration before updates
 * - `GET /guest-list` - View guest check-ins that use table assignments
 * - `POST /transaction` - Process transactions linked to table service
 *
 * **Important Notes:**
 * - **TableId Assignment**: New tables receive automatically generated TableId
 * - **Hospitality Integration**: Table configuration affects seating and service workflows
 * - **Location Scoped**: Tables automatically associated with authenticated location
 * - **Service Ready**: Table data immediately available for hospitality operations
 * - **Configuration Management**: Supports dining room setup and table organization
 */
export const tablePost = <ThrowOnError extends boolean = false>(options?: Options<TablePostData, ThrowOnError>) => {
    return (options?.client ?? client).post<TablePostResponses, TablePostErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/table',
        ...options,
        headers: {
            'Content-Type': 'application/json-patch+json',
            ...options?.headers
        }
    });
};

/**
 * Get Tags
 * **Purpose:** Retrieve all inventory tracking tags available for the location to support inventory management and regulatory compliance tracking.
 *
 * **Request Requirements:**
 * - "Inventory" role authorization required for tag data access
 * - No query parameters or request body needed
 * - Inventory management permissions for tag tracking operations
 *
 * **Response Data:**
 * - Returns array of `Tag` objects with tag identification information
 * - Array typically contains 100-10,000 tags depending on facility operation size
 * - Returns empty array `[]` if no tags are available (not null)
 * - Includes tag names and unique identifiers for inventory assignment
 * - Results automatically filtered to authenticated service provider level
 *
 * **Tag Information Included:**
 * - **TagId**: Unique numeric identifier for each tag
 * - **TagName**: Human-readable name or label for the tag
 * - **Assignment Ready**: Tag information available for inventory assignment operations
 *
 * **Common Use Cases:**
 * - Populate tag dropdown lists in inventory management interfaces
 * - Display available tags for plant and package assignment workflows
 * - Support inventory tracking and regulatory compliance operations
 * - Enable tag allocation and assignment for cultivation and retail workflows
 * - Facilitate state system integration and regulatory reporting requirements
 *
 * **Performance & Limits:**
 * - Comprehensive tag data retrieval for inventory management
 * - Service provider level tag access for facility operations
 * - Optimized for inventory tracking and compliance workflows
 * - Results include all available tags for assignment and tracking
 *
 * **Related Endpoints:**
 * - `POST /package/set-tags` - Assign tags to inventory packages
 * - `POST /package/add-tags` - Add additional tags to packages
 * - `POST /package/remove-tags` - Remove tags from inventory packages
 *
 * **Important Notes:**
 * - **Compliance Critical**: Essential for regulatory compliance and state system integration
 * - **Inventory Integration**: Tag data used throughout inventory tracking workflows
 * - **Service Provider Scoped**: Tags filtered to authenticated service provider level
 * - **Assignment Ready**: Tag data immediately available for inventory assignment operations
 * - **Regulatory Tracking**: Tags support state system compliance and audit requirements
 */
export const tagGet = <ThrowOnError extends boolean = false>(options?: Options<TagGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<TagGetResponses, TagGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/tag',
        ...options
    });
};

/**
 * Get Terminals
 * **Purpose:** Retrieve all point-of-sale terminals configured for the location to support transaction processing and retail operations.
 *
 * **Request Requirements:**
 * - Valid API key authentication required for terminal data access
 * - No specific role restrictions beyond authentication
 * - No query parameters or request body needed
 *
 * **Response Data:**
 * - Returns array of `Terminal` objects with terminal identification information
 * - Response format: `[{ Terminal }, { Terminal }, ...]`
 * - Array typically contains 1-10 terminals depending on retail operation size
 * - Returns empty array `[]` if no terminals are configured (not null)
 * - Includes terminal identification and naming information only
 * - Results automatically filtered to authenticated location
 *
 * **Terminal Information Included:**
 * - **TerminalId**: Unique numeric identifier for each point-of-sale terminal
 * - **TerminalName**: Human-readable name for terminal identification
 *
 * **Common Use Cases:**
 * - Populate terminal dropdown lists in transaction processing interfaces
 * - Display available terminals for cashier assignment and management
 * - Support point-of-sale system configuration and setup
 * - Enable terminal-specific transaction tracking and reporting
 * - Facilitate retail operation management and terminal allocation
 *
 * **Performance & Limits:**
 * - Lightweight operation optimized for frequent terminal lookups
 * - Small dataset suitable for real-time retail operation workflows
 * - No pagination needed due to limited terminal counts per location
 * - Results consistent across point-of-sale and transaction systems
 *
 * **Related Endpoints:**
 * - `POST /transaction` - Process transactions using configured terminals
 * - `GET /reporting/register-transactions` - View terminal-specific transaction history
 * - `GET /reporting/cash-summary` - Terminal cash management and reconciliation
 *
 * **Important Notes:**
 * - **Retail Integration**: Essential for point-of-sale operations and transaction processing
 * - **Terminal Management**: Supports retail terminal configuration and assignment
 * - **Location Specific**: Results filtered to authenticated location terminal setup
 * - **Real-time Access**: Current terminal availability and configuration information
 * - **Transaction Ready**: Terminal data used throughout retail transaction workflows
 */
export const terminalsGet = <ThrowOnError extends boolean = false>(options?: Options<TerminalsGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<TerminalsGetResponses, TerminalsGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/terminals',
        ...options
    });
};

/**
 * Create Anonymous Customer Transaction
 * **Purpose:** Create an anonymous customer profile and automatically check them into the dispensary guest list for pickup or service.
 *
 * **Request Requirements:**
 * - "PreOrder" role authorization required for transaction creation
 * - `CreateAnonymousTransactionRequest` object in request body
 * - Content-Type: application/json
 * - Optional transaction reference for internal tracking
 *
 * **Response Data:**
 * - Returns anonymous transaction object: `{ AnonymousTransaction }`
 * - CustomerId: Temporary customer identifier for this session
 * - TransactionId: Transaction identifier for order processing and tracking
 * - UniqueId: System-generated unique identifier for customer lookup
 *
 * **Process Flow:**
 * 1. Anonymous profile creation: Generate temporary customer record with unique identifier
 * 2. Guest list check-in: Automatically add customer to dispensary queue/guest list
 * 3. Transaction setup: Create transaction record for order processing
 * 4. Unique tracking: Assign unique ID for following up on order status
 *
 * **Common Use Cases:**
 * - Process walk-in customers without pre-existing accounts
 * - Provide quick service for customers who prefer not to create full accounts
 * - Handle one-time or occasional customers efficiently
 * - Accommodate privacy-focused customers who prefer minimal data collection
 * - Bridge anonymous sales with customer tracking systems for POS integration
 *
 * **Performance & Limits:**
 * - Immediate customer profile and transaction creation
 * - Automatic guest list integration for streamlined workflow
 * - Temporary records designed for single-session use
 * - Optimized for high-volume walk-in customer processing
 *
 * **Related Endpoints:**
 * - `POST /preorder/submit` - Create orders for existing customers with full profiles
 * - `GET /guest-list` - View current guest list including anonymous customers
 *
 * **Important Notes:**
 * - Anonymous customer profiles are temporary and session-based
 * - Customer automatically appears in dispensary queue/guest list
 * - Optional transaction reference field for external system correlation
 * - Each anonymous customer gets a unique system identifier
 * - Minimal data collection while maintaining operational requirements
 * - Choose this for walk-ins who don't want accounts; use preorder endpoints for existing customers
 */
export const transactionCreateAnonymousPost = <ThrowOnError extends boolean = false>(options?: Options<TransactionCreateAnonymousPostData, ThrowOnError>) => {
    return (options?.client ?? client).post<TransactionCreateAnonymousPostResponses, TransactionCreateAnonymousPostErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/transaction/create-anonymous',
        ...options,
        headers: {
            'Content-Type': 'application/json-patch+json',
            ...options?.headers
        }
    });
};

/**
 * Generate Authorization Header
 * **Purpose:** Convert an API key into a properly formatted authorization header for initial API client setup and testing.
 *
 * **Intended Use:** This utility endpoint is designed for initial setup and testing workflows. For production applications, consider encoding headers client-side using Base64: `Basic {base64(api_key:)}`
 *
 * **Request Requirements:**
 * - No authentication required - public utility endpoint
 * - API key provided as URL path parameter
 * - Utility function for API client development and testing
 *
 * **Response Data:**
 * - Returns single string value (not array) with formatted authorization header
 * - Basic authentication header format: "Basic [base64-encoded-api-key]"
 * - Ready-to-use authorization header value for HTTP clients
 * - Base64 encoded API key in standard HTTP Basic authentication format
 *
 * **Authorization Header Format:**
 * - **Encoding**: API key converted to Base64 ASCII encoding
 * - **Format**: "Basic {base64-encoded-key}" format for HTTP Authorization header
 * - **Standards Compliant**: Follows HTTP Basic Authentication specification
 * - **Client Ready**: Direct usage in HTTP client authorization headers
 *
 * **Common Use Cases:**
 * - Initial API client setup and configuration
 * - Development and testing workflows
 * - Manual header generation for API testing tools
 * - Integration development and troubleshooting
 *
 * **Related Endpoints:**
 * - `GET /whoami` - Verify API key validity and location access
 * - `GET /health` - Test basic API connectivity
 * - All other endpoints that require the generated authorization header
 *
 * **Important Notes:**
 * - **Public Utility**: No authentication required for this utility endpoint
 * - **Developer Tool**: Designed for API client development and testing support
 * - **Header Generation**: Produces standard HTTP Basic authentication headers
 * - **Standards Compliant**: Follows HTTP Basic Authentication formatting requirements
 */
export const utilAuthorizationHeaderByApiKeyGet = <ThrowOnError extends boolean = false>(options: Options<UtilAuthorizationHeaderByApiKeyGetData, ThrowOnError>) => {
    return (options.client ?? client).get<UtilAuthorizationHeaderByApiKeyGetResponses, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/util/AuthorizationHeader/{apiKey}',
        ...options
    });
};

/**
 * Get Vehicles
 * **Purpose:** Retrieve all vehicles available for delivery and transportation operations to support logistics and compliance tracking.
 *
 * **Request Requirements:**
 * - "Reporting" or "Deliveries" role authorization required for vehicle data access
 * - No query parameters or request body needed
 *
 * **Response Data:**
 * - Response format: `[{ VehicleDetail }, { VehicleDetail }, ...]`
 * - Array typically contains 1-20 vehicles depending on delivery operation size
 * - Returns empty array `[]` if no vehicles are configured (not null)
 * - Includes vehicle identification, specifications, and operational details
 * - License plate numbers, make/model information, and registration data
 * - Results automatically filtered to authenticated location
 *
 * **Vehicle Information Included:**
 * - **Identification**: Vehicle ID, license plate, VIN numbers
 * - **Specifications**: Make, model, year, color, and vehicle type
 * - **Registration**: Registration status and compliance information
 * - **Operational**: Availability status and assignment details
 *
 * **Common Use Cases:**
 * - Populate vehicle dropdown lists in delivery assignment forms
 * - Display vehicle fleet information for logistics management
 * - Support delivery route planning and vehicle allocation
 * - Maintain vehicle records for compliance and regulatory requirements
 * - Generate vehicle utilization reports for operational analysis
 *
 * **Performance & Limits:**
 * - Lightweight operation optimized for frequent vehicle lookups
 * - Small dataset suitable for real-time delivery assignment workflows
 * - No pagination needed due to limited fleet sizes
 * - Results consistent across delivery management operations
 *
 * **Related Endpoints:**
 * - `POST /vehicles` - Create or update vehicle information
 * - `GET /drivers` - Get drivers who can operate vehicles
 * - `POST /deliveries/set-route-detail` - Assign vehicles to delivery routes
 *
 * **Important Notes:**
 * - **Fleet Management**: Essential for delivery operations and logistics coordination
 * - **Compliance Ready**: Vehicle data supports regulatory compliance and tracking
 * - **Location Specific**: Results filtered to authenticated location vehicle fleet
 * - **Real-time Access**: Current vehicle availability and status information
 * - **Delivery Integration**: Vehicle data used throughout delivery assignment workflows
 */
export const vehiclesGet = <ThrowOnError extends boolean = false>(options?: Options<VehiclesGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<VehiclesGetResponses, VehiclesGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/vehicles',
        ...options
    });
};

/**
 * Create or Update Vehicle
 * **Purpose:** Create a new vehicle or update an existing vehicle with comprehensive fleet information for delivery operations and compliance tracking.
 *
 * **Request Requirements:**
 * - "Reporting" or "Deliveries" role authorization required for vehicle data modification
 * - `VehicleDetail` object in request body with vehicle information
 * - Content-Type: application/json
 * - Validation performed on vehicle data before processing
 *
 * **Response Data:**
 * - Response format: `200 OK` (no response body)
 * - No data returned - operation confirmation only
 * - Returns HTTP 400 with validation errors if request data is invalid
 *
 * **Create vs Update Behavior:**
 * - **CREATE**: When VehicleId is null, 0, or omitted, a new vehicle record will be created
 * - **UPDATE**: When VehicleId is provided with a valid vehicle ID, the existing vehicle will be updated
 * - **Identification**: Vehicle existence determined by VehicleId value
 * - **Automatic Detection**: System automatically determines create vs update based on vehicle data
 *
 * **Sparse Update Behavior:**
 * - **Validation Required**: All provided vehicle data must pass validation checks
 * - **Field Updates**: Provided fields will update existing vehicle information
 * - **Data Integrity**: Validation ensures vehicle data meets operational requirements
 * - **Fleet Consistency**: Updates maintain fleet data consistency and compliance standards
 *
 * **Vehicle Data Fields:**
 * - **Identification**: License plate, VIN, vehicle ID
 * - **Specifications**: Make, model, year, color, vehicle type
 * - **Registration**: Registration information and compliance data
 * - **Operational**: Status, availability, and assignment details
 *
 * **Common Use Cases:**
 * - Add new vehicles to delivery fleet for expanded operations
 * - Update existing vehicle information when details change
 * - Maintain vehicle registration and compliance records
 * - Support fleet management and vehicle tracking requirements
 * - Ensure accurate vehicle data for delivery route assignments
 *
 * **Performance & Limits:**
 * - Single vehicle operation for targeted fleet management
 * - Comprehensive validation performed before any changes
 * - Changes reflected immediately in delivery assignment systems
 * - Optimized for fleet management and compliance workflows
 *
 * **Related Endpoints:**
 * - `GET /vehicles` - Retrieve existing vehicle data before updates
 * - `GET /drivers` - Manage driver assignments for vehicles
 * - `POST /deliveries/set-route-detail` - Assign updated vehicles to delivery routes
 *
 * **Important Notes:**
 * - **Validation Critical**: All vehicle data must pass validation before processing
 * - **Fleet Integration**: Vehicle updates affect delivery assignment and logistics systems
 * - **Compliance Essential**: Vehicle data must meet regulatory requirements for delivery operations
 * - **Location Scoped**: Vehicles automatically associated with authenticated location
 * - **Operation Confirmation**: Success indicated by HTTP 200 status (no response body)
 */
export const vehiclesPost = <ThrowOnError extends boolean = false>(options?: Options<VehiclesPostData, ThrowOnError>) => {
    return (options?.client ?? client).post<VehiclesPostResponses, VehiclesPostErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/vehicles',
        ...options,
        headers: {
            'Content-Type': 'application/json-patch+json',
            ...options?.headers
        }
    });
};

/**
 * Get Vendors
 * **Purpose:** Retrieves a list of vendors with optional filtering by vendor ID or name for procurement and inventory management.
 *
 * **Request Requirements:**
 * - "Vendor" role authorization required for vendor data access
 * - Optional query parameters for filtering results
 * - No request body needed
 *
 * **Response Data:**
 * - Response format: `[{ Vendor }, { Vendor }, ...]`
 * - Array typically contains 5-50 vendors per location
 * - Returns empty array `[]` if no vendors configured or match filtering criteria
 * - Includes contact details, address, and license information
 * - Results are automatically filtered by the authenticated user's location
 * - Vendor ID, name, and contact information included
 *
 * **Filtering Options:**
 * - No parameters: Returns all vendors for the location
 * - vendorId: Returns specific vendor by ID
 * - vendorName: Filters vendors by name with partial matching support
 * - Both parameters: Can be used together for more specific filtering
 *
 * **Common Use Cases:**
 * - Populate vendor dropdown lists in purchase order creation forms
 * - Search for specific vendors by name or ID for quick lookup
 * - Synchronize vendor data with external inventory management systems
 * - Display vendor contact information for procurement and purchasing
 * - Maintain vendor databases for supply chain management
 *
 * **Performance & Limits:**
 * - Rate limiting disabled for this endpoint to support frequent lookups
 * - Lightweight response for fast vendor list population
 * - Efficient filtering for large vendor databases
 * - Results cached for improved performance
 *
 * **Related Endpoints:**
 * - `POST /vendor` - Create or update vendor information
 *
 * **Important Notes:**
 * - Results are automatically filtered to the authenticated user's location
 * - Vendor name filtering supports partial matching for flexible search
 * - Both filtering parameters can be used simultaneously for precise results
 * - No rate limiting applied to support frequent vendor lookups
 */
export const vendorVendorsGet = <ThrowOnError extends boolean = false>(options?: Options<VendorVendorsGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<VendorVendorsGetResponses, VendorVendorsGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/vendor/vendors',
        ...options
    });
};

/**
 * Create or Update Vendor
 * **Purpose:** Create a new vendor or update an existing vendor with comprehensive supplier information for procurement and inventory management.
 *
 * **Request Requirements:**
 * - "Vendor" role authorization required for vendor data modification
 * - `Vendor` object in request body with vendor details
 * - Content-Type: application/json
 * - All vendor fields are optional (no validation performed)
 *
 * **Response Data:**
 * - Response format: `{ Vendor }`
 * - Returns single `Vendor` object (not array) with updated vendor information
 * - Includes assigned VendorId for new vendors or updated ID for existing vendors
 * - Complete vendor information with all fields populated
 * - Contact details, address, and license information included
 *
 * **Create vs Update Behavior:**
 * - **CREATE**: When VendorId is null, 0, or omitted, a new vendor record will be created
 * - **UPDATE**: When VendorId is provided with a valid vendor ID, the existing vendor will be updated
 * - **Identification**: Vendor existence determined by VendorId value
 * - **Automatic Detection**: System automatically determines create vs update based on VendorId
 *
 * **Sparse Update Behavior:**
 * - **No Required Fields**: All fields are optional
 * - **Optional Fields**: Address, contact, and license fields can be omitted to preserve existing values
 * - **Null Handling**: Null values will overwrite existing data (use with caution)
 * - **Field Independence**: Each field can be updated independently
 *
 * **Required Fields:**
 * - **None**: No validation is performed on any fields
 *
 * **Optional Fields:**
 * - **Address, City, State, PostalCode**: Physical address information for shipping and contact
 * - **LicenseNumber**: Vendor's business license number for compliance tracking
 * - **ContactName, ContactEmail, ContactPhone**: Primary contact information for procurement
 *
 * **Common Use Cases:**
 * - Add new suppliers to the vendor database for procurement management
 * - Update existing vendor contact information when details change
 * - Maintain vendor address and license details for compliance
 * - Establish vendor relationships for purchase orders and inventory management
 * - Synchronize vendor data with external procurement systems
 *
 * **Performance & Limits:**
 * - Single vendor operation for targeted supplier management
 * - Immediate validation and response with complete vendor data
 * - Changes reflected immediately in vendor catalogs and purchase order systems
 * - Optimized for vendor relationship management workflows
 *
 * **Related Endpoints:**
 * - `GET /vendor/vendors` - Retrieve existing vendor data before updates
 * - `POST /purchase-orders` - Create purchase orders using vendor relationships
 * - `GET /inventory` - View inventory from specific vendors
 *
 * **Important Notes:**
 * - **VendorId Assignment**: New vendors receive automatically generated VendorId
 * - **No Validation**: No validation is performed before creation/update
 * - **Supplier Relationships**: Vendor data used throughout procurement and inventory systems
 * - **Location Scoped**: Vendors automatically associated with authenticated location
 * - **Contact Management**: Maintain accurate contact information for effective supplier communication
 */
export const vendorPost = <ThrowOnError extends boolean = false>(options?: Options<VendorPostData, ThrowOnError>) => {
    return (options?.client ?? client).post<VendorPostResponses, VendorPostErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/vendor',
        ...options,
        headers: {
            'Content-Type': 'application/json-patch+json',
            ...options?.headers
        }
    });
};

/**
 * Get Waste Records
 * **Purpose:** Retrieve comprehensive waste disposal records for cultivation and compliance tracking to support regulatory reporting and facility management.
 *
 * **Request Requirements:**
 * - "CultivationWrite" role authorization required for waste data access
 * - No query parameters or request body needed
 * - Waste tracking permissions essential for compliance operations
 *
 * **Response Data:**
 * - Returns single `WasteSummary` object (not array) with comprehensive waste information
 * - Response format: `{ WasteSummary }`
 * - Includes categorized waste records by type and source
 * - Contains room waste, harvest waste, and plant waste details
 * - Waste disposal tracking and compliance documentation
 * - Results automatically filtered to authenticated location
 *
 * **Waste Categories Included:**
 * - **Room Waste**: General cultivation room waste disposal records
 * - **Harvest Waste**: Plant material disposal from harvest operations
 * - **Plant Waste**: Individual plant disposal and destruction records
 *
 * **Common Use Cases:**
 * - Generate regulatory compliance reports for waste disposal
 * - Track cultivation facility waste management and disposal
 * - Support compliance audits and regulatory inspections
 * - Monitor waste disposal efficiency and facility operations
 * - Maintain cultivation facility waste tracking for legal requirements
 *
 * **Performance & Limits:**
 * - Comprehensive waste data retrieval for facility management
 * - Location-specific waste records for compliance tracking
 * - Optimized for regulatory reporting and compliance workflows
 * - Results include all waste categories and disposal records
 *
 * **Related Endpoints:**
 * - `GET /harvest` - View harvest operations that generate waste
 * - `GET /plant` - Track plants before waste disposal
 * - `POST /plant/harvest` - Harvest operations that create waste records
 *
 * **Important Notes:**
 * - **Compliance Critical**: Essential for regulatory compliance and waste tracking
 * - **Cultivation Focus**: Specific to cultivation facility waste management
 * - **Location Scoped**: Waste records filtered to authenticated location
 * - **Regulatory Ready**: Data formatted for compliance reporting requirements
 * - **Disposal Tracking**: Comprehensive waste disposal and destruction records
 */
export const wasteGet = <ThrowOnError extends boolean = false>(options?: Options<WasteGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<WasteGetResponses, WasteGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/waste',
        ...options
    });
};

export const wasteHarvestWastePost = <ThrowOnError extends boolean = false>(options?: Options<WasteHarvestWastePostData, ThrowOnError>) => {
    return (options?.client ?? client).post<WasteHarvestWastePostResponses, WasteHarvestWastePostErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/waste/HarvestWaste',
        ...options,
        headers: {
            'Content-Type': 'application/json-patch+json',
            ...options?.headers
        }
    });
};

export const wastePlantWastePost = <ThrowOnError extends boolean = false>(options?: Options<WastePlantWastePostData, ThrowOnError>) => {
    return (options?.client ?? client).post<WastePlantWastePostResponses, WastePlantWastePostErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/waste/PlantWaste',
        ...options,
        headers: {
            'Content-Type': 'application/json-patch+json',
            ...options?.headers
        }
    });
};

/**
 * Verify API key and get location identity information
 * **Purpose:** Verifies your API key is valid and returns detailed information about the location/store it's associated with.
 *
 * **Request Requirements:**
 * - Any authenticated role authorization (no specific role required)
 * - No query parameters or request body needed
 *
 * **Response Data:**
 * - Response format: `{ LocationIdentity }`
 * - Returns location identity object with complete location and company information
 * - Location details including name, address, license number, and business information
 * - Parent company (LSP) details and global identifiers
 * - Configuration settings like customer profile sharing preferences
 * - Regional data for compliance and routing
 *
 * **Common Use Cases:**
 * - Confirm your API key is working correctly for API key validation
 * - Identify which store/location your API key accesses for location discovery
 * - Determine current location context for multi-location applications
 * - Get location details for application initialization and configuration setup
 * - Troubleshoot authentication and location access issues during debugging
 *
 * **Performance & Limits:**
 * - Lightweight operation with immediate response
 * - No rate limiting typically applied to identity verification
 * - Recommended as first call when setting up API integration
 * - Cached results can be used for session duration
 *
 * **Related Endpoints:**
 * - No direct related endpoints - this is a foundational identity endpoint
 *
 * **Important Notes:**
 * - Call this endpoint first when setting up API integration
 * - Verify authentication and understand your location context before other calls
 * - Response includes both location-specific and company-wide identifiers
 * - Regional information helps with compliance and API routing decisions
 *
 * **Response Fields:**
 * - `LocationId` / `LocationName` for store identification
 * - `LspId` / `LspName` for parent company information
 * - `Address`, `City`, `State`, `PostalCode` for physical location
 * - `LicenseNumber` for business license and compliance
 * - `ShareCustomerProfiles` for customer data sharing configuration
 * - `LocationGlobalId` / `LspGlobalId` for global unique identifiers
 */
export const whoamiGet = <ThrowOnError extends boolean = false>(options?: Options<WhoamiGetData, ThrowOnError>) => {
    return (options?.client ?? client).get<WhoamiGetResponses, WhoamiGetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'basic',
                type: 'http'
            }
        ],
        url: '/whoami',
        ...options
    });
};
